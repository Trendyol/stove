{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Stove?","text":"<p>Stove is an end-to-end testing framework that spins up physical dependencies and your application all together. So you have a control over dependencies via Kotlin code.  Your tests will be infra agnostic, but component aware, so they can use easily necessary physical components with Stove provided APIs.  All the infra is pluggable, and can be added easily. You can also create your own infra needs by using the abstractions that Stove provides. Having said that, the only dependency is <code>docker</code> since Stove is using testcontainers underlying.</p> <p>You can use JUnit and Kotest for running the tests. You can run all the tests on your CI, too. But that needs DinD(docker-in-docker) integration.</p> <p>The medium story about the motivation behind the framework: A New Approach to the API End-to-End Testing in Kotlin</p>"},{"location":"#high-level-architecture","title":"High Level Architecture","text":""},{"location":"#how-to-build-the-source-code","title":"How to build the source code?","text":"<ul> <li>JDK 16+</li> <li>Docker for running the tests (please use the latest version)</li> </ul> <pre><code>./gradlew build # that will build and run the tests\n</code></pre>"},{"location":"#how-to-get","title":"How to get?","text":"<p>The framework still under development and is getting matured. In general it is working well and in use at Trendyol. Since it should be located under your testing context it is risk-free to apply and use, give it a try!</p> <p>The current version is going with strategy of <code>SNAPSHOT</code> hence you can get the library from the snapshot repository.</p> <p>Overview of the snapshot versions of Stove</p> <p><code>$version = please check the current version</code></p> GradleMaven <p>You need to enable snapshot repository settings first to get it. Navigate to the file that you define your repositories. <pre><code>repositories {\n    mavenCentral() // you probably have already\n    maven { // code to be added\n        url = uri(\"https://oss.sonatype.org/content/repositories/snapshots\")\n    }\n}\n</code></pre> Now, navigate to your dependencies section, and add the dependencies according to your testing needs.</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-testing-e2e:$version\")\n}\n</code></pre> <p>You need to enable snapshot repository settings in <code>~/.m2/settings.xml</code> or settings.xml file in your project folder. Modifying <code>pom.xml</code> also works. Either way, make sure that these xml block is located in one of the places.</p> <p>If you can't manage please look at this StackOverflow answer.</p> <pre><code>  &lt;profiles&gt;\n  &lt;profile&gt;\n     &lt;id&gt;allow-snapshots&lt;/id&gt;\n        &lt;activation&gt;\n            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n        &lt;/activation&gt;\n     &lt;repositories&gt;\n       &lt;repository&gt;\n         &lt;id&gt;snapshots-repo&lt;/id&gt;\n         &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n         &lt;releases&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/releases&gt;\n         &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;\n       &lt;/repository&gt;\n     &lt;/repositories&gt;\n   &lt;/profile&gt;\n&lt;/profiles&gt;\n</code></pre> <p>Now you can add dependencies.</p> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-couchbase&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt; \n\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-http&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt; \n\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-wiremock&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt; \n</code></pre>"},{"location":"#how-to-write-tests","title":"How To Write Tests?","text":"<p>You can start looking at the ways of testing an application with Stove. These are explained in detail under the corresponding sections.</p>"},{"location":"#1-application-aware-recommended","title":"1. Application Aware (recommended)","text":""},{"location":"#2-dockerized","title":"2. Dockerized","text":""},{"location":"how-to-write-tests/","title":"How To Write Tests?","text":"<p>There are two ways of testing. If you are using a framework in your application for example, you may attach Stove to your application, so that you can debug and look with a magnifying glass to your code base. This is especially helpful when one wants to see how code works when the physical dependencies are present. Because, unit and integration tests stay short for the deeper insights when it comes to the behaviour of the system on production.</p>"},{"location":"how-to-write-tests/#figuring-out-the-dependencies","title":"Figuring out the dependencies","text":"<p>Your project might likely have dependencies for Couchbase, Kafka, and external http services. In the application context we will spin up instances of Couchbase and Kafka but not the external http services because you don't manage them, instead we will mock them using Wiremock.</p>"},{"location":"how-to-write-tests/#docker-dependencies","title":"Docker Dependencies","text":"<p>Info</p> <p>You can skip this step if your registry has already the docker images</p> <p>Docker dependencies are already hosted on trendyol registry, you need to be logged in to YOUR_REGISTRY in your local docker to be able to pull the dependencies when the e2e tests run.</p> <pre><code> docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest  \n docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest\n</code></pre> <p>Note</p> <p>Please make sure that you tag/upload the docker images as cross build to support developers that use ARM and AMD microprocessors. In the example above, as you can see uses <code>buildx</code> to create/tag cross-platform docker images and pushes them directly to the registry.</p>"},{"location":"how-to-write-tests/#choose-your-testing-strategy","title":"Choose your testing strategy","text":"<ul> <li>I will run my application alongside Stove E2e testing framework (recommended)</li> <li>I will use docker image of my application</li> </ul>"},{"location":"how-to-write-tests/1.Application-Aware/","title":"Application Aware Testing","text":"<p>There are entry point for every application, usually a <code>main</code> method that is invoked, and starts the application lifecycle. If you are publishing your <code>application/api/microservice</code> as a docker image, <code>docker run ...</code> basically runs your application highly likely with a <code>jvm/java</code> command.</p> <p>In this approach, we're using the <code>main</code> function of your application in the test context to run the application as full-blown as if it is invoked from outside.</p> <p>Stove calls your application's <code>main</code> function like you would call <code>java yourApplicationName.jar</code> to run the application from the test context. So the runner is JUnit or Kotest.</p> <p>For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter. We will discuss this later.</p>"},{"location":"how-to-write-tests/1.Application-Aware/#when-to-use-this-approach","title":"When to use this approach?","text":"<p>This approach has lots of benefits besides of providing a debug ability while e2e testing. With this approach, you can:</p> <ul> <li>Debug the application code</li> <li>Replace the implementations of the interfaces. Useful for time-bounded implementations such as schedulers, background   workers, and time itself.</li> <li>Have more control over Kafka messages, you would have control over publishing and consuming,   with dockerized approach   you would only have consuming.</li> <li>Use and expose application's dependency container. This is useful if you want to write your own system.   Say, if you have a dependency that Stove didn't implement yet, you can go ahead and implement it yourself by using the   abstractions. We will discuss it later.</li> </ul>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/","title":"Testing a Spring Boot Application","text":"<p>Here you can jump immediately to the Spring example application.</p> <p>You need to add the Stove-Spring dependency to be able to write e2e tests for the Spring application.</p> <p><code>$version = please check the current version</code></p> GradleMaven <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n}\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-spring-testing-e2e&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-http&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre> <p>Do not forget to add the other dependencies and configure your maven repository settings first.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/0001-tuning-app/","title":"Tuning the application's entry point","text":"<p>Note</p> <p>This change is an optional change. If you don't have any unpredictable components to alter, like, time, scheduler, etc... Or if you don't want to have full observability over Kafka you can leave the main function as is.  But, still we recommend this change, as you might have components to change in the future.</p> <p>Let's say the application has a standard <code>main</code> function, here how we will change it:</p> BeforeAfter <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { runApplication&lt;ExampleApplication&gt;(*args) }\n</code></pre> <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { run(args) }\n\nfun run(\n     args: Array&lt;String&gt;,\n     init: SpringApplication.() -&gt; Unit = {},\n  ): ConfigurableApplicationContext {\n        return runApplication&lt;ExampleApplication&gt;(*args, init = init)\n    }\n</code></pre> <p>As you can see from <code>before-after</code> sections, we have divided the application main function into two parts.</p> <p><code>run(args, init)</code> method is the important point for the testing configuration. <code>init</code> allows us to override any dependency from the testing side that is being <code>time</code> related or <code>configuration</code> related. Spring itself opens this configuration higher order function to the outside.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/0002-initial-configuration/","title":"Initial Configuration","text":"<p>After you've added the dependencies, and configured the application's <code>main</code> function, it is time to run your application for the first time from the test-context with Stove.</p> <p>Note</p> <p>At this stage you can create a new e2e testing module, or use your existing test module in your project.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/0002-initial-configuration/#setting-up-stove-for-the-runner","title":"Setting up Stove for the Runner","text":"KotestJUnit <p>It implements <code>AbstractProjectConfig</code> from Kotest framework that allows us to spin up Stove per run. This is project wide operation and executes only one time, as the name implies <code>beforeProject</code>.</p> <pre><code>class TestSystemConfig : AbstractProjectConfig() {\n\n    override suspend fun beforeProject(): Unit = \n        TestSystem()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions {\n                        baseUrl = \"http://localhost:8001\"\n                    }\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n\n    override suspend fun afterProject(): Unit = TestSystem.stop()\n}\n</code></pre> <pre><code>class TestSystemConfig {\n\n    @BeforeAll\n    fun beforeProject() = runBlocking {\n         TestSystem()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions {\n                        baseUrl = \"http://localhost:8001\"\n                    }\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n    }\n\n    @AfterAll\n    fun afterProject() = runBlocking {\n        TestSystem.stop()\n    }\n}\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/0002-initial-configuration/#configuring-systemundertest","title":"Configuring systemUnderTest","text":"<p>We may know the concept of <code>service under test</code> from the Test-Driven-Development.</p> <p>Here we have the similar concept, since we're testing the entire system, it is called <code>systemUnderTest</code></p> <p>Every TestSystem must have a system under test, and configure it. In here we're configuring a Spring application under test.</p> <p><code>systemUnderTest</code> configures how to run the application. <code>runner</code> parameter is the entrance point for the Spring application that we have configured at step 1</p> <p>Note</p> <p><code>server.port=8001</code> is a Spring config, TestSystem's <code>baseUrl</code> needs to match with it, since Http requests are made against the <code>baseUrl</code> that is defined. <code>withDefaultHttp</code> creates a WebClient and uses the <code>baseUrl</code> that is passed.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/0003-writing-tests/","title":"Writing Tests","text":"<p>Here is an example test that validates <code>http://localhost:$port/hello/index</code> returns the expected text</p> KotestJUnit <pre><code>class ExampleTest: FunSpec({\n\n    test(\"should return hi\"){\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n})\n</code></pre> <pre><code>class ExampleTest {\n\n    @Test\n    fun `should return hi`() {\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n    }\n})\n</code></pre> <p>That's it! You have up-and-running API, can be tested with Stove.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/advanced/0001-Replacing%20Dependencies%20for%20Better%20Testability/","title":"Replacing Dependencies For Better Testability","text":"<p>When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is <code>advancing</code> the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented.</p> <p>For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation.</p> <pre><code>class BackgroundCommandBusImpl // is the class for delayed operations\n</code></pre> <p>We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write:</p> <pre><code>class NoDelayBackgroundCommandBusImpl(\n    backgroundMessageEnvelopeDispatcher: BackgroundMessageEnvelopeDispatcher,\n    backgroundMessageEnvelopeStorage: BackgroundMessageEnvelopeStorage,\n    lockProvider: CouchbaseLockProvider,\n) : BackgroundCommandBusImpl(\n    backgroundMessageEnvelopeDispatcher,\n    backgroundMessageEnvelopeStorage,\n    lockProvider\n) {\n\n    override suspend fun &lt;TNotification : BackgroundNotification&gt; publish(\n        notification: TNotification,\n        options: BackgroundOptions,\n    ) {\n        super.publish(notification, options.withDelay(0))\n    }\n\n    override suspend fun &lt;TCommand : BackgroundCommand&gt; send(\n        command: TCommand,\n        options: BackgroundOptions,\n    ) {\n        super.send(command, options.withDelay(0))\n    }\n}\n</code></pre> <p>Now, it is time to tell to e2eTest system to use NoDelay implementation.</p> <p>That brings us to initializers.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/advanced/0002-writing-your-own-test-system/","title":"Writing Your Own TestSystem","text":"<pre><code>fun TestSystem.withSchedulerSystem(): TestSystem {\n    getOrRegister(SchedulerSystem(this))\n    return this\n}\n\nfun TestSystem.scheduler(): SchedulerSystem = getOrNone&lt;SchedulerSystem&gt;().getOrElse {\n    throw SystemNotRegisteredException(SchedulerSystem::class)\n}\n\nclass SchedulerSystem(override val testSystem: TestSystem) : AfterRunAware&lt;ApplicationContext&gt;, PluggedSystem {\n\n    private lateinit var scheduler: WaitingRoomScheduler\n    private lateinit var backgroundCommandBus: BackgroundCommandBusImpl\n\n    fun advance(): SchedulerSystem {\n        scheduler.publishValidProducts()\n        return this\n    }\n\n    fun advanceBackgroundCommandBus(): SchedulerSystem {\n        backgroundCommandBus.dispatchTimeoutNotifications()\n        return this\n    }\n\n    override suspend fun afterRun(context: ApplicationContext) {\n        scheduler = context.getBean()\n        backgroundCommandBus = context.getBean()\n    }\n\n    override fun close() {}\n}\n</code></pre> <p>Later you can use it in testing;</p> <pre><code>.then().scheduler().advance()\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/advanced/0002-writing-your-own-test-system/#accessing-an-application-dependency-with-a-system","title":"Accessing an application dependency with a system","text":"<p>As you can see, in the example above, if a system implements <code>AfterRunAware&lt;ApplicationContext&gt;</code> then, <code>afterRun</code> method becomes available, in here we have access to applications dependency container to resolve any bean we need to use.</p> <pre><code>override suspend fun afterRun(context: ApplicationContext) {\n    scheduler = context.getBean()\n    backgroundCommandBus = context.getBean()\n}\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/advanced/0003-Writing-A-Test-Initializer/","title":"Writing a TestInitializer","text":"<p>The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective.</p> <p>e2e Testing has dependencies:</p> <ul> <li><code>ObjectMapper</code>, you can either provide the ObjectMapper you have already in here we get existing bean by <code>ref(\"objectMapper\")</code></li> <li><code>TestSystemInterceptor</code> is for being able to check consumed messages</li> </ul> <pre><code>class TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;TestSystemInterceptor&gt;(isPrimary = true)\n    bean&lt;ObjectMapper&gt; { ref(\"objectMapper\") } // \"objectMapper\" bean name should be in your spring context otherwise it will fail, if not you can provide an instance here.\n    // Be sure that, Couchbase, Kafka and other systems share the same serialization strategy.\n    bean&lt;NoDelayBackgroundCommandBusImpl&gt;(isPrimary = true) // Optional dependency to alter delayed implementation with 0-wait.\n})\n\nfun SpringApplication.addTestDependencies() {\n    this.addInitializers(TestInitializer())\n}\n</code></pre> <p><code>addTestDependencies</code> is an extension that helps us to register our dependencies in the application.</p> <pre><code>.systemUnderTest(\n    runner = { parameters -&gt;\n        com.trendyol.exampleapp.run(parameters) {\n            addTestDependencies()\n        }\n    },\n    withParameters = listOf(\n        \"logging.level.root=error\",\n        \"logging.level.org.springframework.web=error\",\n        \"spring.profiles.active=default\",\n        \"server.http2.enabled=false\",\n        \"kafka.heartbeatInSeconds=2\",\n        \"kafka.autoCreateTopics=true\",\n        \"kafka.offset=earliest\"\n    )\n)\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/","title":"Dependencies","text":"<ul> <li>Kafka</li> </ul>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/","title":"Kafka","text":"<p>When you want to use Kafka with Application Aware testing it provides more assertion capabilities. It is recommended way of working. Stove-Kafka does that with intercepting the messages.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#how-to-get","title":"How to get?","text":"GradleMaven <pre><code>    dependencies {\n      testImplementation(\"com.trendyol:stove-spring-testing-e2e-kafka:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-spring-testing-e2e-kafka&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#configure","title":"Configure","text":""},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#configuration-values","title":"Configuration Values","text":"<p>Kafka works with some settings as default, your application might have these values as not configurable, to make the application testable we need to tweak a little bit.</p> <p>If you have the following configurations:</p> <ul> <li><code>AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" | should be \"earliest\"</code></li> <li><code>ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" | should be true</code></li> <li><code>HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" | should be 2 seconds</code></li> </ul> <p>You better make them configurable, so from the e2e testing context we can change them work with Stove-Kafka testing.</p> <p>As an example:</p> <pre><code>TestSystem()\n    .with{\n        httpClient()\n        kafka()\n        springBoot(\n            runner = { parameters -&gt;\n                com.trendyol.exampleapp.run(parameters)\n            },\n            withParameters = listOf(\n                \"logging.level.root=error\",\n                \"logging.level.org.springframework.web=error\",\n                \"spring.profiles.active=default\",\n                \"server.http2.enabled=false\",\n                \"kafka.heartbeatInSeconds=2\",\n                \"kafka.autoCreateTopics=true\",\n                \"kafka.offset=earliest\"\n            )\n        )\n    }.run()\n</code></pre> <p>As you can see, we pass these configuration values as parameters. Since they are configurable, the application considers these values instead of application-default values.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#consumer-settings","title":"Consumer Settings","text":"<p>Second thing we need to do is tweak your consumer configuration. For that we will provide Stove-Kafka interceptor to your Kafka configuration.</p> <p>Locate to the point where you define your <code>ConcurrentKafkaListenerContainerFactory</code> or where you can set the interceptor. Interceptor needs to implement <code>ConsumerAwareRecordInterceptor&lt;String, String&gt;</code> since Stove-Kafka relies on that.</p> <pre><code>@EnableKafka\n@Configuration\nclass KafkaConsumerConfiguration(\n    private val interceptor: ConsumerAwareRecordInterceptor&lt;String, String&gt;,\n) {\n\n    @Bean\n    fun kafkaListenerContainerFactory(): ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; {\n        val factory = ConcurrentKafkaListenerContainerFactory&lt;String, String&gt;()\n        // ...\n        factory.setRecordInterceptor(interceptor)\n        return factory\n    }\n}\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#producer-settings","title":"Producer Settings","text":"<p>Make sure that the aforementioned values are also configureable for producer settings, too. Stove will have access to <code>KafkaTemplate</code> and will use <code>setProducerListener</code> to arrange itself to listen produced messages.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#plugging-in","title":"Plugging in","text":"<p>When all the configuration is done, it is time to tell to application to use our <code>TestSystemInterceptor</code> and configuration values.</p>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#testsysteminterceptor-and-testinitializer","title":"TestSystemInterceptor and TestInitializer","text":"<pre><code>class TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;TestSystemInterceptor&gt;(isPrimary = true)\n})\n\nfun SpringApplication.addTestDependencies() {\n    this.addInitializers(TestInitializer())\n}\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/1.Spring-Boot/dependencies/kafka/#configuring-the-systemundertest-and-parameters","title":"Configuring the SystemUnderTest and Parameters","text":"<p><code>addTestDependencies</code> is an extension that helps us to register our dependencies in the application.</p> <pre><code>.springBoot(\n    runner = { parameters -&gt;\n        com.trendyol.exampleapp.run(parameters) {\n            addTestDependencies() // Enable TestInitializer with extensions call\n        }\n    },\n    withParameters = listOf(\n        \"logging.level.root=error\",\n        \"logging.level.org.springframework.web=error\",\n        \"spring.profiles.active=default\",\n        \"server.http2.enabled=false\",\n        \"kafka.heartbeatInSeconds=2\", // Added Parameter\n        \"kafka.autoCreateTopics=true\", // Added Parameter\n        \"kafka.offset=earliest\" // Added Parameter\n    )\n)\n</code></pre> <p>Now you're full set and have control over Kafka messages from the testing context.</p> <pre><code>TestSystem.validate {\n        kafka {\n            shouldBeConsumedOnCondition&lt;AnyEvent&gt; { actual-&gt;  }\n            shouldBePublishedOnCondition&lt;AnyEvent&gt; { actual-&gt;  }\n        }\n    }\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/2.Ktor/","title":"2. Ktor","text":"<p>Here you can jump immediately to the Ktor example application.</p>"},{"location":"how-to-write-tests/1.Application-Aware/2.Ktor/#deps","title":"Deps","text":"GradleMaven <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$version\")\n}\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-ktor-testing-e2e&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/1.Application-Aware/2.Ktor/#example-setup","title":"Example Setup","text":"<pre><code>TestSystem()\n    .with {\n        httpClient {\n          HttpClientSystemOptions {\n              baseUrl = \"http://localhost:8080\"\n          }\n        }\n        bridge()\n        postgresql {\n            PostgresqlOptions(configureExposedConfiguration = { cfg -&gt;\n                listOf(\n                    \"database.jdbcUrl=${cfg.jdbcUrl}\",\n                    \"database.host=${cfg.host}\",\n                    \"database.port=${cfg.port}\",\n                    \"database.name=${cfg.database}\",\n                    \"database.username=${cfg.username}\",\n                    \"database.password=${cfg.password}\"\n                )\n            })\n        }\n        kafka {\n            stoveKafkaObjectMapperRef = objectMapperRef\n            KafkaSystemOptions {\n                listOf(\n                    \"kafka.bootstrapServers=${it.bootstrapServers}\"\n                )\n            }\n        }\n        wiremock {\n            WireMockSystemOptions(\n                port = 9090,\n                removeStubAfterRequestMatched = true,\n                afterRequest = { e, _ -&gt;\n                    logger.info(e.request.toString())\n                }\n            )\n        }\n        ktor(\n            withParameters = listOf(\n                \"port=8080\"\n            ),\n            runner = { parameters -&gt;\n                stove.ktor.example.run(parameters) {\n                    addTestSystemDependencies()\n                }\n            }\n        )\n    }.run()\n</code></pre>"},{"location":"how-to-write-tests/2.Dockerized/","title":"2.Dockerized","text":"<p>In this approach, your application does not have any part that is exposed to Stove, and Stove will not attach to application. You could provide a docker image of your application, Stove will spin up the application and its dependencies.</p> <p>This is on the roadmap, and not implemented yet.</p>"},{"location":"how-to-write-tests/3.Components/","title":"Dependencies","text":"<p>All the dependencies are pluggable. Stove supports:</p> <ul> <li>Couchbase</li> <li>Kafka</li> <li>Elasticsearch</li> <li>Wiremock</li> <li>Http client</li> <li>Postgres Sql</li> </ul> <p>and more to come.</p> <p>There is a structure for a dependency to be pluggable in the Stove testing system. Every system connects or starts its  life with <code>with</code> notation. For example, <code>withCouchbase</code>, <code>withHttpClient</code>, <code>withKafka</code>... That means, if you want plug a physical dependency to your system look for a method that starts with <code>with</code> keyword. Having said that, when you write your own system that Stove does not have, you should use this structure, too.</p>"},{"location":"how-to-write-tests/3.Components/#every-system-has-the-systemoptions","title":"Every system has the SystemOptions","text":"<p>Every system accepts an options parameter that implements <code>SystemOptions</code>. For example;</p> <p><pre><code>fun TestSystem.withKafka(\n    options: KafkaSystemOptions = KafkaSystemOptions(),\n)\n</code></pre> Here <code>KafkaSystemOptions</code> implements <code>SystemOptions</code> interface. </p> <p>If a system exposes its <code>run-time</code> configurations then it implements <code>ConfiguresExposedConfiguration</code>. This is applicable for most of the cases. This mechanism allows you to configure your application (system under test) args before it starts.</p> <p><pre><code>TestSystem()\n    .withKafka(\n        KafkaSystemOptions(configureExposedConfiguration = { cfg -&gt;\n            listOf(\"kafka.bootstrapServers=${cfg.boostrapServers}\")\n        })\n    )\n</code></pre> Highlighted list of configurations are passed to the application's <code>main(args)</code> function.</p>"},{"location":"how-to-write-tests/3.Components/01-couchbase/","title":"Couchbase","text":""},{"location":"how-to-write-tests/3.Components/01-couchbase/#prerequisites","title":"Prerequisites","text":""},{"location":"how-to-write-tests/3.Components/01-couchbase/#1-docker-image","title":"1. Docker Image","text":"<pre><code> docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest\n</code></pre>"},{"location":"how-to-write-tests/3.Components/01-couchbase/#2-library","title":"2. Library","text":"GradleMaven <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-couchbase:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-couchbase&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/3.Components/01-couchbase/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>withCouchbase</code> function. This function configures the Couchbase Docker container that is going to be started.</p> <p>Here you can define a <code>defaultBucket</code> name. </p> <p>Warning</p> <p>Make sure that your application has the same bucket names.</p> <pre><code>TestSystem()\n    .withCouchbase(\n        CouchbaseSystemOptions(defaultBucket = \"test-bucket\", configureExposedConfiguration = { cfg -&gt;\n            listOf(\n                \"couchbase.hosts=${cfg.hostsWithPort}\",\n                \"couchbase.username=${cfg.username}\",\n                \"couchbase.password=${cfg.password}\"\n            )\n        })\n    )\n    .run()\n</code></pre> <p>Stove exposes configuration that is generated by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. Your application will start with the physical dependencies that are spun-up by the framework.</p>"},{"location":"how-to-write-tests/3.Components/01-couchbase/#migrations","title":"Migrations","text":"<p>Stove provides a way to run migrations before the test starts.</p>"},{"location":"how-to-write-tests/3.Components/02-kafka/","title":"Kafka","text":""},{"location":"how-to-write-tests/3.Components/02-kafka/#prerequisites","title":"Prerequisites","text":""},{"location":"how-to-write-tests/3.Components/02-kafka/#1-docker-image","title":"1. Docker Image","text":"<pre><code> docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest  \n</code></pre>"},{"location":"how-to-write-tests/3.Components/02-kafka/#2-library","title":"2. Library","text":"GradleMaven <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-kafka&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/3.Components/02-kafka/#configure","title":"Configure","text":"<pre><code>TestSystem(baseUrl = \"http://localhost:8080\")\n    .with {\n        // ... other deps ...  \n        bridge()\n        kafka {\n            stoveKafkaObjectMapperRef = objectMapperRef\n            KafkaSystemOptions {\n                listOf(\n                    \"kafka.bootstrapServers=${it.bootstrapServers}\",\n                    \"kafka.interceptorClasses=com.trendyol.stove.testing.e2e.standalone.kafka.intercepting.StoveKafkaBridge\"\n                )\n            }\n        }\n    }.run()\n</code></pre>"},{"location":"how-to-write-tests/3.Components/02-kafka/#configuring-object-mapper","title":"Configuring Object Mapper","text":"<p>Like every <code>SystemOptions</code> object, <code>KafkaSystemOptions</code> has a <code>stoveKafkaObjectMapperRef</code> field. You can set your own object mapper to this field. If you don't set it, Stove will use its default object mapper.</p> <pre><code>var stoveKafkaObjectMapperRef: ObjectMapper = StoveObjectMapper.Default\n</code></pre>"},{"location":"how-to-write-tests/3.Components/02-kafka/#kafka-bridge-with-your-application","title":"Kafka Bridge With Your Application","text":"<p>Stove Kafka bridge is a MUST to work with Kafka. Otherwise you can't assert any messages from your application.</p> <p>As you can see in the example above, you need to add a support to your application to work with interceptor that Stove provides.</p> <pre><code> \"kafka.interceptorClasses=com.trendyol.stove.testing.e2e.standalone.kafka.intercepting.StoveKafkaBridge\"\n</code></pre> <p>Important</p> <p><code>kafka.</code> prefix is an assumption that you can change it with your own prefix.</p> <p>Make sure that <code>StoveKafkaBridge</code> is in your classpath.</p>"},{"location":"how-to-write-tests/3.Components/03-elasticsearch/","title":"Elasticsearch","text":""},{"location":"how-to-write-tests/3.Components/03-elasticsearch/#prerequisites","title":"Prerequisites","text":""},{"location":"how-to-write-tests/3.Components/03-elasticsearch/#1-docker-image","title":"1. Docker Image","text":"<pre><code> docker buildx imagetools create docker.elastic.co/elasticsearch/elasticsearch:8.6.1 --tag YOUR_REGISTRY/elasticsearch/elasticsearch:8.6.1\n</code></pre>"},{"location":"how-to-write-tests/3.Components/03-elasticsearch/#2-library","title":"2. Library","text":"GradleMaven <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-elasticsearch:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-elasticsearch&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/3.Components/03-elasticsearch/#configure","title":"Configure","text":""},{"location":"how-to-write-tests/3.Components/04-wiremock/","title":"Wiremock","text":""},{"location":"how-to-write-tests/3.Components/04-wiremock/#how-to-get","title":"How to get?","text":"GradleMaven <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-wiremock:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-wiremock&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/3.Components/04-wiremock/#configure","title":"Configure","text":""},{"location":"how-to-write-tests/3.Components/05-http/","title":"HttpClient","text":""},{"location":"how-to-write-tests/3.Components/05-http/#how-to-get","title":"How to get?","text":"GradleMaven <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-http&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/3.Components/05-http/#configure","title":"Configure","text":""},{"location":"how-to-write-tests/3.Components/06-postgresql/","title":"Postgresql","text":""},{"location":"how-to-write-tests/3.Components/06-postgresql/#prerequisites","title":"Prerequisites","text":""},{"location":"how-to-write-tests/3.Components/06-postgresql/#1-docker-image","title":"1. Docker Image","text":"<pre><code> docker buildx imagetools create postgres:latest --tag YOUR_REGISTRY/postgres:latest  \n</code></pre>"},{"location":"how-to-write-tests/3.Components/06-postgresql/#2-library","title":"2. Library","text":"GradleMaven <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-rdbms-postgres:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-rdbms-postgres&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/3.Components/06-postgresql/#configure","title":"Configure","text":""},{"location":"how-to-write-tests/3.Components/07-mongodb/","title":"Mongodb","text":""},{"location":"how-to-write-tests/3.Components/07-mongodb/#prerequisites","title":"Prerequisites","text":""},{"location":"how-to-write-tests/3.Components/07-mongodb/#1-docker-image","title":"1. Docker Image","text":"<pre><code> docker buildx imagetools create mongo:latest --tag YOUR_REGISTRY/mongo:latest  \n</code></pre>"},{"location":"how-to-write-tests/3.Components/07-mongodb/#2-library","title":"2. Library","text":"GradleMaven <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-mongodb:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-testing-e2e-mongodb&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"how-to-write-tests/3.Components/07-mongodb/#configure","title":"Configure","text":""}]}