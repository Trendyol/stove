{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Stove","text":"<p>Stove is an end-to-end testing framework that spins up your application along with all its physical dependencies (databases, message queues, etc.) so you can test the real thing. Everything is controlled through Kotlin code, giving you full control over your test environment.</p> <p>Since JVM languages can interoperate, your application and tests don't need to use the same language. Write your app in Java and tests in Kotlin, or mix Scala and Kotlin\u2014whatever works for your team. Stove takes advantage of this and lets you write all your tests in Kotlin, regardless of what your application is written in.</p> <p>Your tests stay infrastructure-agnostic but component-aware. You can easily plug in whatever physical components you need using Stove's APIs. All the infrastructure is pluggable\u2014add what you need, skip what you don't. If Stove doesn't have a component you need, you can build your own using the abstractions it provides.</p> <p>The only hard requirement is Docker, since Stove uses testcontainers under the hood.</p> <p>You can run tests with either JUnit or Kotest. CI works too, though you'll need DinD (docker-in-docker) setup for that.</p> <p>Want to know more about why we built Stove? Check out the Medium article that explains the motivation behind the framework.</p> <p>Not a Replacement for Unit Tests</p> <p>Stove is for end-to-end and component tests, not unit tests. You'll still want unit tests for fast feedback on individual components.</p>"},{"location":"#why-stove","title":"Why Stove?","text":"<p>The JVM ecosystem has great frameworks for building applications, but when it comes to integration, component, or e2e testing, there's no single framework that works across all tech stacks. Testcontainers exists, but you still end up writing a lot of boilerplate to wire it up with your specific stack.</p> <p>We built Stove to solve this. We wanted to boost developer productivity while keeping code quality high, and we needed it to work across different tech stacks:</p> <ul> <li>Kotlin apps with Spring Boot</li> <li>Kotlin apps with Ktor</li> <li>Java apps with Spring Boot</li> <li>Java apps with Micronaut</li> <li>Java apps with Quarkus</li> <li>Scala apps with Spring Boot</li> <li>Java apps with Micronaut</li> <li>Java apps with Quarkus</li> <li>Scala apps with Spring Boot</li> </ul> <p>Every time someone wants to write e2e tests, they end up writing the same boilerplate: starting physical components, figuring out how to start the application from tests, accessing application beans, and so on. Stove eliminates all that by providing a single API that works across all these stacks.</p> <p>Stove unifies the testing experience, no matter what you're using.</p>"},{"location":"#high-level-architecture","title":"High Level Architecture","text":""},{"location":"#building-from-source","title":"Building from Source","text":"<p>To build Stove from source, you'll need:</p> <ul> <li>JDK 17+</li> <li>Docker (latest version recommended)</li> </ul> <p>Then just run:</p> <pre><code>./gradlew build  # This builds and runs all tests\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#pre-requisites","title":"Pre-requisites","text":"<ul> <li>JDK 17+</li> <li>Docker for running the tests (please use the latest version)</li> <li>Kotlin 1.8+</li> <li>Gradle or Maven for running the tests, but Gradle is recommended.<ul> <li>Gradle is the default build tool for Stove, and it is used in the examples.</li> <li>If you are using Intellij IDEA, Kotest plugin is recommended.</li> </ul> </li> </ul> <p>The framework is still evolving, but it's working well and is actively used at Trendyol. Since Stove tests live in your test source set (separate from your application code), trying it out is completely risk-free\u2014give it a shot!</p> <p><code>$version = please check the current version</code></p> <p>Versions are available at Releases</p> <p>Tip</p> <p>You can use SNAPSHOT versions for the latest features. As of 5th June 2025, Stove's snapshot packages are hosted on  Central Sonatype. SNAPSHOT versions are released with the <code>1.0.0.{buildNumber}-SNAPSHOT</code> strategy.</p> <pre><code>repositories {\n    maven(\"https://central.sonatype.com/repository/maven-snapshots\")\n}\n</code></pre> <p>Every physical component you might need for testing is a separate module in Stove. Add only what you need.</p> <p>Stove supports these components:</p> <ul> <li>Kafka</li> <li>MongoDB</li> <li>MSSQL</li> <li>PostgreSQL</li> <li>MySQL</li> <li>Redis</li> <li>Elasticsearch</li> <li>Couchbase</li> <li>WireMock</li> <li>HTTP</li> <li>gRPC</li> <li>gRPC Mocking</li> <li>Bridge</li> <li>Reporting</li> <li>Tracing</li> </ul> Gradle <pre><code>repositories {\n  mavenCentral()\n}\n\ndependencies {\n  // Import BOM for version management\n  testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n\n  // Application Under Test\n\n  // Spring Boot\n  testImplementation(\"com.trendyol:stove-spring\")\n\n  // or\n\n  // Ktor\n  testImplementation(\"com.trendyol:stove-ktor\")\n\n  // Components\n  testImplementation(\"com.trendyol:stove\")\n  testImplementation(\"com.trendyol:stove-kafka\")\n  testImplementation(\"com.trendyol:stove-mongodb\")\n  testImplementation(\"com.trendyol:stove-mssql\")\n  testImplementation(\"com.trendyol:stove-postgres\")\n  testImplementation(\"com.trendyol:stove-redis\")\n  testImplementation(\"com.trendyol:stove-elasticsearch\")\n  testImplementation(\"com.trendyol:stove-couchbase\")\n  testImplementation(\"com.trendyol:stove-wiremock\")\n  testImplementation(\"com.trendyol:stove-http\")\n}\n</code></pre>"},{"location":"#how-to-write-tests","title":"How To Write Tests?","text":"<p>Stove uses your application entrance point to start your application alongside the physical components. The application's <code>main</code> is the entrance point for the applications in general.</p> <p>Everything starts with the <code>Stove</code> class. You configure your system using the <code>with</code> function.</p> <pre><code>Stove()\n  .with {\n    // your configurations depending on the dependencies you need\n  }.run()\n</code></pre> <p>The <code>with</code> function is a lambda where you configure your system. You can add physical components here, and it's also where you plug in any custom systems you might want to create.</p> <p>If you've added the <code>com.trendyol:stove-kafka</code> package, you can use the <code>kafka</code> function in the <code>with</code> block:</p> <pre><code>Stove()\n  .with {\n    kafka {\n      // your kafka configurations\n    }\n  }.run()\n</code></pre> <p>Note</p> <p>You can add multiple physical components in the <code>with</code> block. Think of it as a DSL for your test system and a <code>docker-compose</code> in Kotlin.</p> <p>Tip</p> <p>If you want to jump directly to the examples, you can check the examples in the repository.</p> <ul> <li> <p>Examples</p> <ul> <li>Ktor Example</li> <li>Spring Boot Example</li> <li>Spring Boot with Standalone Kafka</li> </ul> </li> <li> <p>Recipes</p> <ul> <li>Java Recipes</li> <li>Kotlin Recipes</li> <li>Scala Recipes</li> </ul> </li> </ul> <p>Stove has the concept of \"Application Aware Testing\". It means that Stove is aware of the application's entrance point and that is the only information it needs to start the application.</p> <p>Application that is being tested is a Spring Boot, Ktor, Micronaut, Quarkus, etc. and is called \"Application Under Test (AUT)\".</p> <p>The tests are agnostic to the application's framework. Right now Stove supports Spring Boot, Ktor. But it is easy to add new frameworks.</p> <p>Note</p> <p>If you want to add a new framework, you can check the <code>com.trendyol.stove.system.abstractions.ApplicationUnderTest</code> interface. You can implement this interface for your framework.</p> <p>Let's create an example for a Spring-Boot application with Kafka and explain the setup flow.</p> <p>The dependencies we will need in the <code>build.gradle.kts</code> file are:</p> <pre><code> dependencies {\n  // Import BOM for version management\n  testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n\n  testImplementation(\"com.trendyol:stove\")\n  testImplementation(\"com.trendyol:stove-kafka\")\n  testImplementation(\"com.trendyol:stove-http\")\n  testImplementation(\"com.trendyol:stove-spring\")\n}\n</code></pre> <pre><code>Stove()\n  .with {\n    httpClient {\n      HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8001\"\n      )\n    }\n\n    kafka {\n      KafkaSystemOptions(\n        containerOptions = KafkaContainerOptions(tag = \"latest\"),\n      ) {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\",\n          \"kafka.heartbeatInSeconds=2\",\n          \"kafka.autoCreateTopics=true\",\n          \"kafka.offset=earliest\",\n          \"kafka.secureKafka=false\"\n        )\n      }\n    }\n\n    bridge()\n\n    springBoot( // Application Under Test\n      runner = { parameters -&gt;\n        stove.spring.standalone.example.run(parameters)\n      },\n      withParameters = listOf(\n        \"server.port=8001\",\n        \"logging.level.root=info\",\n        \"logging.level.org.springframework.web=info\",\n        \"spring.profiles.active=default\",\n      )\n    )\n  }\n  .run()\n</code></pre> <p>The typical setup for a Spring Boot application with Kafka is like this. You can see that we have a <code>httpClient</code>function that is used for the HTTP client against the application's endpoints. Then we have a <code>kafka</code> function that is used for the Kafka setup. Then we have a <code>bridge</code> function that is used for accessing the DI container of the application. Then we have a <code>springBoot</code> function that is used for the Spring Boot application setup.</p>"},{"location":"#httpclient-function","title":"<code>httpClient</code> function","text":"<p>It is used for the HTTP client against the application's endpoints. You can configure the base URL of the application. When the application is started, the base URL is used for the HTTP client.</p>"},{"location":"#kafka-function","title":"<code>kafka</code> function","text":"<p>It is used for the Kafka setup. You can configure the Kafka container options and the Kafka properties. When the application is started, the Kafka container is started and the Kafka properties are used for the application. We will investigate the Kafka setup in detail in the Kafka section. Your application code should be able to read these properties, and event app code needs to be arranged for this.</p> <p>Is my application code e2e testing friendly?</p> <p>In general, to write proper unit tests your code should be testable.  This means extracting dependencies to interfaces and using dependency injection. </p> <p>Injecting time, configuration, and other dependencies is a good practice.  This makes your classes testable and you can easily replace the implementations of the interfaces in the tests.</p> <p>Changing your configuration to be able to read from the environment variables or CLI arguments is also a good practice. Since Stove is also passing down the test configurations and the optimum setup for the tests, your application should be able to read these configurations.</p> <p>So, don't think that you're changing too much application code just for sake of the Stove tests, you're making your application code e2e test friendly.</p>"},{"location":"#bridge-function","title":"<code>bridge</code> function","text":"<p>This function is used for accessing the DI container of the application. When the application is started, the bridge is created and the DI container is accessed in the tests.</p> <p>If you want to access to the beans of the application, you can simply do:</p> <pre><code>stove {\n  using&lt;UserApplicationService&gt; {\n    this.getUserById(1) shouldBe User(1, \"John\", \"Doe\")\n  }\n\n  using&lt;ProductDomainService, ProductRepository&gt; { productDomainService, productRepository -&gt;\n    productDomainService.getProductById(1) shouldBe Product(1, \"Product 1\")\n    productRepository.findById(1) shouldBe Product(1, \"Product 1\")\n  }\n}\n</code></pre>"},{"location":"#springboot-function","title":"<code>springBoot</code> function","text":"<p>This function is used for the Spring Boot application setup. You can configure the runner function and the parameters of the application. When the application is started, the runner function is called with the parameters. The parameters you see in <code>runner</code> function are the parameters that are passed to the Spring Boot application when it is started. Each physical component exposes its own properties and you can use them in the application. Here:</p> <pre><code>kafka {\n  KafkaSystemOptions(\n    containerOptions = KafkaContainerOptions(tag = \"latest\"),\n  ) {\n    listOf(\n      \"kafka.bootstrapServers=${it.bootstrapServers}\",\n      \"kafka.isSecure=false\",\n      \"kafka.interceptorClasses=${it.interceptorClass}\",\n      \"kafka.heartbeatInSeconds=2\",\n      \"kafka.autoCreateTopics=true\",\n      \"kafka.offset=earliest\",\n      \"kafka.secureKafka=false\"\n    )\n  }\n}\n</code></pre> <p>The list of properties are exposed by the Kafka component and you can use them in the application. The <code>it</code> reference in this block is the physical component itself with all its exposed properties. When Kafka and the testing suite start, these properties are automatically passed down to your application.</p>"},{"location":"#run-function","title":"<code>run</code> function","text":"<p>Runs the entire setup. It starts the physical components and the application.</p> <p>Run the Setup Once</p> <p>You should run the setup once in your test suite. You can run it in the <code>@BeforeAll</code> function of JUnit or implement <code>AbstractProjectConfig#beforeProject</code> in Kotest. Teardown is also important to call. You can run it in the <code>@AfterAll</code> function of JUnit or implement <code>AbstractProjectConfig#afterProject</code> in Kotest. Simply calling <code>Stove.stop()</code> is enough to stop everything.</p>"},{"location":"#writing-tests","title":"Writing Tests","text":"<p>After the setup is done, you can write your tests. Use the <code>stove</code> function to write your test assertions:</p> <pre><code>stove {\n  http {\n    get&lt;String&gt;(\"/hello/index\") { actual -&gt;\n      actual shouldContain \"Hi from Stove framework\"\n    }\n  }\n\n  kafka {\n    shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt;\n      actual.productId == 1\n    }\n  }\n\n  using&lt;UserApplicationService&gt; {\n    this.getUserById(1) shouldBe User(1, \"John\", \"Doe\")\n  }\n\n  using&lt;ProductDomainService, ProductRepository&gt; { productDomainService, productRepository -&gt;\n    productDomainService.getProductById(1) shouldBe Product(1, \"Product 1\")\n    productRepository.findById(1) shouldBe Product(1, \"Product 1\")\n  }\n\n  kafka {\n    shouldBePublished&lt;ProductCreatedEvent&gt; { actual -&gt;\n      actual.productId == 1\n    }\n  }\n}\n</code></pre> <p>That's it! You have up-and-running API, can be tested with Stove. And each test is independent of each other. But they share the same instance of physical component of course, so you need to provide random data for each test. This is a good practice for the tests to be independent of each other.</p>"},{"location":"#application-aware-testing","title":"Application Aware Testing","text":"<p>Stove is aware of your application either it is SpringBoot or Ktor, and it is aware of the entrance point of your application.</p> <p>There are entry point for every application, usually a <code>main</code> method that is invoked, and starts the application lifecycle.</p> <p>If you are publishing your <code>application</code> as a docker image, <code>docker run ...</code> basically runs your application highly likely with a <code>jvm/java</code> command.</p> <p>In this approach, we're using the same <code>main</code> function of your application in the test context to run the application as full-blown as if it is invoked from outside.</p> <p>Stove calls your application's <code>main</code> function like you would call <code>java yourApplicationName.jar --param1 --param2</code> to run the application from the test context. So the runner is JUnit or Kotest.</p> <p>For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter.</p> <p>This approach has lots of benefits besides of providing a debug ability while e2e testing. You can:</p> <ul> <li>Debug the application code</li> <li>Replace the implementations of the interfaces. Useful for time-bounded implementations such as schedulers, background   workers, and time itself.   you would only have consuming.</li> <li>Use and expose application's dependency container to the test context. You can access the beans of the application   easily. Using <code>bridge</code> functionality.</li> </ul>"},{"location":"#spring-boot","title":"Spring Boot","text":"<p>You need to add the Stove-Spring dependency to be able to write e2e tests for the Spring application.</p> Gradle <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-spring:$version\")\n\n    // You can add other components if you need\n}\n</code></pre>"},{"location":"#tuning-the-applications-entry-point","title":"Tuning the application's entry point","text":"<p>Let's say the application has a standard <code>main</code> function, here how we will change it:</p> BeforeAfter <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { runApplication&lt;ExampleApplication&gt;(*args) }\n</code></pre> <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { run(args) }\n\nfun run(\n     args: Array&lt;String&gt;,\n     init: SpringApplication.() -&gt; Unit = {},\n  ): ConfigurableApplicationContext {\n        return runApplication&lt;ExampleApplication&gt;(*args, init = init)\n    }\n</code></pre> <p>As you can see from <code>before-after</code> sections, we have divided the application main function into two parts.</p> <p><code>run(args, init)</code> method is the important point for the testing configuration. <code>init</code> allows us to override any dependency from the testing side that is being <code>time</code> related or <code>configuration</code> related. Spring itself opens this configuration higher order function to the outside.</p> <p>Also returning <code>ConfigurableApplicationContext</code> is important for the <code>bridge</code> functionality that we will use in the tests.</p> <p>Tip</p> <p>Here you can jump immediately to the Spring example application.</p>"},{"location":"#initial-configuration","title":"Initial Configuration","text":"<p>After you've added the dependencies, and configured the application's <code>main</code> function, it is time to run your application for the first time from the test-context with Stove.</p>"},{"location":"#setting-up-stove-for-the-runner","title":"Setting up Stove for the Runner","text":"KotestJUnit <p>It implements <code>AbstractProjectConfig</code> from Kotest framework that allows us to spin up Stove per run. This is project wide operation and executes only one time, as the name implies <code>beforeProject</code>.</p> <p>Test Framework Extensions</p> <p><code>StoveKotestExtension</code> (<code>stove-extensions-kotest</code>) and <code>StoveJUnitExtension</code> (<code>stove-extensions-junit</code>) are separate packages. Kotest requires 6.1.3+; JUnit requires Jupiter 6.x if possible. For Kotest, add a <code>kotest.properties</code> file with <code>kotest.framework.config.fqn=&lt;your config class FQN&gt;</code>. See Step 3: Create Test Configuration for details.</p> <pre><code>import com.trendyol.stove.extensions.kotest.StoveKotestExtension\nimport com.trendyol.stove.system.Stove\nimport com.trendyol.stove.http.*\nimport com.trendyol.stove.spring.springBoot\n\nclass Stove : AbstractProjectConfig() {\n    // Register StoveKotestExtension for detailed failure reports\n    override val extensions: List&lt;Extension&gt; = listOf(StoveKotestExtension())\n\n    override suspend fun beforeProject(): Unit = \n        Stove()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions (\n                        baseUrl = \"http://localhost:8001\"\n                    )\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n\n    override suspend fun afterProject(): Unit = Stove.stop()\n}\n</code></pre> <pre><code>import com.trendyol.stove.extensions.junit.StoveJUnitExtension\nimport com.trendyol.stove.system.Stove\nimport com.trendyol.stove.http.*\nimport com.trendyol.stove.spring.springBoot\nimport org.junit.jupiter.api.extension.ExtendWith\n\n@ExtendWith(StoveJUnitExtension::class)\nclass StoveConfig {\n\n    @BeforeAll\n    fun beforeProject() = runBlocking {\n         Stove()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions (\n                        baseUrl = \"http://localhost:8001\"\n                    )\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n    }\n\n    @AfterAll\n    fun afterProject() = runBlocking {\n        Stove.stop()\n    }\n}\n</code></pre> <p>In the <code>springBoot</code> function, we configure the application's entry point and the parameters passed to it. <code>stove.spring.example.run(parameters)</code> is where your application starts.</p> <p>This is similar to the \"service under test\" concept from TDD, but since we're testing the entire system, we call it the \"Application Under Test\". Here we're configuring the Spring Boot application as the application under test.</p> <p>Note</p> <p><code>server.port=8001</code> is a Spring config, and Stove's <code>baseUrl</code> needs to match it, since HTTP requests are made  against the <code>baseUrl</code> you define. <code>httpClient</code> creates a WebClient and uses the <code>baseUrl</code> you pass.</p>"},{"location":"#writing-tests_1","title":"Writing Tests","text":"<p>Here is an example test that validates <code>http://localhost:$port/hello/index</code> returns the expected text</p> KotestJUnit <pre><code>class ExampleTest: FunSpec({\n\n    test(\"should return hi\"){\n        stove {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n})\n</code></pre> <pre><code>class ExampleTest {\n\n    @Test\n    fun `should return hi`() {\n        stove {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n    }\n})\n</code></pre> <p>That's it! You have up-and-running API, can be tested with Stove.</p> <p>Tip</p> <p>DSL scopes can appear more than once while writing the tests.  You can access to any DSL assertion scope such as http, kafka, using, etc. as many times as you need.</p> <p>Example:</p> <pre><code>stove {\n    http {\n        get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n            actual shouldContain \"Hi from Stove framework\" \n        }\n    }\n\n    kafka {\n        shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt; \n            actual.productId == 1\n        }\n    }\n\n    kafka {\n        shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt; \n            actual.productId == 1\n        }\n    }\n\n    http {\n        get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n            actual shouldContain \"Hi from Stove framework\" \n        }\n    }\n\n    using&lt;UserApplicationService&gt; {\n        this.getUserById(1) shouldBe\n    }\n</code></pre>"},{"location":"#ktor","title":"Ktor","text":"Gradle <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-ktor:$version\")\n\n    // Add your preferred DI framework (one of):\n    testImplementation(\"io.insert-koin:koin-ktor:$koinVersion\")  // Koin\n    // OR\n    testImplementation(\"io.ktor:ktor-server-di:$ktorVersion\")    // Ktor-DI\n\n    // You can add other components if you need\n}\n</code></pre> <p>DI Framework Required</p> <p>Ktor Bridge requires either Koin or Ktor-DI to be on the classpath. The <code>bridge()</code> function auto-detects which one is available.</p>"},{"location":"#example-setup","title":"Example Setup","text":"KoinKtor-DI <pre><code>Stove()\n  .with {\n    bridge()  // Auto-detects Koin\n    ktor(\n      withParameters = listOf(\"port=8080\"),\n      runner = { parameters -&gt;\n        stove.ktor.example.run(\n          parameters,\n          testModules = listOf(\n            module {\n              single&lt;TimeProvider&gt;(override = true) { FixedTimeProvider() }\n            }\n          )\n        )\n      }\n    )\n  }.run()\n</code></pre> <pre><code>Stove()\n  .with {\n    bridge()  // Auto-detects Ktor-DI\n    ktor(\n      withParameters = listOf(\"port=8080\"),\n      runner = { parameters -&gt;\n        stove.ktor.example.run(parameters) {\n          provide&lt;TimeProvider&gt; { FixedTimeProvider() }\n        }\n      }\n    )\n  }.run()\n</code></pre> <p>After you've added <code>stove-ktor</code> dependency and your preferred DI framework, and configured the application's <code>main</code> function for Stove to enter, it is time to run your application for the first time from the test-context with Stove.</p>"},{"location":"#tuning-the-applications-entry-point_1","title":"Tuning the application's entry point","text":"<p>Let's say the application has a standard <code>main</code> function, here how we will change it:</p> BeforeAfter (Koin)After (Ktor-DI) <pre><code>fun main() {\n  embeddedServer(Netty, port = 8080) {\n      routing {\n          get(\"/\") {\n              call.respondText(\"Hello, world!\")\n          }\n      }\n   }.start(wait = true)\n}\n</code></pre> <pre><code>object ExampleApp {\n  @JvmStatic\n  fun main(args: Array&lt;String&gt;) = run(args)\n\n  fun run(\n    args: Array&lt;String&gt;, \n    wait: Boolean = true, \n    testModules: List&lt;Module&gt; = emptyList()  // Accept test modules\n  ): Application {\n    val config = loadConfiguration&lt;Env&gt;(args)\n    return embeddedServer(Netty, port = config.port) {\n      install(Koin) {\n        modules(appModule, *testModules.toTypedArray())\n      }\n      configureRouting()\n    }.start(wait = wait).application\n  }\n}\n</code></pre> <pre><code>object ExampleApp {\n  @JvmStatic\n  fun main(args: Array&lt;String&gt;) = run(args)\n\n  fun run(\n    args: Array&lt;String&gt;, \n    wait: Boolean = true, \n    testDependencies: (DependencyRegistrar.() -&gt; Unit)? = null  // Accept test overrides\n  ): Application {\n    val config = loadConfiguration&lt;Env&gt;(args)\n    return embeddedServer(Netty, port = config.port) {\n      install(DI) {\n        dependencies {\n          provide&lt;MyService&gt; { MyServiceImpl() }\n          testDependencies?.invoke(this)  // Apply test overrides\n        }\n      }\n      configureRouting()\n    }.start(wait = wait).application\n  }\n}\n</code></pre> <p>As you can see from <code>before-after</code> sections, we have divided the application main function into two parts. The <code>run</code> method accepts parameters for test configuration, allowing you to override dependencies from the testing side (e.g., time-related or configuration-related beans).</p> <p>Note</p> <p>There are helper methods here for example loadConfiguration  that is used to load the configuration from the environment variables or CLI arguments. And as you can see there is an <code>Env</code> data class to cast the configuration.  Stove itself does not provide them, but of course we have already used them in our examples, you can find them in the examples.</p> <p>Tip</p> <p>Here you can jump immediately to the Ktor example application.</p>"},{"location":"#advanced","title":"Advanced","text":""},{"location":"#global-variables","title":"Global Variables","text":""},{"location":"#default_registry","title":"DEFAULT_REGISTRY","text":"<p>The default container registry is <code>docker.io</code>. You can change it by setting the <code>DEFAULT_REGISTRY</code> variable.</p> <pre><code>DEFAULT_REGISTRY = \"your.registry.com\"\n</code></pre> <p>This will effect all the components Stove wide. Or you can set it for each individual component by setting the<code>registry</code> property, example for Kafka:</p> <pre><code>KafkaSystemOptions(\n  containerOptions = KafkaContainerOptions(\n    registry = \"your.registry.com\",\n    tag = \"latest\"\n  ),\n)\n</code></pre>"},{"location":"#serializing-and-deserializing","title":"Serializing and Deserializing","text":"<p>Each component has its own serialization and deserialization mechanism. You can align Stove's serialization and deserialization mechanism with your application's serialization and deserialization mechanism.</p> <p>Stove works with multiple serializers and deserializers. The package <code>stove</code> provides the following serializers and deserializers:</p> <ul> <li>Jackson</li> <li>Gson</li> <li>Kotlinx</li> </ul> <p>Stove also provides a way to add your own serializer and deserializer. You can implement the <code>StoveSerde&lt;TIn, TOut&gt;</code> interface and add your own serializer and deserializer.</p> <p><code>StoveSerde</code> also keeps the reference to the aforementioned libraries:</p> <pre><code>StoveSerde.jackson\nStoveSerde.gson\nStoveSerde.kotlinx\n</code></pre> <p>And also provides default implementations for them:</p> <pre><code>StoveSerde.jackson.anyByteArraySerde(yourObjectMapper())\nStoveSerde.gson.anyByteArraySerde(yourGson())\nStoveSerde.kotlinx.anyByteArraySerde(yourJson())\n\n// there is also string serde\nStoveSerde.jackson.anyStringSerde(yourObjectMapper())\nStoveSerde.gson.anyStringSerde(yourGson())\nStoveSerde.kotlinx.anyStringSerde(yourJson())\n</code></pre>"},{"location":"#replacing-dependencies-for-better-testability","title":"Replacing Dependencies For Better Testability","text":"<p>When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is <code>advancing</code> the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented.</p> <p>For example, imagine we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation.</p> <pre><code>class BackgroundCommandBusImpl // is the class for delayed operations\n</code></pre> <p>We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write:</p> <pre><code>class NoDelayBackgroundCommandBusImpl(\n  backgroundMessageEnvelopeDispatcher: BackgroundMessageEnvelopeDispatcher,\n  backgroundMessageEnvelopeStorage: BackgroundMessageEnvelopeStorage,\n  lockProvider: CouchbaseLockProvider,\n) : BackgroundCommandBusImpl(\n  backgroundMessageEnvelopeDispatcher,\n  backgroundMessageEnvelopeStorage,\n  lockProvider\n) {\n\n  override suspend fun &lt;TNotification : BackgroundNotification&gt; publish(\n    notification: TNotification,\n    options: BackgroundOptions,\n  ) {\n    super.publish(notification, options.withDelay(0))\n  }\n\n  override suspend fun &lt;TCommand : BackgroundCommand&gt; send(\n    command: TCommand,\n    options: BackgroundOptions,\n  ) {\n    super.send(command, options.withDelay(0))\n  }\n}\n</code></pre> <p>Now, it is time to tell the e2e test system to use the NoDelay implementation.</p> <p>This is done by registering test dependencies (see \"Registering Test Dependencies\" section below).</p>"},{"location":"#writing-your-own-custom-system","title":"Writing Your Own Custom System","text":"<p>Stove's pluggable architecture lets you create custom systems for any component or behavior specific to your application. This is useful for:</p> <ul> <li>Capturing domain events in memory</li> <li>Integrating with schedulers (db-scheduler, Quartz, etc.)</li> <li>Controlling time in tests</li> <li>Testing domain-specific behavior</li> </ul> <p>Here's a simple example of a custom scheduler system:</p> <pre><code>fun Stove.withSchedulerSystem(): Stove {\n  getOrRegister(SchedulerSystem(this))\n  return this\n}\n\nfun Stove.scheduler(): SchedulerSystem = getOrNone&lt;SchedulerSystem&gt;().getOrElse {\n  throw SystemNotRegisteredException(SchedulerSystem::class)\n}\n\nclass SchedulerSystem(override val stove: Stove) : AfterRunAware&lt;ApplicationContext&gt;, PluggedSystem {\n\n  private lateinit var scheduler: WaitingRoomScheduler\n  private lateinit var backgroundCommandBus: BackgroundCommandBusImpl\n\n  fun advance(): SchedulerSystem {\n    scheduler.publishValidProducts()\n    return this\n  }\n\n  fun advanceBackgroundCommandBus(): SchedulerSystem {\n    backgroundCommandBus.dispatchTimeoutNotifications()\n    return this\n  }\n\n  override suspend fun afterRun(context: ApplicationContext) {\n    scheduler = context.getBean()\n    backgroundCommandBus = context.getBean()\n  }\n\n  override fun close() {}\n}\n</code></pre> <p>Later you can use it in testing:</p> <pre><code>stove {\n  scheduler {\n    advance()\n  }\n}\n</code></pre> <p>Comprehensive Guide</p> <p>For a complete guide on writing custom systems including examples for db-scheduler integration,  in-memory event capture, and time control systems, see Writing Custom Systems.</p>"},{"location":"#accessing-an-application-dependency-with-a-system","title":"Accessing an application dependency with a system","text":"<p>As you can see, in the example above, if a system implements <code>AfterRunAware&lt;ApplicationContext&gt;</code> then, <code>afterRun</code> method becomes available, in here we have access to applications dependency container to resolve any bean we need to use.</p> <pre><code>override suspend fun afterRun(context: ApplicationContext) {\n  scheduler = context.getBean()\n  backgroundCommandBus = context.getBean()\n}\n</code></pre>"},{"location":"#registering-test-dependencies","title":"Registering Test Dependencies","text":"<p>You can add test-scoped beans to configure the Spring application from the test perspective using <code>addTestDependencies</code>:</p> <p>Spring Boot 2.x / 3.x:</p> <pre><code>import com.trendyol.stove.addTestDependencies\n\nrunApplication&lt;MyApp&gt;(*params) {\n    addTestDependencies {\n        bean&lt;YourInstanceToReplace&gt;(isPrimary = true)\n        bean&lt;NoDelayBackgroundCommandBusImpl&gt;(isPrimary = true)\n    }\n}\n</code></pre> <p>Spring Boot 4.x:</p> <pre><code>import com.trendyol.stove.addTestDependencies4x\n\nrunApplication&lt;MyApp&gt;(*params) {\n    addTestDependencies4x {\n        registerBean&lt;YourInstanceToReplace&gt;(primary = true)\n        registerBean&lt;NoDelayBackgroundCommandBusImpl&gt;(primary = true)\n    }\n}\n</code></pre> <p><code>addTestDependencies</code> / <code>addTestDependencies4x</code> are extensions that help us register our dependencies in the application.</p> <pre><code>springBoot(\n  runner = { parameters -&gt;\n    runApplication&lt;MyApp&gt;(*parameters) {\n      addTestDependencies {\n        bean&lt;YourInstanceToReplace&gt;(isPrimary = true)\n        bean&lt;NoDelayBackgroundCommandBusImpl&gt;(isPrimary = true)\n      }\n    }\n  },\n  withParameters = listOf(\n    \"logging.level.root=error\",\n    \"logging.level.org.springframework.web=error\",\n    \"spring.profiles.active=default\",\n    \"server.http2.enabled=false\",\n    \"kafka.heartbeatInSeconds=2\",\n    \"kafka.autoCreateTopics=true\",\n    \"kafka.offset=earliest\"\n  )\n)\n</code></pre>"},{"location":"best-practices/","title":"Best Practices","text":"<p>Here are some practices we've found helpful when writing end-to-end tests with Stove. These aren't hard rules, but they'll make your tests more maintainable and easier to work with.</p>"},{"location":"best-practices/#test-organization","title":"Test Organization","text":""},{"location":"best-practices/#use-dedicated-source-set-for-e2e-tests","title":"Use Dedicated Source Set for E2E Tests","text":"<p>Instead of placing e2e tests in the regular <code>src/test</code> folder, create a dedicated <code>src/test-e2e</code> source set. This provides better separation between unit/integration tests and e2e tests:</p> <pre><code>src/\n\u251c\u2500\u2500 main/kotlin/           # Application code\n\u251c\u2500\u2500 test/kotlin/           # Unit tests\n\u2514\u2500\u2500 test-e2e/kotlin/       # E2E tests with Stove\n    \u251c\u2500\u2500 config/\n    \u2502   \u2514\u2500\u2500 TestConfig.kt  # Contains Stove setup\n    \u251c\u2500\u2500 features/\n    \u2502   \u251c\u2500\u2500 OrderE2ETest.kt\n    \u2502   \u251c\u2500\u2500 UserE2ETest.kt\n    \u2502   \u2514\u2500\u2500 ProductE2ETest.kt\n    \u2514\u2500\u2500 shared/\n        \u251c\u2500\u2500 TestData.kt\n        \u2514\u2500\u2500 Assertions.kt\n</code></pre>"},{"location":"best-practices/#gradle-configuration","title":"Gradle Configuration","text":"<p>Here's how to set up the <code>test-e2e</code> source set in your <code>build.gradle.kts</code>:</p> <pre><code>sourceSets {\n    @Suppress(\"LocalVariableName\")\n    val `test-e2e` by creating {\n        compileClasspath += sourceSets.main.get().output\n        runtimeClasspath += sourceSets.main.get().output\n    }\n\n    val testE2eImplementation by configurations.getting {\n        extendsFrom(configurations.testImplementation.get())\n    }\n    configurations[\"testE2eRuntimeOnly\"].extendsFrom(configurations.runtimeOnly.get())\n}\n\n// Register e2e test task\ntasks.register&lt;Test&gt;(\"e2eTest\") {\n    description = \"Runs e2e tests.\"\n    group = \"verification\"\n    testClassesDirs = sourceSets[\"test-e2e\"].output.classesDirs\n    classpath = sourceSets[\"test-e2e\"].runtimeClasspath\n\n    useJUnitPlatform()\n    reports {\n        junitXml.required.set(true)\n        html.required.set(true)\n    }\n}\n\n// Configure IDEA to recognize test-e2e as test sources\nidea {\n    module {\n        testSources.from(sourceSets[\"test-e2e\"].allSource.sourceDirectories)\n        testResources.from(sourceSets[\"test-e2e\"].resources.sourceDirectories)\n    }\n}\n</code></pre>"},{"location":"best-practices/#running-e2e-tests","title":"Running E2E Tests","text":"<pre><code># Run only e2e tests\n./gradlew e2eTest\n\n# Run unit tests (doesn't include e2e)\n./gradlew test\n\n# Run all tests\n./gradlew test e2eTest\n</code></pre>"},{"location":"best-practices/#benefits-of-separate-source-set","title":"Benefits of Separate Source Set","text":"Benefit Description Isolation E2E tests run independently from unit tests CI Flexibility Run unit tests quickly, e2e tests separately or in parallel Resource Management Different JVM settings for e2e tests (more memory, longer timeouts) Clear Boundaries Developers know exactly where e2e tests live <p>See Examples</p> <p>Check the recipes folder for complete working examples with this structure.</p>"},{"location":"best-practices/#single-setup-multiple-tests","title":"Single Setup, Multiple Tests","text":"<p>Configure Stove once for all tests:</p> <pre><code>// \u2705 Good: Single configuration for all tests\nclass TestConfig : AbstractProjectConfig() {\n    override suspend fun beforeProject() {\n        Stove()\n            .with { /* configuration */ }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        Stove.stop()\n    }\n}\n\n// \u274c Bad: Configuration per test class\nclass MyTest : FunSpec({\n    beforeSpec {\n        Stove().with { /* */ }.run()  // Don't do this!\n    }\n})\n</code></pre>"},{"location":"best-practices/#test-data-management","title":"Test Data Management","text":""},{"location":"best-practices/#use-unique-test-data","title":"Use Unique Test Data","text":"<p>Generate unique identifiers to prevent test interference:</p> <pre><code>// \u2705 Good: Unique data per test\ntest(\"should create order\") {\n    val orderId = UUID.randomUUID().toString()\n    val userId = \"user-${UUID.randomUUID()}\"\n\n    stove {\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(id = orderId, userId = userId).some()\n            ) { /* assertions */ }\n        }\n    }\n}\n\n// \u274c Bad: Hardcoded IDs that may conflict\ntest(\"should create order\") {\n    val orderId = \"order-123\"  // May conflict with other tests\n    // ...\n}\n</code></pre>"},{"location":"best-practices/#isolate-shared-infrastructure-resources","title":"Isolate Shared Infrastructure Resources","text":"<p>When using provided instances (shared infrastructure in CI/CD), use unique prefixes for all resources to prevent parallel test runs from interfering with each other:</p> <pre><code>object TestRunContext {\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: UUID.randomUUID().toString().take(8)\n\n    val databaseName = \"testdb_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n}\n\n// Use unique names in configuration\nStove()\n    .with {\n        postgresql {\n            PostgresqlOptions.provided(\n                databaseName = TestRunContext.databaseName,\n                // ...\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n                \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\"\n            )\n        )\n    }\n</code></pre> <p>Detailed Guide</p> <p>See Provided Instances - Test Isolation for comprehensive examples for each system.</p>"},{"location":"best-practices/#use-cleanup-functions","title":"Use Cleanup Functions","text":"<p>Clean up test data to maintain isolation. The <code>cleanup</code> parameter is passed inside the options:</p> <pre><code>Stove()\n    .with {\n        couchbase {\n            CouchbaseSystemOptions(\n                defaultBucket = \"bucket\",\n                cleanup = { cluster -&gt;\n                    // Clean test data after tests complete\n                    cluster.query(\"DELETE FROM `bucket` WHERE type = 'test'\")\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"couchbase.hosts=${cfg.hostsWithPort}\",\n                        \"couchbase.username=${cfg.username}\",\n                        \"couchbase.password=${cfg.password}\"\n                    )\n                }\n            )\n        }\n\n        kafka {\n            KafkaSystemOptions(\n                cleanup = { admin -&gt;\n                    // Delete test topics after tests complete\n                    val testTopics = admin.listTopics().names().get()\n                        .filter { it.startsWith(\"test-\") }\n                    if (testTopics.isNotEmpty()) {\n                        admin.deleteTopics(testTopics).all().get()\n                    }\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n                        \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n                    )\n                }\n            )\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#test-data-builders","title":"Test Data Builders","text":"<p>Create reusable test data builders:</p> <pre><code>object TestData {\n    fun createUser(\n        id: String = UUID.randomUUID().toString(),\n        name: String = \"Test User\",\n        email: String = \"test-${UUID.randomUUID()}@example.com\"\n    ) = User(id = id, name = name, email = email)\n\n    fun createProduct(\n        id: String = UUID.randomUUID().toString(),\n        name: String = \"Test Product\",\n        price: Double = 99.99\n    ) = Product(id = id, name = name, price = price)\n}\n\n// Usage in tests\ntest(\"should create user\") {\n    val user = TestData.createUser(name = \"John Doe\")\n    // ...\n}\n</code></pre>"},{"location":"best-practices/#assertions","title":"Assertions","text":""},{"location":"best-practices/#be-specific-with-assertions","title":"Be Specific with Assertions","text":"<p>Test specific behaviors, not just successful responses:</p> <pre><code>// \u2705 Good: Specific assertions\nstove {\n    http {\n        postAndExpectBody&lt;OrderResponse&gt;(\n            uri = \"/orders\",\n            body = CreateOrderRequest(id = orderId, amount = 99.99).some()\n        ) { response -&gt;\n            response.status shouldBe 201\n            response.body().id shouldBe orderId\n            response.body().amount shouldBe 99.99\n            response.body().status shouldBe \"CREATED\"\n            response.body().createdAt shouldNotBe null\n        }\n    }\n}\n\n// \u274c Bad: Only checking status code\nstove {\n    http {\n        postAndExpectBodilessResponse(\"/orders\", body = order.some()) { response -&gt;\n            response.status shouldBe 201  // Not enough!\n        }\n    }\n}\n</code></pre>"},{"location":"best-practices/#verify-side-effects","title":"Verify Side Effects","text":"<p>Test the complete flow including side effects: make the request, then verify database state, published events, search index, and cache.</p> <pre><code>test(\"should process order completely\") {\n    val orderId = UUID.randomUUID().toString()\n\n    stove {\n        // 1. Make the request\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(id = orderId).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // 2. Verify database state\n        couchbase {\n            shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n                order.status shouldBe \"CREATED\"\n            }\n        }\n\n        // 3. Verify event was published\n        kafka {\n            shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n                actual.orderId == orderId\n            }\n        }\n\n        // 4. Verify search index updated\n        elasticsearch {\n            shouldGet&lt;Order&gt;(index = \"orders\", key = orderId) { order -&gt;\n                order.status shouldBe \"CREATED\"\n            }\n        }\n\n        // 5. Verify cache populated\n        redis {\n            client().connect().sync().get(\"order:$orderId\") shouldNotBe null\n        }\n    }\n}\n</code></pre>"},{"location":"best-practices/#performance","title":"Performance","text":""},{"location":"best-practices/#use-keepdependenciesrunning-for-development","title":"Use keepDependenciesRunning for Development","text":"<p>Speed up local development:</p> <pre><code>Stove {\n    keepDependenciesRunning()  // Containers stay running between test runs\n}.with {\n    // ...\n}.run()\n</code></pre> <p>Tip</p> <p>Disable <code>keepDependenciesRunning()</code> in CI/CD for clean environments.</p>"},{"location":"best-practices/#configure-appropriate-timeouts","title":"Configure Appropriate Timeouts","text":"<p>Set realistic timeouts for your environment:</p> <pre><code>// HTTP client timeout\nhttp {\n    HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8080\",\n        timeout = 30.seconds  // Adjust based on your app's response times\n    )\n}\n\n// Kafka assertion timeout\nkafka {\n    shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 20.seconds) {\n        // Allow enough time for async processing\n        actual.orderId == orderId\n    }\n}\n</code></pre>"},{"location":"best-practices/#run-tests-in-parallel-with-care","title":"Run Tests in Parallel (With Care)","text":"<p>If running tests in parallel, ensure proper isolation:</p> <pre><code>// Use unique data per test\ntest(\"test 1\") {\n    val id = UUID.randomUUID().toString()  // Unique per test\n    // ...\n}\n\ntest(\"test 2\") {\n    val id = UUID.randomUUID().toString()  // Different ID\n    // ...\n}\n</code></pre>"},{"location":"best-practices/#external-services","title":"External Services","text":""},{"location":"best-practices/#mock-external-dependencies","title":"Mock External Dependencies","text":"<p>Use WireMock for external services:</p> <pre><code>// \u2705 Good: Mock external services\nstove {\n    wiremock {\n        mockPost(\n            url = \"/payments/charge\",\n            statusCode = 200,\n            responseBody = PaymentResult(success = true, transactionId = \"tx-123\").some()\n        )\n    }\n\n    http {\n        postAndExpectBody&lt;OrderResponse&gt;(\n            uri = \"/orders\",\n            body = CreateOrderRequest(amount = 99.99).some()\n        ) { response -&gt;\n            response.body().paymentStatus shouldBe \"PAID\"\n        }\n    }\n}\n\n// \u274c Bad: Calling real external services in tests\n// - Tests become flaky\n// - Tests are slow\n// - May incur costs\n// - Can't test edge cases\n</code></pre>"},{"location":"best-practices/#test-error-scenarios","title":"Test Error Scenarios","text":"<p>Test how your application handles failures:</p> <pre><code>test(\"should handle payment failure gracefully\") {\n    stove {\n        wiremock {\n            mockPost(\n                url = \"/payments/charge\",\n                statusCode = 500,\n                responseBody = ErrorResponse(\"Payment service unavailable\").some()\n            )\n        }\n\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(amount = 99.99).some()\n            ) { response -&gt;\n                response.status shouldBe 503\n                response.body().status shouldBe \"PAYMENT_FAILED\"\n            }\n        }\n    }\n}\n\ntest(\"should retry on transient failures\") {\n    stove {\n        wiremock {\n            behaviourFor(\"/payments/charge\", WireMock::post) {\n                initially {\n                    aResponse().withStatus(503)\n                }\n                then {\n                    aResponse().withStatus(503)\n                }\n                then {\n                    aResponse()\n                        .withStatus(200)\n                        .withBody(it.serialize(PaymentResult(success = true)))\n                }\n            }\n        }\n\n        // Application should retry and eventually succeed\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(amount = 99.99).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"best-practices/#serialization","title":"Serialization","text":""},{"location":"best-practices/#align-serializers","title":"Align Serializers","text":"<p>Ensure Stove uses the same serialization as your application:</p> <pre><code>// If your app uses custom Jackson configuration\nval customObjectMapper = ObjectMapper().apply {\n    registerModule(JavaTimeModule())\n    disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n    setSerializationInclusion(JsonInclude.Include.NON_NULL)\n}\n\nStove()\n    .with {\n        http {\n            HttpClientSystemOptions(\n                baseUrl = \"http://localhost:8080\",\n                contentConverter = JacksonConverter(customObjectMapper)\n            )\n        }\n\n        kafka {\n            KafkaSystemOptions(\n                serde = StoveSerde.jackson.anyByteArraySerde(customObjectMapper)\n            ) { /* config */ }\n        }\n\n        wiremock {\n            WireMockSystemOptions(\n                serde = StoveSerde.jackson.anyByteArraySerde(customObjectMapper)\n            )\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#application-configuration","title":"Application Configuration","text":""},{"location":"best-practices/#make-configuration-testable","title":"Make Configuration Testable","text":"<p>Your application should accept configuration from various sources:</p> <pre><code>// \u2705 Good: Configurable properties\n@Configuration\nclass KafkaConfig(\n    @Value(\"\\${kafka.bootstrapServers}\") private val bootstrapServers: String,\n    @Value(\"\\${kafka.offset:latest}\") private val offset: String,\n    @Value(\"\\${kafka.autoCreateTopics:false}\") private val autoCreate: Boolean\n) {\n    // Stove can override these via command line args\n}\n</code></pre>"},{"location":"best-practices/#external-service-urls-must-be-configurable","title":"External Service URLs Must Be Configurable","text":"<p>When using WireMock, all external service URLs must point to WireMock's URL:</p> <pre><code>// \u2705 Good: External service URLs are configurable\n@Configuration\nclass ExternalServicesConfig(\n    @Value(\"\\${payment.service.url}\") val paymentUrl: String,\n    @Value(\"\\${inventory.service.url}\") val inventoryUrl: String\n)\n\n// In tests, pass WireMock URL for all external services\nStove()\n    .with {\n        wiremock {\n            WireMockSystemOptions(port = 9090)\n        }\n        springBoot(\n            withParameters = listOf(\n                \"payment.service.url=http://localhost:9090\",\n                \"inventory.service.url=http://localhost:9090\"\n            )\n        )\n    }\n</code></pre> <pre><code>// \u274c Bad: Hardcoded URLs won't be intercepted by WireMock\nclass PaymentClient {\n    private val url = \"http://payment-service.com\"  // WireMock can't intercept this!\n}\n</code></pre> <pre><code>// \u274c Bad: Hardcoded values\n@Configuration\nclass KafkaConfig {\n    private val bootstrapServers = \"localhost:9092\"  // Can't change in tests!\n}\n</code></pre>"},{"location":"best-practices/#use-test-profiles-wisely","title":"Use Test Profiles Wisely","text":"<p>Minimize differences between test and production:</p> <pre><code>springBoot(\n    runner = { params -&gt; myApp.run(params) },\n    withParameters = listOf(\n        \"server.port=8080\",\n        \"spring.profiles.active=default\",  // Use default profile when possible\n        \"logging.level.root=warn\",\n        // Override only what's necessary\n        \"kafka.bootstrapServers=${kafkaConfig.bootstrapServers}\"\n    )\n)\n</code></pre>"},{"location":"best-practices/#debugging","title":"Debugging","text":""},{"location":"best-practices/#enable-verbose-logging-when-needed","title":"Enable Verbose Logging When Needed","text":"<pre><code>springBoot(\n    runner = { params -&gt; myApp.run(params) },\n    withParameters = listOf(\n        \"logging.level.root=debug\",  // For debugging\n        \"logging.level.org.springframework.web=trace\"\n    )\n)\n</code></pre>"},{"location":"best-practices/#use-container-inspection","title":"Use Container Inspection","text":"<p>Debug container issues:</p> <pre><code>stove {\n    mongodb {\n        val info = inspect()\n        println(\"Container ID: ${info?.containerId}\")\n        println(\"Network: ${info?.network}\")\n        println(\"IP: ${info?.ipAddress}\")\n    }\n}\n</code></pre>"},{"location":"best-practices/#access-application-beans","title":"Access Application Beans","text":"<p>Debug by accessing application components:</p> <pre><code>stove {\n    using&lt;OrderRepository&gt; {\n        val order = findById(orderId)\n        println(\"Order state: $order\")\n    }\n\n    using&lt;OrderService, PaymentService&gt; { orderService, paymentService -&gt;\n        // Debug complex scenarios\n    }\n}\n</code></pre>"},{"location":"best-practices/#cicd-considerations","title":"CI/CD Considerations","text":""},{"location":"best-practices/#use-provided-instances-in-ci","title":"Use Provided Instances in CI","text":"<p>For faster CI builds, use pre-provisioned infrastructure:</p> <pre><code>val isCI = System.getenv(\"CI\") == \"true\"\n\nStove()\n    .with {\n        kafka {\n            if (isCI) {\n                KafkaSystemOptions.provided(\n                    bootstrapServers = System.getenv(\"KAFKA_SERVERS\"),\n                    configureExposedConfiguration = { cfg -&gt;\n                        listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n                    }\n                )\n            } else {\n                KafkaSystemOptions {\n                    listOf(\"kafka.bootstrapServers=${it.bootstrapServers}\")\n                }\n            }\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#configure-docker-registry","title":"Configure Docker Registry","text":"<p>For corporate environments:</p> <pre><code>// Set globally for all components\nDEFAULT_REGISTRY = System.getenv(\"DOCKER_REGISTRY\") ?: \"docker.io\"\n</code></pre>"},{"location":"best-practices/#handle-resource-constraints","title":"Handle Resource Constraints","text":"<p>Configure for CI resource limits:</p> <pre><code>Stove()\n    .with {\n        couchbase {\n            CouchbaseSystemOptions(\n                container = CouchbaseContainerOptions(\n                    containerFn = { container -&gt;\n                        container.withCreateContainerCmdModifier { cmd -&gt;\n                            cmd.hostConfig?.withMemory(512 * 1024 * 1024)  // 512MB limit\n                        }\n                    }\n                )\n            ) { /* config */ }\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#common-anti-patterns","title":"Common Anti-Patterns","text":""},{"location":"best-practices/#testing-implementation-details","title":"\u274c Testing Implementation Details","text":"<pre><code>// Bad: Testing internal implementation\nusing&lt;OrderRepository&gt; {\n    save(order)\n}\nshouldGet&lt;Order&gt;(orderId) { /* verify */ }\n\n// Good: Test through the API\nhttp {\n    postAndExpectBody&lt;OrderResponse&gt;(\"/orders\", body = order.some()) { /* verify */ }\n}\ncouchbase {\n    shouldGet&lt;Order&gt;(\"orders\", orderId) { /* verify */ }\n}\n</code></pre>"},{"location":"best-practices/#sleeping-instead-of-waiting","title":"\u274c Sleeping Instead of Waiting","text":"<pre><code>// Bad: Fixed sleep\nhttp { post(\"/async-operation\") }\nThread.sleep(5000)  // Fragile!\nkafka { shouldBeConsumed&lt;Event&gt; { true } }\n\n// Good: Poll with timeout\nkafka {\n    shouldBePublished&lt;Event&gt;(atLeastIn = 10.seconds) {\n        actual.id == expectedId\n    }\n}\n</code></pre>"},{"location":"best-practices/#sharing-state-between-tests","title":"\u274c Sharing State Between Tests","text":"<pre><code>// Bad: Shared mutable state\nvar createdUserId: String? = null\n\ntest(\"create user\") {\n    createdUserId = createUser()\n}\n\ntest(\"get user\") {\n    getUser(createdUserId!!)  // Depends on test order!\n}\n\n// Good: Independent tests\ntest(\"create and get user\") {\n    val userId = createUser()\n    getUser(userId)\n}\n</code></pre>"},{"location":"best-practices/#overly-broad-assertions","title":"\u274c Overly Broad Assertions","text":"<pre><code>// Bad: Too vague\nresponse.status shouldBe 200\n\n// Good: Specific assertions\nresponse.status shouldBe 200\nresponse.body().id shouldBe expectedId\nresponse.body().status shouldBe \"ACTIVE\"\nresponse.body().createdAt shouldNotBe null\n</code></pre>"},{"location":"best-practices/#summary","title":"Summary","text":"Do Don't Use unique test data Use hardcoded IDs Test through public APIs Test implementation details Mock external services Call real external services Use appropriate timeouts Use fixed sleeps Clean up test data Leave test artifacts Keep tests independent Share state between tests Be specific in assertions Use vague assertions Test error scenarios Only test happy paths"},{"location":"getting-started/","title":"Getting Started","text":"<p>Get Stove running in your project in just a few minutes. Stove helps you write end-to-end tests by spinning up your application and all its dependencies (databases, message queues, etc.) together, so you can test the real thing instead of mocks.</p>"},{"location":"getting-started/#what-youll-need","title":"What You'll Need","text":"<p>Make sure you have these installed:</p> <ul> <li>JDK 17+ - Stove needs Java 17 or higher</li> <li>Docker - Get the latest version (Stove uses testcontainers, so Docker is required)</li> <li>Kotlin 1.8+ - For writing your tests</li> <li>Gradle or Maven - We use Gradle in all examples, but Maven works too</li> </ul> <p>IDE Setup</p> <p>If you're using IntelliJ IDEA, grab the Kotest plugin. It adds run buttons and makes test discovery much smoother.</p>"},{"location":"getting-started/#step-1-add-dependencies","title":"Step 1: Add Dependencies","text":"<p>Add Stove to your <code>build.gradle.kts</code>:</p> <pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    // Import BOM for version management\n    testImplementation(platform(\"com.trendyol:stove-bom:$stoveVersion\"))\n\n    // Core framework\n    testImplementation(\"com.trendyol:stove\")\n\n    // Optional: Test framework extension for better failure reporting\n    // Choose the one that matches your test framework\n    testImplementation(\"com.trendyol:stove-extensions-kotest\")  // For Kotest\n    // OR\n    testImplementation(\"com.trendyol:stove-extensions-junit\")   // For JUnit 5/6\n\n    // Choose your application framework\n    testImplementation(\"com.trendyol:stove-spring\")\n    // OR\n    testImplementation(\"com.trendyol:stove-ktor\")\n    // For Ktor, also add your preferred DI framework:\n    testImplementation(\"io.insert-koin:koin-ktor:$koinVersion\")  // Koin\n    // OR testImplementation(\"io.ktor:ktor-server-di:$ktorVersion\")  // Ktor-DI\n\n    // Add components you need\n    testImplementation(\"com.trendyol:stove-http\")\n    testImplementation(\"com.trendyol:stove-kafka\")\n    // ... add more as needed\n}\n</code></pre> <p>Latest Version</p> <p>Check the Releases page for the latest version.</p>"},{"location":"getting-started/#step-2-prepare-your-application","title":"Step 2: Prepare Your Application","text":"<p>Stove needs to start your application from tests, which means we need to tweak your main function slightly. Instead of calling <code>runApplication</code> or <code>embeddedServer</code> directly, we'll extract that logic into a separate <code>run</code> function that Stove can call with test-specific parameters.</p> Spring BootKtor with KoinKtor with Ktor-DI <pre><code>// Before\n@SpringBootApplication\nclass MyApplication\n\nfun main(args: Array&lt;String&gt;) {\n    runApplication&lt;MyApplication&gt;(*args)\n}\n\n// After\n@SpringBootApplication\nclass MyApplication\n\nfun main(args: Array&lt;String&gt;) = run(args)\n\nfun run(\n    args: Array&lt;String&gt;,\n    init: SpringApplication.() -&gt; Unit = {}\n): ConfigurableApplicationContext {\n    return runApplication&lt;MyApplication&gt;(*args, init = init)\n}\n</code></pre> <pre><code>// Before\nfun main() {\n    embeddedServer(Netty, port = 8080) {\n        install(Koin) { modules(appModule) }\n        configureRouting()\n    }.start(wait = true)\n}\n\n// After - Accept test modules for overriding beans\nobject MyApp {\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) = run(args)\n\n    fun run(\n        args: Array&lt;String&gt;,\n        wait: Boolean = true,\n        testModules: List&lt;Module&gt; = emptyList()\n    ): Application {\n        return embeddedServer(Netty, port = args.getPort()) {\n            install(Koin) {\n                modules(appModule, *testModules.toTypedArray())\n            }\n            configureRouting()\n        }.start(wait = wait).application\n    }\n}\n</code></pre> <pre><code>// Before\nfun main() {\n    embeddedServer(Netty, port = 8080) {\n        install(DI) { dependencies { provide&lt;MyService&gt; { MyServiceImpl() } } }\n        configureRouting()\n    }.start(wait = true)\n}\n\n// After - Accept test dependency overrides\nobject MyApp {\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) = run(args)\n\n    fun run(\n        args: Array&lt;String&gt;,\n        wait: Boolean = true,\n        testDependencies: (DependencyRegistrar.() -&gt; Unit)? = null\n    ): Application {\n        return embeddedServer(Netty, port = args.getPort()) {\n            install(DI) {\n                dependencies {\n                    provide&lt;MyService&gt; { MyServiceImpl() }\n                    testDependencies?.invoke(this)  // Apply test overrides\n                }\n            }\n            configureRouting()\n        }.start(wait = wait).application\n    }\n}\n</code></pre>"},{"location":"getting-started/#step-3-create-test-configuration","title":"Step 3: Create Test Configuration","text":"<p>Set up Stove once for your entire test suite. This configuration runs before all your tests and shuts down after they're done. Use Stove() and .with { } to configure your test environment. </p> <p>We recommend putting e2e tests in a separate <code>src/test-e2e</code> source set to keep them separate from unit tests (see Best Practices for the Gradle setup).</p> <p>Test Framework Extensions</p> <p><code>StoveKotestExtension</code> and <code>StoveJUnitExtension</code> are separate packages that must be on your classpath:</p> <pre><code>testImplementation(\"com.trendyol:stove-extensions-kotest\") // For Kotest\n// or\ntestImplementation(\"com.trendyol:stove-extensions-junit\")  // For JUnit\n</code></pre> <p>Kotest requires 6.1.3 or later. JUnit requires Jupiter 6.x if possible. In Kotest 6.x, <code>AbstractProjectConfig</code> is no longer auto-scanned. Create a <code>kotest.properties</code> file in your test resources (e.g. <code>src/test-e2e/resources/kotest.properties</code>):</p> <pre><code>kotest.framework.config.fqn=com.myapp.e2e.TestConfig\n</code></pre> <p>Set the value to the fully qualified name of your <code>AbstractProjectConfig</code> class.</p> KotestJUnit <pre><code>// src/test-e2e/kotlin/io/kotest/provided/ProjectConfig.kt\nimport com.trendyol.stove.extensions.kotest.StoveKotestExtension\nimport com.trendyol.stove.system.Stove\nimport com.trendyol.stove.system.stove\nimport com.trendyol.stove.http.*\nimport com.trendyol.stove.spring.springBoot\n\nclass TestConfig : AbstractProjectConfig() {\n    // Optional: Add this for detailed failure reports with execution context\n    override val extensions: List&lt;Extension&gt; = listOf(StoveKotestExtension())\n\n    override suspend fun beforeProject() {\n        Stove()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions(\n                        baseUrl = \"http://localhost:8080\"\n                    )\n                }\n\n                springBoot(\n                    runner = { params -&gt; \n                        com.myapp.run(params)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8080\",\n                        \"logging.level.root=warn\"\n                    )\n                )\n            }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        Stove.stop()\n    }\n}\n</code></pre> <pre><code>// src/test-e2e/kotlin/e2e/TestConfig.kt\nimport com.trendyol.stove.extensions.junit.StoveJUnitExtension\nimport com.trendyol.stove.system.Stove\nimport com.trendyol.stove.http.*\nimport com.trendyol.stove.spring.springBoot\nimport org.junit.jupiter.api.extension.ExtendWith\n\n// Optional: Add this annotation for detailed failure reports\n@ExtendWith(StoveJUnitExtension::class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nabstract class BaseE2ETest {\n\n    companion object {\n        @JvmStatic\n        @BeforeAll\n        fun setup() = runBlocking {\n            Stove()\n                .with {\n                    httpClient {\n                        HttpClientSystemOptions(\n                            baseUrl = \"http://localhost:8080\"\n                        )\n                    }\n\n                    springBoot(\n                        runner = { params -&gt; \n                            com.myapp.run(params)\n                        },\n                        withParameters = listOf(\n                            \"server.port=8080\",\n                            \"logging.level.root=warn\"\n                        )\n                    )\n                }\n                .run()\n        }\n\n        @JvmStatic\n        @AfterAll\n        fun teardown() = runBlocking {\n            Stove.stop()\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#step-4-write-your-first-test","title":"Step 4: Write Your First Test","text":"KotestJUnit <pre><code>import com.trendyol.stove.system.stove\n\nclass MyFirstE2ETest : FunSpec({\n\n    test(\"should return hello world\") {\n        stove {\n            http {\n                get&lt;String&gt;(\"/hello\") { response -&gt;\n                    response shouldBe \"Hello, World!\"\n                }\n            }\n        }\n    }\n\n    test(\"should create a user\") {\n        stove {\n            http {\n                postAndExpectBody&lt;UserResponse&gt;(\n                    uri = \"/users\",\n                    body = CreateUserRequest(name = \"John\", email = \"john@example.com\").some()\n                ) { response -&gt;\n                    response.status shouldBe 201\n                    response.body().name shouldBe \"John\"\n                }\n            }\n        }\n    }\n})\n</code></pre> <pre><code>import com.trendyol.stove.system.stove\n\nclass MyFirstE2ETest : BaseE2ETest() {\n\n    @Test\n    fun `should return hello world`() = runBlocking {\n        stove {\n            http {\n                get&lt;String&gt;(\"/hello\") { response -&gt;\n                    response shouldBe \"Hello, World!\"\n                }\n            }\n        }\n    }\n\n    @Test\n    fun `should create a user`() = runBlocking {\n        stove {\n            http {\n                postAndExpectBody&lt;UserResponse&gt;(\n                    uri = \"/users\",\n                    body = CreateUserRequest(name = \"John\", email = \"john@example.com\").some()\n                ) { response -&gt;\n                    response.status shouldBe 201\n                    response.body().name shouldBe \"John\"\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#step-5-add-more-components","title":"Step 5: Add More Components","text":"<p>Once you've got the basics working, you'll probably want to add more components. Here's how you'd set up a typical stack:</p> <pre><code>Stove()\n    .with {\n        httpClient {\n            HttpClientSystemOptions(baseUrl = \"http://localhost:8080\")\n        }\n\n        // Add Kafka for event-driven tests\n        kafka {\n            KafkaSystemOptions {\n                listOf(\n                    \"kafka.bootstrapServers=${it.bootstrapServers}\",\n                    \"kafka.interceptorClasses=${it.interceptorClass}\"\n                )\n            }\n        }\n\n        // Add Couchbase for database tests\n        couchbase {\n            CouchbaseSystemOptions(\n                defaultBucket = \"myBucket\",\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"couchbase.hosts=${cfg.hostsWithPort}\",\n                        \"couchbase.username=${cfg.username}\",\n                        \"couchbase.password=${cfg.password}\"\n                    )\n                }\n            )\n        }\n\n        // Add WireMock for external service mocking\n        wiremock {\n            WireMockSystemOptions(port = 9090)\n        }\n\n        // Add bridge for DI container access\n        bridge()\n\n        springBoot(\n            runner = { params -&gt; com.myapp.run(params) },\n            withParameters = listOf(\n                \"server.port=8080\",\n                \"external.service.url=http://localhost:9090\"\n            )\n        )\n    }\n    .run()\n</code></pre>"},{"location":"getting-started/#step-6-write-tests-that-span-multiple-systems","title":"Step 6: Write Tests That Span Multiple Systems","text":"<p>Here's where Stove really shines. You can write tests that touch multiple systems and verify everything works together:</p> <pre><code>import com.trendyol.stove.system.stove\n\ntest(\"should create order and publish event\") {\n    stove {\n        val orderId = UUID.randomUUID().toString()\n\n        // Mock external payment service\n        wiremock {\n            mockPost(\n                url = \"/payments\",\n                statusCode = 200,\n                responseBody = PaymentResult(success = true).some()\n            )\n        }\n\n        // Create order via API\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(\n                    id = orderId,\n                    items = listOf(\"item1\", \"item2\"),\n                    amount = 99.99\n                ).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // Verify order stored in database\n        couchbase {\n            shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n                order.status shouldBe \"CREATED\"\n                order.amount shouldBe 99.99\n            }\n        }\n\n        // Verify event was published\n        kafka {\n            shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n                actual.orderId == orderId &amp;&amp;\n                actual.amount == 99.99\n            }\n        }\n\n        // Access application beans directly\n        using&lt;OrderService&gt; {\n            val order = getOrder(orderId)\n            order.status shouldBe \"CREATED\"\n        }\n    }\n}\n</code></pre> <p>Stove starts your application with its dependencies, runs your tests, and shuts everything down when done.</p>"},{"location":"getting-started/#running-tests","title":"Running Tests","text":"<p>Run all your tests:</p> <pre><code>./gradlew test\n</code></pre> <p>Or run a specific test class:</p> <pre><code>./gradlew test --tests \"com.myapp.e2e.OrderE2ETest\"\n</code></pre> <p>If you're using the <code>test-e2e</code> source set, you might have a separate task:</p> <pre><code>./gradlew e2eTest\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you're up and running, here's what to explore next:</p> <ul> <li>Components - Check out the Components documentation to see what's available</li> <li>Tracing - Enable Tracing to see exactly what happened inside your application when a test fails</li> <li>Reporting - Set up Reporting to get detailed failure diagnostics</li> <li>gRPC Mocking - Mock external gRPC services with gRPC Mocking</li> <li>Best Practices - Read the Best Practices guide for tips on writing effective e2e tests</li> <li>Troubleshooting - Hit an issue? Check the Troubleshooting guide</li> <li>Examples - Browse the Examples and Recipes for complete working projects</li> </ul>"},{"location":"getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/#keep-containers-running-between-test-runs","title":"Keep Containers Running Between Test Runs","text":"<p>Starting containers takes time. During development, you can keep them running between test runs to speed things up:</p> <pre><code>Stove {\n    keepDependenciesRunning()\n}.with {\n    // Your configuration\n}.run()\n</code></pre>"},{"location":"getting-started/#using-a-custom-container-registry","title":"Using a Custom Container Registry","text":"<p>If you're behind a corporate firewall or need to use a private registry:</p> <pre><code>// Set globally\nDEFAULT_REGISTRY = \"your.registry.com\"\n\n// Or per component\nkafka {\n    KafkaSystemOptions(\n        container = KafkaContainerOptions(\n            registry = \"your.registry.com\"\n        )\n    )\n}\n</code></pre>"},{"location":"getting-started/#use-unique-test-data","title":"Use Unique Test Data","text":"<p>To avoid test conflicts, generate unique data for each test run:</p> <pre><code>test(\"should create user\") {\n    val userId = UUID.randomUUID().toString()\n    val email = \"test-${UUID.randomUUID()}@example.com\"\n\n    stove {\n        // Use unique data to avoid conflicts\n    }\n}\n</code></pre>"},{"location":"getting-started/#troubleshooting-quick-tips","title":"Troubleshooting Quick Tips","text":"Problem Solution Docker not found Ensure Docker is running and accessible Port conflicts Use dynamic ports or ensure no conflicts Slow startup Enable <code>keepDependenciesRunning()</code> for development Serialization errors Configure <code>StoveSerde</code> to match your app's serializer Test isolation issues Use unique test data and cleanup functions <p>For more help, see the Troubleshooting Guide.</p>"},{"location":"troubleshooting/","title":"Troubleshooting &amp; FAQ","text":"<p>Having issues? This guide covers the most common problems and how to fix them. If you don't find what you're looking for, feel free to open an issue on GitHub.</p>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#docker-issues","title":"Docker Issues","text":""},{"location":"troubleshooting/#docker-not-found-not-running","title":"Docker Not Found / Not Running","text":"<p>Symptoms: <pre><code>Could not find a valid Docker environment\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify Docker is installed and running: <pre><code>docker --version\ndocker ps\n</code></pre></p> </li> <li> <p>Check Docker daemon status: <pre><code># macOS/Linux\nsystemctl status docker\n\n# or\ndocker info\n</code></pre></p> </li> <li> <p>Restart Docker Desktop (if using Docker Desktop)</p> </li> <li> <p>Check Docker socket permissions: <pre><code># Linux\nsudo chmod 666 /var/run/docker.sock\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#docker-image-pull-failures","title":"Docker Image Pull Failures","text":"<p>Symptoms: <pre><code>Error pulling image: denied: access denied\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Use a custom registry: <pre><code>DEFAULT_REGISTRY = \"your-registry.com\"\n</code></pre></p> </li> <li> <p>Login to registry: <pre><code>docker login your-registry.com\n</code></pre></p> </li> <li> <p>Configure per-component registry: <pre><code>kafka {\n    KafkaSystemOptions(\n        container = KafkaContainerOptions(\n            registry = \"your-registry.com\"\n        )\n    ) { /* config */ }\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#port-already-in-use","title":"Port Already in Use","text":"<p>Symptoms: <pre><code>Bind for 0.0.0.0:8080 failed: port is already allocated\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Find and kill the process using the port: <pre><code># macOS/Linux\nlsof -i :8080\nkill -9 &lt;PID&gt;\n\n# Windows\nnetstat -ano | findstr :8080\ntaskkill /PID &lt;PID&gt; /F\n</code></pre></p> </li> <li> <p>Use a different port: <pre><code>springBoot(\n    runner = { params -&gt; myApp.run(params) },\n    withParameters = listOf(\"server.port=8081\")\n)\n</code></pre></p> </li> <li> <p>Use dynamic ports: Let the framework assign available ports when possible.</p> </li> </ol>"},{"location":"troubleshooting/#startup-issues","title":"Startup Issues","text":""},{"location":"troubleshooting/#application-fails-to-start","title":"Application Fails to Start","text":"<p>Symptoms: <pre><code>Application failed to start\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check application logs: <pre><code>springBoot(\n    withParameters = listOf(\n        \"logging.level.root=debug\",\n        \"logging.level.org.springframework=debug\"\n    )\n)\n</code></pre></p> </li> <li> <p>Verify configuration is being passed correctly: <pre><code>kafka {\n    KafkaSystemOptions { cfg -&gt;\n        println(\"Kafka config: ${cfg.bootstrapServers}\")  // Debug print\n        listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n    }\n}\n</code></pre></p> </li> <li> <p>Ensure your application accepts CLI arguments: <pre><code>// Application should parse args\nfun run(args: Array&lt;String&gt;) {\n    // args should include Stove's configuration\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#container-startup-timeout","title":"Container Startup Timeout","text":"<p>Symptoms: <pre><code>Container startup timed out\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase container startup timeout: <pre><code>couchbase {\n    CouchbaseSystemOptions(\n        container = CouchbaseContainerOptions(\n            containerFn = { container -&gt;\n                container.withStartupTimeout(Duration.ofMinutes(5))\n            }\n        )\n    ) { /* config */ }\n}\n</code></pre></p> </li> <li> <p>Check container resource requirements:</p> </li> <li>Elasticsearch needs at least 2GB RAM</li> <li>Couchbase needs significant memory</li> <li> <p>Reduce memory limits in resource-constrained environments</p> </li> <li> <p>Check Docker resources:</p> </li> <li>Increase Docker Desktop memory allocation</li> <li>Ensure sufficient disk space</li> </ol>"},{"location":"troubleshooting/#test-failures","title":"Test Failures","text":""},{"location":"troubleshooting/#assertion-timeout","title":"Assertion Timeout","text":"<p>Symptoms: <pre><code>Timed out waiting for condition\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase assertion timeout: <pre><code>kafka {\n    shouldBePublished&lt;Event&gt;(atLeastIn = 30.seconds) {\n        actual.id == expectedId\n    }\n}\n</code></pre></p> </li> <li> <p>Check if the operation actually completes:</p> </li> <li>Add logging to verify the operation is triggered</li> <li> <p>Check application logs for errors</p> </li> <li> <p>Verify async processing is working: <pre><code>// Debug by checking intermediate state\nusing&lt;EventProcessor&gt; {\n    println(\"Pending events: ${pendingCount()}\")\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#serializationdeserialization-errors","title":"Serialization/Deserialization Errors","text":"<p>Symptoms: <pre><code>JsonParseException: Unrecognized field\nMismatchedInputException: Cannot deserialize\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Align ObjectMapper configuration: <pre><code>val objectMapper = ObjectMapper().apply {\n    registerModule(KotlinModule.Builder().build())\n    registerModule(JavaTimeModule())\n    disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n}\n\nStove()\n    .with {\n        http {\n            HttpClientSystemOptions(\n                contentConverter = JacksonConverter(objectMapper)\n            )\n        }\n        kafka {\n            KafkaSystemOptions(\n                serde = StoveSerde.jackson.anyByteArraySerde(objectMapper)\n            ) { /* config */ }\n        }\n    }\n</code></pre></p> </li> <li> <p>Check field name mapping: <pre><code>data class MyEvent(\n    @JsonProperty(\"eventId\")  // Match exact field name\n    val id: String\n)\n</code></pre></p> </li> <li> <p>Verify data class has default constructor for Jackson: <pre><code>// Add default values or use @JsonCreator\ndata class MyEvent(\n    val id: String = \"\",\n    val name: String = \"\"\n)\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#data-not-found","title":"Data Not Found","text":"<p>Symptoms: <pre><code>Resource with key (xxx) is not found\nDocument not found\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify data was actually saved: <pre><code>// Save\ncouchbase {\n    save(collection = \"orders\", id = orderId, instance = order)\n\n    // Immediately verify\n    shouldGet&lt;Order&gt;(\"orders\", orderId) { o -&gt;\n        println(\"Saved order: $o\")\n    }\n}\n</code></pre></p> </li> <li> <p>Check timing - wait for async operations: <pre><code>// If save is async, wait for it\ndelay(1.seconds)\n\ncouchbase {\n    shouldGet&lt;Order&gt;(\"orders\", orderId) { /* verify */ }\n}\n</code></pre></p> </li> <li> <p>Verify collection/index names match: <pre><code>// Ensure collection names are consistent\nsave(collection = \"orders\", ...)  // Note: \"orders\" not \"order\"\nshouldGet&lt;Order&gt;(\"orders\", ...)   // Must match!\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#kafka-message-not-found","title":"Kafka Message Not Found","text":"<p>Symptoms: <pre><code>Message was not published within timeout\nMessage was not consumed within timeout\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify Kafka interceptor is configured: <pre><code>// In your Stove setup\naddTestDependencies {\n    bean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;(isPrimary = true)\n}\n</code></pre></p> </li> <li> <p>Check topic names: <pre><code>kafka {\n    shouldBePublished&lt;Event&gt;(atLeastIn = 10.seconds) {\n        println(\"Checking topic: ${metadata.topic}\")  // Debug\n        actual.id == expectedId\n    }\n}\n</code></pre></p> </li> <li> <p>Verify interceptor class is passed to application: <pre><code>kafka {\n    KafkaSystemOptions { cfg -&gt;\n        listOf(\n            \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n            \"kafka.interceptorClasses=${cfg.interceptorClass}\"  // Important!\n        )\n    }\n}\n</code></pre></p> </li> <li> <p>Check consumer group offset configuration: <pre><code>springBoot(\n    withParameters = listOf(\n        \"kafka.offset=earliest\",  // Start from beginning\n        \"kafka.autoCreateTopics=true\"\n    )\n)\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#wiremock-stubs-not-being-hit","title":"WireMock Stubs Not Being Hit","text":"<p>Symptoms: <pre><code>Connection refused to external service\nTest timeout when calling mocked endpoint\nMock not found / unexpected request\n</code></pre></p> <p>Cause: This is almost always because your application's external service URLs don't match the WireMock URL.</p> <p>Solutions:</p> <ol> <li> <p>Ensure ALL external service URLs point to WireMock: <pre><code>Stove()\n    .with {\n        wiremock {\n            WireMockSystemOptions(port = 9090)\n        }\n        springBoot(\n            runner = { params -&gt; myApp.run(params) },\n            withParameters = listOf(\n                // ALL external services must use WireMock URL\n                \"payment.service.url=http://localhost:9090\",\n                \"inventory.service.url=http://localhost:9090\",\n                \"notification.service.url=http://localhost:9090\"\n            )\n        )\n    }\n</code></pre></p> </li> <li> <p>Verify your application is reading the URLs from configuration: <pre><code>// Your application should read URLs from config, not hardcode them\n@Value(\"\\${payment.service.url}\")\nprivate lateinit var paymentServiceUrl: String\n</code></pre></p> </li> <li> <p>Check the port matches: <pre><code>// WireMock port\nWireMockSystemOptions(port = 9090)\n\n// Application parameter must match\n\"payment.service.url=http://localhost:9090\"  // Same port!\n</code></pre></p> </li> <li> <p>Debug by checking WireMock requests: <pre><code>wiremock {\n    // After test, check what requests WireMock received\n    WireMock.getAllServeEvents().forEach { event -&gt;\n        println(\"Request: ${event.request.url}\")\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#memory-issues","title":"Memory Issues","text":""},{"location":"troubleshooting/#outofmemoryerror","title":"OutOfMemoryError","text":"<p>Symptoms: OutOfMemoryError (e.g. <code>Java heap space</code>)</p> <p>Solutions:</p> <ol> <li> <p>Increase JVM heap for tests: <pre><code>// build.gradle.kts\ntasks.test {\n    jvmArgs(\"-Xmx2g\", \"-Xms512m\")\n}\n</code></pre></p> </li> <li> <p>Limit container memory: <pre><code>elasticsearch {\n    ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n            containerFn = { container -&gt;\n                container.withEnv(\"ES_JAVA_OPTS\", \"-Xms512m -Xmx512m\")\n            }\n        )\n    ) { /* config */ }\n}\n</code></pre></p> </li> <li> <p>Use provided instances instead of containers for CI environments.</p> </li> </ol>"},{"location":"troubleshooting/#cicd-issues","title":"CI/CD Issues","text":""},{"location":"troubleshooting/#docker-in-docker-not-working","title":"Docker-in-Docker Not Working","text":"<p>Solutions:</p> <ol> <li> <p>Use DinD sidecar in CI: <pre><code># GitLab CI example\nservices:\n  - docker:dind\nvariables:\n  DOCKER_HOST: tcp://docker:2375\n</code></pre></p> </li> <li> <p>Use provided instances: <pre><code>Stove()\n    .with {\n        kafka {\n            KafkaSystemOptions.provided(\n                bootstrapServers = System.getenv(\"KAFKA_SERVERS\"),\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n                }\n            )\n        }\n    }\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#slow-ci-builds","title":"Slow CI Builds","text":"<p>Solutions:</p> <ol> <li>Use provided instances for external infrastructure</li> <li>Enable container reuse: <pre><code>Stove {\n    keepDependenciesRunning()  // In development only\n}\n</code></pre></li> <li>Run tests in parallel (ensure proper isolation)</li> <li>Use smaller container images when available</li> </ol>"},{"location":"troubleshooting/#intermittent-failures-with-shared-infrastructure","title":"Intermittent Failures with Shared Infrastructure","text":"<p>Symptoms: <pre><code>Tests pass locally but fail randomly in CI\nData from another test run appears in assertions\n\"Topic already exists\" or \"Index already exists\" errors\nTests fail when multiple builds run in parallel\n</code></pre></p> <p>Cause: Multiple test runs are using the same resource names (databases, topics, indices) in shared infrastructure.</p> <p>Solutions:</p> <ol> <li> <p>Use unique resource prefixes per test run: <pre><code>object TestRunContext {\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: UUID.randomUUID().toString().take(8)\n\n    val databaseName = \"testdb_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n}\n</code></pre></p> </li> <li> <p>Apply prefixes to all resources: <pre><code>springBoot(\n    withParameters = listOf(\n        \"spring.datasource.url=jdbc:postgresql://db:5432/${TestRunContext.databaseName}\",\n        \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n        \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\"\n    )\n)\n</code></pre></p> </li> <li> <p>Clean up only your resources: <pre><code>cleanup = { admin -&gt;\n    val ourTopics = admin.listTopics().names().get()\n        .filter { it.startsWith(TestRunContext.topicPrefix) }\n    if (ourTopics.isNotEmpty()) {\n        admin.deleteTopics(ourTopics).all().get()\n    }\n}\n</code></pre></p> </li> <li> <p>Log the run ID for debugging: <pre><code>init {\n    println(\"Test Run ID: ${TestRunContext.runId}\")\n}\n</code></pre></p> </li> </ol> <p>Detailed Guide</p> <p>See Provided Instances - Test Isolation for comprehensive examples.</p>"},{"location":"troubleshooting/#faq","title":"FAQ","text":""},{"location":"troubleshooting/#general-questions","title":"General Questions","text":""},{"location":"troubleshooting/#q-can-i-use-stove-with-java","title":"Q: Can I use Stove with Java?","text":"<p>A: Yes, you can use Stove in Java projects! However, the e2e tests themselves need to be written in Kotlin. Stove's DSL is designed specifically for Kotlin, providing a clean and expressive syntax:</p> <pre><code>class MyE2ETest : FunSpec({\n    test(\"should create order\") {\n        stove {\n            http {\n                postAndExpectBodilessResponse(\n                    uri = \"/orders\",\n                    body = Some(CreateOrderRequest()),\n                    expect = { status shouldBe 201 }\n                )\n            }\n        }\n    }\n})\n</code></pre> <p>You can still test your Java application with Stove \u2014 just write your e2e test files in Kotlin.</p>"},{"location":"troubleshooting/#q-can-i-use-junit-instead-of-kotest","title":"Q: Can I use JUnit instead of Kotest?","text":"<p>A: Yes, Stove works with both JUnit and Kotest. See the Getting Started guide for JUnit examples.</p>"},{"location":"troubleshooting/#q-how-do-i-debug-tests","title":"Q: How do I debug tests?","text":"<p>A: </p> <ol> <li>Set breakpoints in your application code</li> <li>Run tests in debug mode</li> <li>Use verbose logging:    <pre><code>withParameters = listOf(\"logging.level.root=debug\")\n</code></pre></li> <li>Access application beans:    <pre><code>using&lt;MyService&gt; {\n    println(\"Service state: $this\")\n}\n</code></pre></li> </ol>"},{"location":"troubleshooting/#q-can-i-run-tests-in-parallel","title":"Q: Can I run tests in parallel?","text":"<p>A: Yes, but ensure proper test isolation:</p> <ul> <li>Use unique test data (UUIDs)</li> <li>Don't share state between tests</li> <li>Be careful with shared resources</li> </ul>"},{"location":"troubleshooting/#q-how-do-i-test-with-ssltls","title":"Q: How do I test with SSL/TLS?","text":"<p>A: Configure the component with security enabled:</p> <pre><code>elasticsearch {\n    ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n            disableSecurity = false\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n            // Certificate info available in cfg.certificate\n            listOf(...)\n        }\n    )\n}\n</code></pre>"},{"location":"troubleshooting/#component-specific-questions","title":"Component-Specific Questions","text":""},{"location":"troubleshooting/#q-why-isnt-my-kafka-message-being-intercepted","title":"Q: Why isn't my Kafka message being intercepted?","text":"<p>A: Ensure:</p> <ol> <li><code>TestSystemKafkaInterceptor</code> is registered as a bean</li> <li><code>kafka.interceptorClasses</code> is configured correctly</li> <li>Your Kafka listener container uses the interceptor</li> </ol> <pre><code>// Application configuration\n@Bean\nfun containerFactory(\n    interceptor: ConsumerAwareRecordInterceptor&lt;String, String&gt;\n): ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; {\n    return ConcurrentKafkaListenerContainerFactory&lt;String, String&gt;().apply {\n        setRecordInterceptor(interceptor)\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#q-how-do-i-test-multiple-databases","title":"Q: How do I test multiple databases?","text":"<p>A: Add multiple database components:</p> <pre><code>Stove()\n    .with {\n        postgresql { PostgresqlOptions(...) }\n        mongodb { MongodbSystemOptions(...) }\n        couchbase { CouchbaseSystemOptions(...) }\n    }\n</code></pre>"},{"location":"troubleshooting/#q-can-i-use-custom-container-images","title":"Q: Can I use custom container images?","text":"<p>A: Yes:</p> <pre><code>kafka {\n    KafkaSystemOptions(\n        container = KafkaContainerOptions(\n            registry = \"my-registry.com\",\n            image = \"custom/kafka\",\n            tag = \"3.5.0\"\n        )\n    ) { /* config */ }\n}\n</code></pre>"},{"location":"troubleshooting/#q-how-do-i-handle-database-migrations","title":"Q: How do I handle database migrations?","text":"<p>A: Use the migrations API:</p> <pre><code>postgresql {\n    PostgresqlOptions(...).migrations {\n        register&lt;CreateUserTableMigration&gt;()\n        register&lt;CreateOrderTableMigration&gt;()\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#q-can-i-access-the-underlying-testcontainer","title":"Q: Can I access the underlying testcontainer?","text":"<p>A: For container operations like pause/unpause:</p> <pre><code>couchbase {\n    pause()    // Pause container\n    unpause()  // Resume container\n}\n</code></pre> <p>For the client: <pre><code>elasticsearch {\n    val client = client()  // Get Elasticsearch client\n    // Use client directly\n}\n</code></pre></p>"},{"location":"troubleshooting/#performance-questions","title":"Performance Questions","text":""},{"location":"troubleshooting/#q-how-can-i-speed-up-test-execution","title":"Q: How can I speed up test execution?","text":"<p>A:</p> <ol> <li> <p>Keep containers running: <pre><code>Stove { keepDependenciesRunning() }\n</code></pre></p> </li> <li> <p>Use provided instances in CI: <pre><code>kafka { KafkaSystemOptions.provided(bootstrapServers = \"...\", configureExposedConfiguration = { ... }) }\n</code></pre></p> </li> <li> <p>Reduce container resource allocation: <pre><code>withEnv(\"ES_JAVA_OPTS\", \"-Xms256m -Xmx256m\")\n</code></pre></p> </li> <li> <p>Run independent tests in parallel</p> </li> </ol>"},{"location":"troubleshooting/#q-why-is-container-startup-slow","title":"Q: Why is container startup slow?","text":"<p>A: Container startup depends on:</p> <ul> <li>Image pull time (first run)</li> <li>Container initialization time</li> <li>Health check completion</li> </ul> <p>Solutions: - Pre-pull images in CI - Use <code>keepDependenciesRunning()</code> locally - Increase startup timeout for slow containers</p>"},{"location":"troubleshooting/#migration-questions","title":"Migration Questions","text":""},{"location":"troubleshooting/#q-how-do-i-migrate-from-014x-to-015x","title":"Q: How do I migrate from 0.14.x to 0.15.x?","text":"<p>A: See Migration Notes for detailed instructions. Key changes:</p> <ul> <li><code>StoveSerde</code> replaces direct <code>ObjectMapper</code> usage</li> <li>Configure serde for each component that needs it</li> </ul>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you can't find a solution:</p> <ol> <li>Search existing issues: GitHub Issues</li> <li>Check examples: Examples Directory</li> <li>Open a new issue: Include:</li> <li>Stove version</li> <li>JDK version</li> <li>Docker version</li> <li>Complete error message</li> <li>Minimal reproduction code</li> </ol>"},{"location":"troubleshooting/#debug-checklist","title":"Debug Checklist","text":"<p>When troubleshooting, check these items:</p> <ul> <li>[ ] Docker is running and accessible</li> <li>[ ] Correct Stove version in dependencies</li> <li>[ ] Application main function is properly modified</li> <li>[ ] Configuration is passed to application</li> <li>[ ] Serializers match between Stove and application</li> <li>[ ] Container has enough resources</li> <li>[ ] Ports are not conflicting</li> <li>[ ] Network is accessible (for provided instances)</li> <li>[ ] Timeouts are appropriate for your environment</li> </ul>"},{"location":"writing-custom-systems/","title":"Writing Custom Systems","text":"<p>Stove's built-in systems cover databases, Kafka, HTTP, gRPC, and more, but your application is unique. Maybe you use a job scheduler, publish domain events, need to control time in tests, or talk to a service over a custom protocol. Custom systems let you bring anything into the Stove DSL so your tests read like this:</p> <pre><code>test(\"should send welcome email after user signs up\") {\n    stove {\n        http {\n            post&lt;UserResponse&gt;(\"/users\", createUserRequest) { it.status shouldBe 201 }\n        }\n\n        tasks {\n            shouldBeExecuted&lt;SendEmailPayload&gt;(atLeastIn = 10.seconds) {\n                recipientEmail == \"new-user@example.com\"\n            }\n        }\n    }\n}\n</code></pre> <p>That <code>tasks { }</code> block is a custom system. Building one is straightforward.</p>"},{"location":"writing-custom-systems/#the-pattern","title":"The Pattern","text":"<p>Every custom system has three pieces:</p>"},{"location":"writing-custom-systems/#1-the-system-class","title":"1. The System Class","text":"<p>Implement PluggedSystem and pick a lifecycle interface that fits your needs:</p> <pre><code>class DbSchedulerSystem(\n    override val stove: Stove\n) : PluggedSystem, AfterRunAwareWithContext&lt;ApplicationContext&gt; {\n\n    private lateinit var listener: StoveDbSchedulerListener\n\n    override suspend fun afterRun(context: ApplicationContext) {\n        listener = context.getBean(StoveDbSchedulerListener::class.java)\n    }\n\n    suspend inline fun &lt;reified T : Any&gt; shouldBeExecuted(\n        atLeastIn: Duration = 5.seconds,\n        noinline condition: T.() -&gt; Boolean\n    ): DbSchedulerSystem {\n        listener.waitUntilObserved(atLeastIn, T::class, condition)\n        return this\n    }\n\n    override fun close() {}\n}\n</code></pre> <p>The lifecycle interfaces control when your system runs: before the app starts, after it starts, or when configuration is collected.</p> Interface When Called <code>RunAware</code> Before application starts <code>AfterRunAware</code> After application starts <code>AfterRunAwareWithContext&lt;T&gt;</code> After application starts, with DI context (e.g., Spring <code>ApplicationContext</code>) <code>ExposesConfiguration</code> When collecting configuration to pass to the application"},{"location":"writing-custom-systems/#2-dsl-extensions","title":"2. DSL Extensions","text":"<p>Two extension functions wire your system into Stove's DSL:</p> <pre><code>@StoveDsl\nfun WithDsl.dbScheduler(): Stove =\n    this.stove.getOrRegister(DbSchedulerSystem(this.stove)).let { this.stove }\n\n@StoveDsl\nsuspend fun ValidationDsl.tasks(\n    validation: suspend DbSchedulerSystem.() -&gt; Unit\n): Unit = validation(this.stove.getOrNone&lt;DbSchedulerSystem&gt;().getOrElse {\n    throw SystemNotRegisteredException(DbSchedulerSystem::class)\n})\n</code></pre> <p>The first one registers the system during setup (<code>.with { dbScheduler() }</code>). The second one exposes it during tests (<code>tasks { ... }</code>).</p>"},{"location":"writing-custom-systems/#3-bean-registration","title":"3. Bean Registration","text":"<p>If your system needs a component inside the application (like a listener), register it as a test bean:</p> <pre><code>springBoot(\n    runner = { params -&gt;\n        runApplication&lt;MyApp&gt;(*params) {\n            addTestDependencies {\n                bean&lt;StoveDbSchedulerListener&gt;(isPrimary = true)\n            }\n        }\n    }\n)\n</code></pre> <p>That's the whole pattern. The rest is your domain logic.</p>"},{"location":"writing-custom-systems/#ideas","title":"Ideas","text":"<p>Here are examples of what you can build. Each shows the test DSL (the part your teammates will see), not the implementation details.</p>"},{"location":"writing-custom-systems/#scheduled-task-testing","title":"Scheduled Task Testing","text":"<p>Test that your application scheduled and executed a task with the expected payload:</p> <pre><code>stove {\n    http {\n        postAndExpectBodilessResponse(\"/orders\", body = orderRequest.some()) {\n            it.status shouldBe 200\n        }\n    }\n\n    tasks {\n        shouldBeExecuted&lt;SendOrderConfirmationPayload&gt;(atLeastIn = 10.seconds) {\n            orderId == expectedOrderId &amp;&amp; recipientEmail == \"customer@example.com\"\n        }\n    }\n}\n</code></pre> <p>Full working example</p> <p>See the spring-showcase recipe for the complete <code>DbSchedulerSystem</code> implementation with reporting integration.</p>"},{"location":"writing-custom-systems/#domain-event-capture","title":"Domain Event Capture","text":"<p>Capture Spring application events in memory and assert on them:</p> <pre><code>stove {\n    http {\n        post&lt;UserResponse&gt;(\"/users\", createUserRequest) { it.status shouldBe 201 }\n    }\n\n    domainEvents {\n        shouldBePublished&lt;UserCreatedEvent&gt;(atLeastIn = 5.seconds) {\n            userId == expectedId &amp;&amp; name == \"John\"\n        }\n\n        shouldNotBePublished&lt;UserDeletedEvent&gt; {\n            userId == expectedId\n        }\n    }\n}\n</code></pre> <p>The system behind this is a <code>@EventListener</code> bean that collects events into a <code>ConcurrentLinkedQueue</code>, and a <code>DomainEventSystem</code> that polls it with a timeout.</p>"},{"location":"writing-custom-systems/#time-control","title":"Time Control","text":"<p>Replace your application's <code>Clock</code> with a test-controllable one:</p> <pre><code>stove {\n    http {\n        post&lt;SessionResponse&gt;(\"/login\", credentials) { sessionId = it.sessionId }\n    }\n\n    time {\n        advance(31.minutes)\n    }\n\n    http {\n        getResponseBodiless(\"/protected\", headers = mapOf(\"Session-ID\" to sessionId)) {\n            it.status shouldBe 401  // Session expired\n        }\n    }\n}\n</code></pre> <p>The system injects a <code>StoveTestClock</code> (extending <code>java.time.Clock</code>) as a Spring bean, and the <code>advance()</code> / <code>setTime()</code> methods manipulate it.</p>"},{"location":"writing-custom-systems/#exposing-configuration","title":"Exposing Configuration","text":"<p>If your system starts infrastructure (like a container) and needs to pass connection details to the application:</p> <pre><code>class MySystem(\n    override val stove: Stove,\n    private val options: MySystemOptions\n) : PluggedSystem, RunAware, ExposesConfiguration {\n\n    private lateinit var config: MyExposedConfig\n\n    override suspend fun run() {\n        config = MyExposedConfig(host = \"localhost\", port = startContainer())\n    }\n\n    override fun configuration(): List&lt;String&gt; =\n        options.configureExposedConfiguration(config)\n\n    override fun close() {}\n}\n</code></pre> <p>Stove collects all <code>configuration()</code> outputs and passes them to the application as startup parameters.</p>"},{"location":"writing-custom-systems/#extending-built-in-systems","title":"Extending Built-In Systems","text":"<p>You don't always need a full system. Sometimes an extension function on an existing system is enough:</p> <pre><code>@StoveDsl\nsuspend fun KafkaSystem.publishWithCorrelationId(\n    topic: String,\n    message: Any,\n    correlationId: String = UUID.randomUUID().toString()\n) {\n    publish(\n        topic = topic,\n        message = message,\n        headers = mapOf(\"X-Correlation-ID\" to correlationId)\n    )\n}\n\n// Usage\nkafka {\n    publishWithCorrelationId(\"orders.created\", orderEvent)\n}\n</code></pre> <p>This works for any built-in system: <code>HttpSystem</code>, <code>KafkaSystem</code>, <code>PostgresqlSystem</code>, etc. Use <code>@StoveDsl</code> for IDE auto-completion support.</p>"},{"location":"Components/","title":"Components","text":"<p>Stove uses a pluggable architecture\u2014each physical dependency is a separate module you can add based on what you need. Components use Testcontainers under the hood. All components work together seamlessly, so you can build your test environment to match your production setup.</p>"},{"location":"Components/#available-components","title":"Available Components","text":"Component Module Description Kafka <code>stove-kafka</code> Message broker for event-driven architectures Couchbase <code>stove-couchbase</code> NoSQL document database Elasticsearch <code>stove-elasticsearch</code> Search and analytics engine PostgreSQL <code>stove-postgres</code> Relational database MySQL <code>stove-mysql</code> Relational database MongoDB <code>stove-mongodb</code> NoSQL document database MSSQL <code>stove-mssql</code> Microsoft SQL Server Redis <code>stove-redis</code> In-memory data store WireMock <code>stove-wiremock</code> HTTP mock server for external services gRPC Mock <code>stove-grpc-mock</code> gRPC mock server for external gRPC services HTTP Client <code>stove-http</code> HTTP client for testing your API gRPC <code>stove-grpc</code> gRPC client for testing gRPC services Bridge Built-in Access to application's DI container Tracing <code>stove-tracing</code> Execution tracing with OpenTelemetry for failure diagnostics"},{"location":"Components/#quick-start","title":"Quick Start","text":"<p>Add the components you need to your <code>build.gradle.kts</code>:</p> Gradle <pre><code>dependencies {\n    // Import BOM for version management\n    testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n\n    // Core testing framework\n    testImplementation(\"com.trendyol:stove\")\n\n    // Application framework support\n    testImplementation(\"com.trendyol:stove-spring\")\n    // or\n    testImplementation(\"com.trendyol:stove-ktor\")\n\n    // Add components based on your needs\n    testImplementation(\"com.trendyol:stove-kafka\")\n    testImplementation(\"com.trendyol:stove-couchbase\")\n    testImplementation(\"com.trendyol:stove-elasticsearch\")\n    testImplementation(\"com.trendyol:stove-http\")\n    testImplementation(\"com.trendyol:stove-wiremock\")\n    // ... add more as needed\n}\n</code></pre>"},{"location":"Components/#architecture-overview","title":"Architecture Overview","text":"<p>Each component follows a consistent pattern:</p> <ol> <li>Configuration - Define how the component should be set up</li> <li>Container/Runtime - Manages the testcontainer or provided instance</li> <li>DSL - Fluent API for test assertions</li> <li>Cleanup - Automatic resource management</li> </ol> <pre><code>Stove()\n  .with {\n    // Each component is configured in the `with` block\n    kafka { KafkaSystemOptions(...) }\n    couchbase { CouchbaseSystemOptions(...) }\n    http { HttpClientSystemOptions(...) }\n    wiremock { WireMockSystemOptions(...) }\n    tracing { enableSpanReceiver() }\n\n    // Application under test\n    springBoot(runner = { params -&gt; myApp.run(params) })\n  }\n  .run() // Starts all components and the application\n\n// Test your application\nstove {\n  http { /* HTTP assertions */ }\n  kafka { /* Kafka assertions */ }\n  couchbase { /* Database assertions */ }\n}\n</code></pre>"},{"location":"Components/#component-categories","title":"Component Categories","text":""},{"location":"Components/#databases","title":"Databases","text":"Type Components Use Case Document Couchbase, MongoDB, Elasticsearch JSON document storage, search Relational PostgreSQL, MySQL, MSSQL Structured data, transactions Key-Value Redis Caching, sessions, pub/sub"},{"location":"Components/#messaging","title":"Messaging","text":"Component Use Case Kafka Event streaming, message queues, pub/sub"},{"location":"Components/#network","title":"Network","text":"Component Use Case HTTP Client Testing your application's REST API gRPC Testing your application's gRPC services WireMock Mocking external HTTP services gRPC Mock Mocking external gRPC services"},{"location":"Components/#application-integration","title":"Application Integration","text":"Component Use Case Bridge Access application beans and services directly Reporting Detailed execution reports and failure diagnostics Tracing Execution tracing with full call chain visibility on failure"},{"location":"Components/#common-configuration-pattern","title":"Common Configuration Pattern","text":"<p>All components follow a similar configuration pattern:</p> <pre><code>componentName {\n  ComponentSystemOptions(\n    // Container configuration\n    container = ContainerOptions(\n      registry = \"docker.io\",\n      image = \"component-image\",\n      tag = \"version\"\n    ),\n\n    // Expose configuration to your application\n    configureExposedConfiguration = { cfg -&gt;\n      listOf(\n        \"app.component.host=${cfg.host}\",\n        \"app.component.port=${cfg.port}\"\n      )\n    }\n  )\n}\n</code></pre>"},{"location":"Components/#testcontainer-vs-provided-instance","title":"Testcontainer vs Provided Instance","text":"<p>Each component supports two modes:</p>"},{"location":"Components/#container-mode-default","title":"Container Mode (Default)","text":"<p>Stove automatically manages testcontainers:</p> <pre><code>kafka {\n  KafkaSystemOptions(\n    container = KafkaContainerOptions(tag = \"latest\"),\n    configureExposedConfiguration = { cfg -&gt; listOf(...) }\n  )\n}\n</code></pre>"},{"location":"Components/#provided-instance-mode","title":"Provided Instance Mode","text":"<p>Connect to existing infrastructure (useful for CI/CD):</p> <pre><code>kafka {\n  KafkaSystemOptions.provided(\n    bootstrapServers = \"localhost:9092\",\n    configureExposedConfiguration = { cfg -&gt; \n      listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n    }\n  )\n}\n</code></pre> <p>See Provided Instances for detailed documentation.</p>"},{"location":"Components/#migrations-support","title":"Migrations Support","text":"<p>Database components support migrations:</p> <pre><code>class CreateTableseMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: PostgresSqlMigrationContext) {\n    connection.operations.execute(\"CREATE TABLE ...\")\n  }\n}\n\npostgresql {\n  PostgresqlOptions(...).migrations {\n    register&lt;CreateTablesMigration&gt;()\n  }\n}\n</code></pre>"},{"location":"Components/#cleanup-support","title":"Cleanup Support","text":"<p>All components support cleanup functions for data isolation:</p> <pre><code>couchbase(\n  cleanup = { cluster -&gt;\n    cluster.query(\"DELETE FROM `bucket` WHERE type = 'test'\")\n  }\n) {\n  CouchbaseSystemOptions(...)\n}\n</code></pre>"},{"location":"Components/#best-practices","title":"Best Practices","text":"<ol> <li>Use random data - Generate unique identifiers for each test to avoid conflicts</li> <li>Leverage cleanup functions - Clean test data between runs</li> <li>Configure timeouts appropriately - Set realistic timeouts for your environment</li> <li>Use the DSL consistently - Leverage the fluent API for readable tests</li> <li>Combine components - Test complete workflows across multiple systems</li> </ol>"},{"location":"Components/#example-full-stack-test","title":"Example: Full Stack Test","text":"<pre><code>test(\"should process order end-to-end\") {\n  stove {\n    val orderId = UUID.randomUUID().toString()\n\n    // Mock payment service\n    wiremock {\n      mockPost(\"/payments\", statusCode = 200, responseBody = PaymentResult(success = true).some())\n    }\n\n    // Create order via API\n    http {\n      postAndExpectBody&lt;OrderResponse&gt;(\"/orders\", body = CreateOrderRequest(orderId).some()) { \n        it.status shouldBe 201 \n      }\n    }\n\n    // Verify stored in database\n    couchbase {\n      shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n        order.status shouldBe \"CREATED\"\n      }\n    }\n\n    // Verify event published\n    kafka {\n      shouldBePublished&lt;OrderCreatedEvent&gt; { actual.orderId == orderId }\n    }\n\n    // Verify indexed for search\n    elasticsearch {\n      shouldGet&lt;Order&gt;(index = \"orders\", key = orderId) { it.status shouldBe \"CREATED\" }\n    }\n\n    // Verify cached\n    redis {\n      client().connect().sync().get(\"order:$orderId\") shouldNotBe null\n    }\n  }\n}\n</code></pre>"},{"location":"Components/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>Couchbase - NoSQL document database with N1QL queries</li> <li>Kafka - Message streaming with producer/consumer testing</li> <li>Elasticsearch - Search engine with query DSL support</li> <li>WireMock - Mock external HTTP dependencies</li> <li>gRPC Mock - Mock external gRPC services</li> <li>HTTP Client - Test your REST API endpoints</li> <li>gRPC - Test your gRPC services with Wire and grpc-kotlin</li> <li>PostgreSQL - Relational database with SQL support</li> <li>MongoDB - Document database with aggregation support</li> <li>MSSQL - Microsoft SQL Server support</li> <li>Redis - In-memory data store for caching</li> <li>Bridge - Direct access to application beans</li> <li>Provided Instances - Use external infrastructure</li> <li>Reporting - Detailed execution reports and failure diagnostics</li> <li>Tracing - Execution tracing with OpenTelemetry for full call chain visibility</li> </ul>"},{"location":"Components/01-couchbase/","title":"Couchbase","text":"Gradle <pre><code>    dependencies {\n        testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n        testImplementation(\"com.trendyol:stove-couchbase\")\n    }\n</code></pre>"},{"location":"Components/01-couchbase/#configure","title":"Configure","text":"<p>Once you've added the dependency, you'll have access to the <code>couchbase</code> function when configuring Stove. This sets up the Couchbase Docker container that will be started for your tests.</p> <p>You'll need to define a <code>defaultBucket</code> name. Make sure this matches what your application expects.</p> <p>Warning</p> <p>Your application needs to use the same bucket names, otherwise tests will fail.</p> <pre><code>Stove()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(defaultBucket = \"test-bucket\", configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      })\n    }\n  }\n  .run()\n</code></pre> <p>Stove exposes the configuration it generates, so you can pass the real connection strings and credentials to your application before it starts. Your application will start with the physical dependencies that are spun-up by the framework.</p>"},{"location":"Components/01-couchbase/#migrations","title":"Migrations","text":"<p>Stove provides a way to run migrations before the test starts.</p> <pre><code>class CouchbaseMigration : DatabaseMigration&lt;Cluster&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: Cluster) {\n    val bucket = connection.bucket(CollectionConstants.BUCKET_NAME)\n    listOf(CollectionConstants.PRODUCT_COLLECTION).forEach { collection -&gt;\n      bucket.collections.createCollection(bucket.defaultScope().name, collection)\n    }\n    connection.waitUntilReady(30.seconds)\n  }\n}\n</code></pre> <p>You can define your migration class by implementing the <code>DatabaseMigration</code> interface. You can define the order of the migration by overriding the <code>order</code> property. The migrations will be executed in the order of the <code>order</code> property.</p> <p>After defining your migration class, you can pass it to the <code>migrations</code> function of the <code>couchbase</code> configuration.</p> <pre><code>Stove()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(defaultBucket = \"test-bucket\", configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      }).migrations {\n        register&lt;CouchbaseMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/01-couchbase/#usage","title":"Usage","text":""},{"location":"Components/01-couchbase/#saving-documents","title":"Saving Documents","text":"<p>Save documents to Couchbase collections:</p> <pre><code>stove {\n  couchbase {\n    // Save to default collection (_default)\n    saveToDefaultCollection(\n      id = \"user:123\",\n      instance = User(id = \"123\", name = \"John Doe\", email = \"john@example.com\")\n    )\n\n    // Save to a specific collection\n    save(\n      collection = \"products\",\n      id = \"product:456\",\n      instance = Product(id = \"456\", name = \"Laptop\", price = 999.99)\n    )\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#getting-documents","title":"Getting Documents","text":"<p>Retrieve and validate documents:</p> <pre><code>stove {\n  couchbase {\n    // Get from default collection\n    shouldGet&lt;User&gt;(\"user:123\") { user -&gt;\n      user.id shouldBe \"123\"\n      user.name shouldBe \"John Doe\"\n      user.email shouldBe \"john@example.com\"\n    }\n\n    // Get from specific collection\n    shouldGet&lt;Product&gt;(\"products\", \"product:456\") { product -&gt;\n      product.id shouldBe \"456\"\n      product.name shouldBe \"Laptop\"\n      product.price shouldBe 999.99\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#checking-non-existence","title":"Checking Non-Existence","text":"<p>Verify that documents don't exist:</p> <pre><code>stove {\n  couchbase {\n    // Check default collection\n    shouldNotExist(\"user:999\")\n\n    // Check specific collection\n    shouldNotExist(\"products\", \"product:999\")\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#deleting-documents","title":"Deleting Documents","text":"<p>Delete documents and verify deletion:</p> <pre><code>stove {\n  couchbase {\n    // Delete from default collection\n    shouldDelete(\"user:123\")\n    shouldNotExist(\"user:123\")\n\n    // Delete from specific collection\n    shouldDelete(\"products\", \"product:456\")\n    shouldNotExist(\"products\", \"product:456\")\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#n1ql-queries","title":"N1QL Queries","text":"<p>Execute N1QL queries and validate results:</p> <pre><code>stove {\n  couchbase {\n    // Simple query\n    shouldQuery&lt;User&gt;(\"SELECT u.* FROM `users` u WHERE u.age &gt; 18\") { users -&gt;\n      users.size shouldBeGreaterThan 0\n      users.all { it.age &gt; 18 } shouldBe true\n    }\n\n    // Query with multiple conditions\n    shouldQuery&lt;Product&gt;(\n      \"\"\"\n      SELECT p.* \n      FROM `products` p \n      WHERE p.price &gt; 100 AND p.category = 'Electronics'\n      \"\"\".trimIndent()\n    ) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.price &gt; 100 &amp;&amp; it.category == \"Electronics\" } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#working-with-collections-and-scopes","title":"Working with Collections and Scopes","text":"<p>Access bucket, collection, and cluster directly:</p> <pre><code>stove {\n  couchbase {\n    // Access the cluster\n    val cluster = cluster()\n\n    // Access the bucket\n    val bucket = bucket()\n\n    // Perform custom operations\n    val customResult = bucket.collections.getAllScopes()\n    customResult shouldNotBe null\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Control the Couchbase container for testing failure scenarios:</p> <pre><code>stove {\n  couchbase {\n    // Pause the container\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the container\n    unpause()\n\n    // Verify recovery\n    shouldGet&lt;User&gt;(\"user:123\") { user -&gt;\n      user.id shouldBe \"123\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, Couchbase, and Kafka:</p> <pre><code>test(\"should create product and store in couchbase\") {\n  stove {\n    val productId = UUID.randomUUID().toString()\n    val productName = \"Gaming Laptop\"\n    val categoryId = 1\n\n    // Mock external service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Create product via API\n    http {\n      postAndExpectBody&lt;Any&gt;(\n        uri = \"/products\",\n        body = ProductCreateRequest(\n          name = productName,\n          price = 1299.99,\n          categoryId = categoryId\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify stored in Couchbase\n    couchbase {\n      shouldGet&lt;Product&gt;(\"products\", \"product:$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe productName\n        product.price shouldBe 1299.99\n        product.categoryId shouldBe categoryId\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName &amp;&amp;\n        actual.price == 1299.99\n      }\n    }\n\n    // Query products by category\n    couchbase {\n      shouldQuery&lt;Product&gt;(\n        \"\"\"\n        SELECT p.* \n        FROM `products` p \n        WHERE p.categoryId = $categoryId\n        \"\"\".trimIndent()\n      ) { products -&gt;\n        products.size shouldBeGreaterThan 0\n        products.any { it.id == productId } shouldBe true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#integration-with-application","title":"Integration with Application","text":"<p>Verify application behavior using the bridge:</p> <pre><code>test(\"should use repository to save product\") {\n  stove {\n    val productId = UUID.randomUUID().toString()\n    val product = Product(id = productId, name = \"Test Product\", price = 99.99)\n\n    // Use application's repository\n    using&lt;ProductRepository&gt; {\n      save(product)\n    }\n\n    // Verify in Couchbase\n    couchbase {\n      shouldGet&lt;Product&gt;(\"products\", \"product:$productId\") { savedProduct -&gt;\n        savedProduct.id shouldBe productId\n        savedProduct.name shouldBe \"Test Product\"\n        savedProduct.price shouldBe 99.99\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#advanced-operations","title":"Advanced Operations","text":""},{"location":"Components/01-couchbase/#batch-operations","title":"Batch Operations","text":"<pre><code>stove {\n  couchbase {\n    // Save multiple documents\n    val users = listOf(\n      User(id = \"1\", name = \"Alice\"),\n      User(id = \"2\", name = \"Bob\"),\n      User(id = \"3\", name = \"Charlie\")\n    )\n\n    users.forEach { user -&gt;\n      saveToDefaultCollection(\"user:${user.id}\", user)\n    }\n\n    // Query all\n    shouldQuery&lt;User&gt;(\"SELECT u.* FROM `${bucket().name}` u\") { result -&gt;\n      result.size shouldBeGreaterThanOrEqual users.size\n    }\n\n    // Verify each\n    users.forEach { user -&gt;\n      shouldGet&lt;User&gt;(\"user:${user.id}\") { actual -&gt;\n        actual.name shouldBe user.name\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#error-handling","title":"Error Handling","text":"<pre><code>stove {\n  couchbase {\n    // Document not found\n    shouldNotExist(\"non-existent:key\")\n\n    // Attempting to delete non-existent document throws exception\n    assertThrows&lt;DocumentNotFoundException&gt; {\n      shouldDelete(\"non-existent:key\")\n    }\n\n    // Attempting to assert non-existence on existing document throws assertion error\n    saveToDefaultCollection(\"user:123\", User(id = \"123\", name = \"John\"))\n    assertThrows&lt;AssertionError&gt; {\n      shouldNotExist(\"user:123\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/","title":"Kafka","text":"<p>Stove supports Kafka in two ways: standalone Kafka or Kafka with Spring integration. You can use either one, but not both in the same project.</p>"},{"location":"Components/02-kafka/#standalone-kafka","title":"Standalone Kafka","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-kafka:$version\")\n    }\n</code></pre>"},{"location":"Components/02-kafka/#configure","title":"Configure","text":"<pre><code>Stove()\n  .with {\n    // other dependencies\n\n    kafka {\n      stoveKafkaObjectMapperRef = objectMapperRef\n      KafkaSystemOptions {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\"\n        )\n      }\n    }\n  }.run()\n</code></pre> <p>The configuration values are:</p> <pre><code>class KafkaSystemOptions(\n  /**\n   * Suffixes for error and retry topics in the application.\n   */\n  val topicSuffixes: TopicSuffixes = TopicSuffixes(),\n  /**\n   * If true, the system will listen to the messages published by the Kafka system.\n   */\n  val listenPublishedMessagesFromStove: Boolean = false,\n  /**\n   * The port of the bridge gRPC server that is used to communicate with the Kafka system.\n   */\n  val bridgeGrpcServerPort: Int = stoveKafkaBridgePortDefault.toInt(),\n  /**\n   * The Serde that is used while asserting the messages,\n   * serializing while bridging the messages. Take a look at the [serde] property for more information.\n   *\n   * The default value is [StoveSerde.jackson]'s anyByteArraySerde.\n   * Depending on your application's needs you might want to change this value.\n   *\n   * The places where it was used listed below:\n   *\n   * @see [com.trendyol.stove.standalone.kafka.intercepting.StoveKafkaBridge] for bridging the messages.\n   * @see StoveKafkaValueSerializer for serializing the messages.\n   * @see StoveKafkaValueDeserializer for deserializing the messages.\n   * @see valueSerializer for serializing the messages.\n   */\n  val serde: StoveSerde&lt;Any, ByteArray&gt; = stoveSerdeRef,\n  /**\n   * The Value serializer that is used to serialize messages.\n   */\n  val valueSerializer: Serializer&lt;Any&gt; = StoveKafkaValueSerializer(),\n  /**\n   * The options for the Kafka container.\n   */\n  val containerOptions: KafkaContainerOptions = KafkaContainerOptions(),\n  /**\n   * The options for the Kafka system that is exposed to the application\n   */\n  override val configureExposedConfiguration: (KafkaExposedConfiguration) -&gt; List&lt;String&gt;\n) : SystemOptions, ConfiguresExposedConfiguration&lt;KafkaExposedConfiguration&gt;\n</code></pre>"},{"location":"Components/02-kafka/#configuring-serializer-and-deserializer","title":"Configuring Serializer and Deserializer","text":"<p>Like every <code>SystemOptions</code> object, <code>KafkaSystemOptions</code> has a <code>serde</code> property that you can configure. It is a <code>StoveSerde</code> object that has two functions <code>serialize</code> and <code>deserialize</code>. You can configure them depending on your application's needs.</p> <pre><code>val kafkaSystemOptions = KafkaSystemOptions(\n  serde = object : StoveSerde&lt;Any, ByteArray&gt; {\n    override fun serialize(value: Any): ByteArray {\n      return objectMapper.writeValueAsBytes(value)\n    }\n\n    override fun &lt;T&gt; deserialize(value: ByteArray): T {\n      return objectMapper.readValue(value, Any::class.java) as T\n    }\n  }\n)\n</code></pre>"},{"location":"Components/02-kafka/#kafka-bridge-with-your-application","title":"Kafka Bridge With Your Application","text":"<p>Stove Kafka bridge is a MUST to work with Kafka. Otherwise you can't assert any messages from your application.</p> <p>As you can see in the example above, you need to add a support to your application to work with interceptor that Stove provides.</p> <pre><code> \"kafka.interceptorClasses=com.trendyol.stove.standalone.kafka.intercepting.StoveKafkaBridge\"\n\n// or\n\n\"kafka.interceptorClasses={cfg.interceptorClass}\" // cfg.interceptorClass is exposed by Stove\n</code></pre> <p>Important</p> <p><code>kafka.</code> prefix or <code>interceptorClasses</code> are assumptions that you can change it with your own prefix or configuration.</p>"},{"location":"Components/02-kafka/#spring-kafka","title":"Spring Kafka","text":"<p>When you want to use Kafka with Application Aware testing it provides more assertion capabilities. It is recommended way of working. Stove-Kafka does that with intercepting the messages.</p>"},{"location":"Components/02-kafka/#how-to-get","title":"How to get?","text":"GradleMaven <pre><code>    dependencies {\n      testImplementation(\"com.trendyol:stove-spring-kafka:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-spring-kafka&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"Components/02-kafka/#configure_1","title":"Configure","text":""},{"location":"Components/02-kafka/#configuration-values","title":"Configuration Values","text":"<p>Kafka works with some settings as default, your application might have these values as not configurable, to make the application testable we need to tweak a little bit.</p> <p>If you have the following configurations:</p> <ul> <li><code>AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" | should be \"earliest\"</code></li> <li><code>ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" | should be true</code></li> <li><code>HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" | should be 2 seconds</code></li> </ul> <p>You better make them configurable, so from the e2e testing context we can change them work with Stove-Kafka testing.</p> <p>As an example:</p> <pre><code>Stove()\n  .with {\n    httpClient {\n      HttpClientSystemOptions(baseUrl = \"http://localhost:8080\")\n    }\n    kafka {\n      KafkaSystemOptions {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\"\n        )\n      }\n    }\n    springBoot(\n      runner = { parameters -&gt;\n        com.trendyol.exampleapp.run(parameters)\n      },\n      withParameters = listOf(\n        \"logging.level.root=error\",\n        \"logging.level.org.springframework.web=error\",\n        \"spring.profiles.active=default\",\n        \"server.http2.enabled=false\",\n        \"kafka.heartbeatInSeconds=2\",\n        \"kafka.autoCreateTopics=true\",\n        \"kafka.offset=earliest\"\n      )\n    )\n  }.run()\n</code></pre> <p>As you can see, we pass these configuration values as parameters. Since they are configurable, the application considers these values instead of application-default values.</p>"},{"location":"Components/02-kafka/#consumer-settings","title":"Consumer Settings","text":"<p>Second thing we need to do is tweak your consumer configuration. For that we will provide Stove-Kafka interceptor to your Kafka configuration.</p> <p>Locate to the point where you define your <code>ConcurrentKafkaListenerContainerFactory</code> or where you can set the interceptor. Interceptor needs to implement <code>ConsumerAwareRecordInterceptor&lt;String, String&gt;</code> since Stove-Kafka relies on that.</p> <pre><code>@EnableKafka\n@Configuration\nclass KafkaConsumerConfiguration(\n  private val interceptor: ConsumerAwareRecordInterceptor&lt;String, String&gt;,\n) {\n\n  @Bean\n  fun kafkaListenerContainerFactory(): ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; {\n    val factory = ConcurrentKafkaListenerContainerFactory&lt;String, String&gt;()\n    // ...\n    factory.setRecordInterceptor(interceptor)\n    return factory\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#producer-settings","title":"Producer Settings","text":"<p>Make sure that the aforementioned values are also configurable for producer settings, too. Stove will have access to <code>KafkaTemplate</code> and will use <code>setProducerListener</code> to arrange itself to listen produced messages.</p>"},{"location":"Components/02-kafka/#plugging-in","title":"Plugging in","text":"<p>When all the configuration is done, it is time to tell to application to use our <code>TestSystemInterceptor</code> and configuration values.</p>"},{"location":"Components/02-kafka/#testsysteminterceptor-and-bean-registration","title":"TestSystemInterceptor and Bean Registration","text":"<p>Register the interceptor and serde using <code>addTestDependencies</code>:</p> <p>Spring Boot 2.x / 3.x:</p> <pre><code>import com.trendyol.stove.addTestDependencies\n\nspringBoot(\n  runner = { parameters -&gt;\n    runApplication&lt;MyApp&gt;(*parameters) {\n      addTestDependencies {\n        bean&lt;TestSystemInterceptor&gt;(isPrimary = true)\n        bean { StoveSerde.jackson.anyByteArraySerde(yourObjectMapper()) }\n      }\n    }\n  },\n</code></pre> <p>Spring Boot 4.x:</p> <pre><code>import com.trendyol.stove.addTestDependencies4x\n\nspringBoot(\n  runner = { parameters -&gt;\n    runApplication&lt;MyApp&gt;(*parameters) {\n      addTestDependencies4x {\n        registerBean&lt;TestSystemInterceptor&gt;(primary = true)\n        registerBean { StoveSerde.jackson.anyByteArraySerde(yourObjectMapper()) }\n      }\n    }\n  },\n</code></pre>"},{"location":"Components/02-kafka/#configuring-the-systemundertest-and-parameters","title":"Configuring the SystemUnderTest and Parameters","text":"<pre><code>springBoot(\n  runner = { parameters -&gt;\n    runApplication&lt;MyApp&gt;(*parameters) {\n      addTestDependencies {\n        bean&lt;TestSystemInterceptor&gt;(isPrimary = true)\n        bean { StoveSerde.jackson.anyByteArraySerde(yourObjectMapper()) }\n      }\n    }\n  },\n  withParameters = listOf(\n    \"logging.level.root=error\",\n    \"logging.level.org.springframework.web=error\",\n    \"spring.profiles.active=default\",\n    \"server.http2.enabled=false\",\n    \"kafka.heartbeatInSeconds=2\", // Added Parameter\n    \"kafka.autoCreateTopics=true\", // Added Parameter\n    \"kafka.offset=earliest\" // Added Parameter\n  )\n)\n</code></pre> <p>Now you're full set and have control over Kafka messages from the testing context.</p>"},{"location":"Components/02-kafka/#testing","title":"Testing","text":""},{"location":"Components/02-kafka/#publishing-messages","title":"Publishing Messages","text":"<p>You can publish messages to Kafka topics for testing:</p> <pre><code>stove {\n  kafka {\n    publish(\n      topic = \"product-events\",\n      message = ProductCreated(id = \"123\", name = \"T-Shirt\"),\n      key = \"product-123\".some(), // Optional\n      headers = mapOf(\"X-UserEmail\" to \"user@example.com\"), // Optional\n      partition = 0 // Optional\n    )\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#asserting-published-messages","title":"Asserting Published Messages","text":"<p>Test that your application publishes messages correctly:</p> <pre><code>stove {\n  // Trigger an action in your application\n  http {\n    postAndExpectBodilessResponse(\"/products\", body = CreateProductRequest(name = \"Laptop\").some()) { response -&gt;\n      response.status shouldBe 200\n    }\n  }\n\n  // Verify the message was published\n  kafka {\n    shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n      actual.name == \"Laptop\" &amp;&amp;\n      actual.id != null &amp;&amp;\n      metadata.topic == \"product-events\" &amp;&amp;\n      metadata.headers[\"event-type\"] == \"PRODUCT_CREATED\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#asserting-consumed-messages","title":"Asserting Consumed Messages","text":"<p>Test that your application consumes messages correctly:</p> <pre><code>stove {\n  // Publish a message\n  kafka {\n    publish(\n      topic = \"order-events\",\n      message = OrderCreated(orderId = \"456\", amount = 100.0)\n    )\n  }\n\n  // Verify your application consumed and processed it\n  kafka {\n    shouldBeConsumed&lt;OrderCreated&gt;(atLeastIn = 20.seconds) {\n      actual.orderId == \"456\" &amp;&amp;\n      actual.amount == 100.0\n    }\n  }\n\n  // Verify side effects (e.g., database write)\n  couchbase {\n    shouldGet&lt;Order&gt;(\"order:456\") { order -&gt;\n      order.orderId shouldBe \"456\"\n      order.status shouldBe \"CREATED\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#testing-failed-messages","title":"Testing Failed Messages","text":"<p>Test that your application handles failures correctly:</p> <pre><code>stove {\n  kafka {\n    // Publish an invalid message\n    publish(\"user-events\", FailingEvent(id = 5L))\n\n    // Verify it failed with the expected reason\n    shouldBeFailed&lt;FailingEvent&gt;(atLeastIn = 10.seconds) {\n      actual.id == 5L &amp;&amp;\n      reason is BusinessException\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#testing-retry-logic","title":"Testing Retry Logic","text":"<p>Test that your application retries failed messages:</p> <pre><code>stove {\n  kafka {\n    publish(\"product-failing\", ProductFailingCreated(productId = \"789\"))\n\n    // Verify it was retried 3 times\n    shouldBeRetried&lt;ProductFailingCreated&gt;(atLeastIn = 1.minutes, times = 3) {\n      actual.productId == \"789\"\n    }\n\n    // Verify it ended up in error topic\n    shouldBePublished&lt;ProductFailingCreated&gt;(atLeastIn = 1.minutes) {\n      metadata.topic == \"product-failing.error\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#working-with-message-metadata","title":"Working with Message Metadata","text":"<p>Access message metadata including headers, topic, partition, offset:</p> <pre><code>stove {\n  kafka {\n    shouldBeConsumed&lt;OrderCreated&gt; {\n      actual.orderId == \"123\" &amp;&amp;\n      metadata.topic == \"order-events\" &amp;&amp;\n      metadata.headers[\"correlation-id\"] != null &amp;&amp;\n      metadata.partition == 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#peeking-messages","title":"Peeking Messages","text":"<p>Inspect messages without consuming them:</p> <pre><code>stove {\n  kafka {\n    // Peek at published messages\n    peekPublishedMessages(atLeastIn = 5.seconds, topic = \"product-events\") { record -&gt;\n      record.key == \"product-123\"\n    }\n\n    // Peek at consumed messages\n    peekConsumedMessages(atLeastIn = 5.seconds, topic = \"order-events\") { record -&gt;\n      record.offset &gt;= 10L\n    }\n\n    // Peek at committed messages\n    peekCommittedMessages(topic = \"order-events\") { record -&gt;\n      record.offset == 101L // next offset after 100 messages\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#admin-operations","title":"Admin Operations","text":"<p>Manage Kafka topics and configurations:</p> <pre><code>stove {\n  kafka {\n    adminOperations {\n      createTopic(NewTopic(\"test-topic\", 1, 1))\n      // Other admin operations available here\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#in-flight-consumer","title":"In-Flight Consumer","text":"<p>Create a consumer for advanced testing scenarios:</p> <pre><code>stove {\n  kafka {\n    consumer&lt;String, ProductCreated&gt;(\n      topic = \"product-events\",\n      readOnly = false, // commit messages\n      autoOffsetReset = \"earliest\",\n      autoCreateTopics = true,\n      keepConsumingAtLeastFor = 10.seconds\n    ) { record -&gt;\n      println(\"Consumed: ${record.value()}\")\n      // Process the message\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, Kafka, and database assertions:</p> <pre><code>test(\"should create product and publish event\") {\n  stove {\n    val productId = UUID.randomUUID()\n    val productName = \"Laptop\"\n\n    // Mock external service\n    wiremock {\n      mockGet(\"/categories/electronics\", statusCode = 200, responseBody = Category(id = 1, active = true).some())\n    }\n\n    // Make HTTP request\n    http {\n      postAndExpectBodilessResponse(\n        uri = \"/products\",\n        body = ProductCreateRequest(id = productId, name = productName, categoryId = 1).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify Kafka message was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName &amp;&amp;\n        metadata.headers[\"X-UserEmail\"] != null\n      }\n    }\n\n    // Verify database state\n    couchbase {\n      shouldGet&lt;Product&gt;(\"product:$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe productName\n      }\n    }\n\n    // Verify the event was consumed by another service\n    kafka {\n      shouldBeConsumed&lt;ProductCreatedEvent&gt;(atLeastIn = 20.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/","title":"Elasticsearch","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-elasticsearch:$version\")\n    }\n</code></pre>"},{"location":"Components/03-elasticsearch/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>elasticsearch</code> function. This function configures the Elasticsearch Docker container that is going to be started.</p> <pre><code>Stove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"elasticsearch.host=${cfg.host}\",\n          \"elasticsearch.port=${cfg.port}\",\n          \"elasticsearch.password=${cfg.password}\"\n        )\n      })\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#container-options","title":"Container Options","text":"<p>You can customize the Elasticsearch container:</p> <pre><code>Stove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n          registry = \"docker.elastic.co/\",\n          image = \"elasticsearch/elasticsearch\",\n          tag = \"8.6.1\",\n          password = \"password\",\n          disableSecurity = true, // Disable for simpler test setup\n          exposedPorts = listOf(9200)\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#security-configuration","title":"Security Configuration","text":"<p>For secure Elasticsearch setups with authentication:</p> <pre><code>Stove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n          disableSecurity = false, // Enable security\n          password = \"your-secure-password\"\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\",\n            \"elasticsearch.password=${cfg.password}\",\n            \"elasticsearch.ssl.enabled=true\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#client-configurer","title":"Client Configurer","text":"<p>Customize the Elasticsearch REST client:</p> <pre><code>Stove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        clientConfigurer = ElasticClientConfigurer(\n          httpClientBuilder = {\n            setDefaultRequestConfig(\n              RequestConfig.custom()\n                .setSocketTimeout(60000)\n                .setConnectTimeout(30000)\n                .build()\n            )\n          }\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#custom-json-mapper","title":"Custom JSON Mapper","text":"<p>Use a custom Jackson ObjectMapper for serialization:</p> <pre><code>Stove()\n  .with {\n    elasticsearch {\n      val customMapper = ObjectMapper().apply {\n        registerModule(JavaTimeModule())\n        disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n      }\n      ElasticsearchSystemOptions(\n        jsonpMapper = JacksonJsonpMapper(customMapper),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#migrations","title":"Migrations","text":"<p>Stove provides a way to run index migrations before tests start:</p> <pre><code>class CreateProductIndex : DatabaseMigration&lt;ElasticsearchClient&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: ElasticsearchClient) {\n    connection.indices().create { c -&gt;\n      c.index(\"products\")\n        .mappings { m -&gt;\n          m.properties(\"name\") { p -&gt; p.text { t -&gt; t } }\n            .properties(\"price\") { p -&gt; p.double_ { d -&gt; d } }\n            .properties(\"category\") { p -&gt; p.keyword { k -&gt; k } }\n            .properties(\"createdAt\") { p -&gt; p.date { d -&gt; d } }\n        }\n    }\n  }\n}\n</code></pre> <p>Register migrations in your Stove configuration:</p> <pre><code>Stove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      ).migrations {\n        register&lt;CreateProductIndex&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#usage","title":"Usage","text":""},{"location":"Components/03-elasticsearch/#saving-documents","title":"Saving Documents","text":"<p>Save documents to Elasticsearch indices:</p> <pre><code>stove {\n  elasticsearch {\n    // Save a document\n    save(\n      id = \"product-123\",\n      instance = Product(\n        id = \"123\",\n        name = \"Laptop\",\n        price = 999.99,\n        category = \"Electronics\"\n      ),\n      index = \"products\"\n    )\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#getting-documents","title":"Getting Documents","text":"<p>Retrieve and validate documents:</p> <pre><code>stove {\n  elasticsearch {\n    // Get by ID and validate\n    shouldGet&lt;Product&gt;(index = \"products\", key = \"product-123\") { product -&gt;\n      product.id shouldBe \"123\"\n      product.name shouldBe \"Laptop\"\n      product.price shouldBe 999.99\n      product.category shouldBe \"Electronics\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#checking-non-existence","title":"Checking Non-Existence","text":"<p>Verify that documents don't exist:</p> <pre><code>stove {\n  elasticsearch {\n    // Verify document doesn't exist\n    shouldNotExist(key = \"product-999\", index = \"products\")\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#deleting-documents","title":"Deleting Documents","text":"<p>Delete documents and verify deletion:</p> <pre><code>stove {\n  elasticsearch {\n    // Delete a document\n    shouldDelete(key = \"product-123\", index = \"products\")\n\n    // Verify deletion\n    shouldNotExist(key = \"product-123\", index = \"products\")\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#querying-with-json-query-dsl","title":"Querying with JSON Query DSL","text":"<p>Execute Elasticsearch queries using JSON DSL:</p> <pre><code>stove {\n  elasticsearch {\n    // Query using JSON DSL\n    shouldQuery&lt;Product&gt;(\n      query = \"\"\"\n        {\n          \"bool\": {\n            \"must\": [\n              { \"match\": { \"category\": \"Electronics\" } },\n              { \"range\": { \"price\": { \"gte\": 500 } } }\n            ]\n          }\n        }\n      \"\"\".trimIndent(),\n      index = \"products\"\n    ) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.category == \"Electronics\" &amp;&amp; it.price &gt;= 500 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#querying-with-query-builder","title":"Querying with Query Builder","text":"<p>Use the Elasticsearch Java client's query builder:</p> <pre><code>stove {\n  elasticsearch {\n    // Query using Query builder\n    val query = Query.of { q -&gt;\n      q.bool { b -&gt;\n        b.must { m -&gt;\n          m.match { t -&gt; t.field(\"category\").query(\"Electronics\") }\n        }.filter { f -&gt;\n          f.range { r -&gt; r.field(\"price\").gte(JsonData.of(500)) }\n        }\n      }\n    }\n\n    shouldQuery&lt;Product&gt;(query) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.category == \"Electronics\" &amp;&amp; it.price &gt;= 500 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#accessing-the-client-directly","title":"Accessing the Client Directly","text":"<p>For advanced operations, access the Elasticsearch client:</p> <pre><code>stove {\n  elasticsearch {\n    val esClient = client()\n\n    // Perform custom operations\n    val indexExists = esClient.indices().exists { e -&gt; e.index(\"products\") }.value()\n    indexExists shouldBe true\n\n    // Bulk operations\n    esClient.bulk { b -&gt;\n      b.operations { op -&gt;\n        op.index { i -&gt;\n          i.index(\"products\")\n            .id(\"bulk-1\")\n            .document(Product(id = \"bulk-1\", name = \"Mouse\", price = 29.99, category = \"Electronics\"))\n        }\n      }.operations { op -&gt;\n        op.index { i -&gt;\n          i.index(\"products\")\n            .id(\"bulk-2\")\n            .document(Product(id = \"bulk-2\", name = \"Keyboard\", price = 79.99, category = \"Electronics\"))\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Control the Elasticsearch container for testing failure scenarios:</p> <pre><code>stove {\n  elasticsearch {\n    // Elasticsearch is running\n    shouldGet&lt;Product&gt;(index = \"products\", key = \"product-123\") { product -&gt;\n      product.id shouldBe \"123\"\n    }\n\n    // Pause the container\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the container\n    unpause()\n\n    // Verify recovery\n    shouldGet&lt;Product&gt;(index = \"products\", key = \"product-123\") { product -&gt;\n      product.id shouldBe \"123\"\n    }\n  }\n}\n</code></pre> <p>Warning</p> <p><code>pause()</code> and <code>unpause()</code> operations are not supported when using a provided instance.</p>"},{"location":"Components/03-elasticsearch/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, Elasticsearch, and Kafka:</p> <pre><code>test(\"should create product and index in elasticsearch\") {\n  stove {\n    val productId = UUID.randomUUID().toString()\n    val productName = \"Gaming Laptop\"\n    val categoryId = 1\n\n    // Mock external service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Create product via API\n    http {\n      postAndExpectBody&lt;ProductResponse&gt;(\n        uri = \"/products\",\n        body = ProductCreateRequest(\n          name = productName,\n          price = 1299.99,\n          categoryId = categoryId\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().id shouldNotBe null\n      }\n    }\n\n    // Verify indexed in Elasticsearch\n    elasticsearch {\n      shouldGet&lt;Product&gt;(index = \"products\", key = productId) { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe productName\n        product.price shouldBe 1299.99\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName\n      }\n    }\n\n    // Query products by category\n    elasticsearch {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"\n          {\n            \"term\": { \"category\": \"Electronics\" }\n          }\n        \"\"\".trimIndent(),\n        index = \"products\"\n      ) { products -&gt;\n        products.size shouldBeGreaterThan 0\n        products.any { it.id == productId } shouldBe true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#integration-with-application","title":"Integration with Application","text":"<p>Verify application behavior using the bridge:</p> <pre><code>test(\"should use service to index product\") {\n  stove {\n    val productId = UUID.randomUUID().toString()\n    val product = Product(id = productId, name = \"Test Product\", price = 99.99, category = \"Test\")\n\n    // Use application's service\n    using&lt;ProductIndexingService&gt; {\n      indexProduct(product)\n    }\n\n    // Verify in Elasticsearch\n    elasticsearch {\n      shouldGet&lt;Product&gt;(index = \"products\", key = productId) { indexed -&gt;\n        indexed.id shouldBe productId\n        indexed.name shouldBe \"Test Product\"\n        indexed.price shouldBe 99.99\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#advanced-operations","title":"Advanced Operations","text":""},{"location":"Components/03-elasticsearch/#full-text-search","title":"Full-Text Search","text":"<pre><code>stove {\n  elasticsearch {\n    // Setup test data\n    listOf(\n      Product(id = \"1\", name = \"MacBook Pro 16 inch\", price = 2499.99, category = \"Laptops\"),\n      Product(id = \"2\", name = \"MacBook Air M2\", price = 1199.99, category = \"Laptops\"),\n      Product(id = \"3\", name = \"Dell XPS 15\", price = 1799.99, category = \"Laptops\")\n    ).forEach { product -&gt;\n      save(id = product.id, instance = product, index = \"products\")\n    }\n\n    // Full-text search\n    shouldQuery&lt;Product&gt;(\n      query = \"\"\"\n        {\n          \"multi_match\": {\n            \"query\": \"MacBook\",\n            \"fields\": [\"name\", \"description\"]\n          }\n        }\n      \"\"\".trimIndent(),\n      index = \"products\"\n    ) { results -&gt;\n      results.size shouldBe 2\n      results.all { \"MacBook\" in it.name } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#aggregations","title":"Aggregations","text":"<pre><code>stove {\n  elasticsearch {\n    val esClient = client()\n\n    // Search with aggregations\n    val response = esClient.search({ s -&gt;\n      s.index(\"products\")\n        .size(0)\n        .aggregations(\"price_stats\") { a -&gt;\n          a.stats { st -&gt; st.field(\"price\") }\n        }\n        .aggregations(\"by_category\") { a -&gt;\n          a.terms { t -&gt; t.field(\"category.keyword\") }\n        }\n    }, Product::class.java)\n\n    // Access aggregation results\n    val priceStats = response.aggregations()[\"price_stats\"]?.stats()\n    priceStats?.avg() shouldNotBe null\n    priceStats?.min() shouldNotBe null\n    priceStats?.max() shouldNotBe null\n\n    val categoryBuckets = response.aggregations()[\"by_category\"]?.sterms()?.buckets()?.array()\n    categoryBuckets?.size shouldBeGreaterThan 0\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#index-management","title":"Index Management","text":"<pre><code>stove {\n  elasticsearch {\n    val esClient = client()\n\n    // Create index with custom settings\n    esClient.indices().create { c -&gt;\n      c.index(\"test-index\")\n        .settings { s -&gt;\n          s.numberOfShards(\"1\")\n            .numberOfReplicas(\"0\")\n        }\n        .mappings { m -&gt;\n          m.properties(\"title\") { p -&gt; p.text { t -&gt; t.analyzer(\"standard\") } }\n            .properties(\"tags\") { p -&gt; p.keyword { k -&gt; k } }\n        }\n    }\n\n    // Check index exists\n    val exists = esClient.indices().exists { e -&gt; e.index(\"test-index\") }.value()\n    exists shouldBe true\n\n    // Delete index\n    esClient.indices().delete { d -&gt; d.index(\"test-index\") }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#provided-instance-external-elasticsearch","title":"Provided Instance (External Elasticsearch)","text":"<p>For CI/CD pipelines or shared infrastructure:</p> <pre><code>Stove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions.provided(\n        host = System.getenv(\"ELASTICSEARCH_HOST\") ?: \"localhost\",\n        port = System.getenv(\"ELASTICSEARCH_PORT\")?.toInt() ?: 9200,\n        password = System.getenv(\"ELASTICSEARCH_PASSWORD\") ?: \"\",\n        runMigrations = true,\n        cleanup = { esClient -&gt;\n          // Clean up test indices after tests\n          esClient.indices().delete { d -&gt; d.index(\"test-*\") }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\",\n            \"elasticsearch.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#data-classes-example","title":"Data Classes Example","text":"<pre><code>data class Product(\n  val id: String,\n  val name: String,\n  val description: String? = null,\n  val price: Double,\n  val category: String,\n  val tags: List&lt;String&gt; = emptyList(),\n  val createdAt: Instant = Instant.now()\n)\n\ndata class SearchResult(\n  val total: Long,\n  val products: List&lt;Product&gt;\n)\n</code></pre>"},{"location":"Components/04-wiremock/","title":"WireMock","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-wiremock:$version\")\n    }\n</code></pre>"},{"location":"Components/04-wiremock/#configure","title":"Configure","text":"<p>Once you've added the dependency, you'll have access to the <code>wiremock</code> function when configuring Stove.</p> <p>This starts a WireMock server instance. By default, WireMock uses a dynamic port (port = 0),  which lets the system pick an available port automatically. This avoids port conflicts, especially in CI environments.</p> <pre><code>Stove()\n  .with {\n    wiremock {\n      WireMockSystemOptions(\n        // port = 0 by default (dynamic port)\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"external-api.url=${cfg.baseUrl}\"  // e.g., http://localhost:54321\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/04-wiremock/#dynamic-port-configuration-recommended","title":"Dynamic Port Configuration (Recommended)","text":"<p>Using dynamic ports is the recommended approach as it:</p> <ul> <li>Avoids port conflicts in CI/CD pipelines where multiple builds may run in parallel</li> <li>Eliminates \"Address already in use\" errors that occur with hardcoded ports</li> <li>Automatically exposes the actual port to your application via <code>configureExposedConfiguration</code></li> </ul> <pre><code>Stove()\n  .with {\n    wiremock {\n      WireMockSystemOptions(\n        // Dynamic port (default)\n        configureExposedConfiguration = { cfg -&gt;\n          // cfg.baseUrl = \"http://localhost:&lt;dynamic-port&gt;\"\n          // cfg.port = &lt;dynamic-port&gt;\n          // cfg.host = \"localhost\"\n          listOf(\n            \"payment.service.url=${cfg.baseUrl}\",\n            \"inventory.service.url=${cfg.baseUrl}\",\n            \"notification.service.url=${cfg.baseUrl}\"\n          )\n        }\n      )\n    }\n    springBoot(\n      runner = { params -&gt;\n        com.myapp.run(params)\n      }\n      // No need to specify external service URLs here - \n      // they're automatically injected via configureExposedConfiguration\n    )\n  }\n  .run()\n</code></pre>"},{"location":"Components/04-wiremock/#fixed-port-configuration","title":"Fixed Port Configuration","text":"<p>If you need a specific port (not recommended for CI), you can set it explicitly:</p> <pre><code>wiremock {\n  WireMockSystemOptions(\n    port = 9090  // Fixed port\n  )\n}\n</code></pre>"},{"location":"Components/04-wiremock/#options","title":"Options","text":"<pre><code>data class WireMockSystemOptions(\n  /**\n   * Port of wiremock server.\n   * Defaults to 0, which lets WireMock pick an available port automatically.\n   * This avoids port conflicts, especially in CI environments.\n   */\n  val port: Int = 0,\n  /**\n   * Configures wiremock server\n   */\n  val configure: WireMockConfiguration.() -&gt; WireMockConfiguration = { this.notifier(ConsoleNotifier(true)) },\n  /**\n   * Removes the stub when request matches/completes\n   * Default value is false\n   */\n  val removeStubAfterRequestMatched: Boolean = false,\n  /**\n   * Called after stub removed\n   */\n  val afterStubRemoved: AfterStubRemoved = { _, _ -&gt; },\n  /**\n   * Called after request handled\n   */\n  val afterRequest: AfterRequestHandler = { _, _ -&gt; },\n  /**\n   * ObjectMapper for serialization/deserialization\n   */\n  val serde: StoveSerde&lt;Any, ByteArray&gt; = StoveSerde.jackson.anyByteArraySerde(),\n  /**\n   * Configures the exposed configuration for the application under test.\n   * Use this to inject WireMock's URL into your application's configuration.\n   */\n  val configureExposedConfiguration: (WireMockExposedConfiguration) -&gt; List&lt;String&gt; = { _ -&gt; listOf() }\n) : SystemOptions\n\n/**\n * Configuration exposed by WireMock after it starts.\n */\ndata class WireMockExposedConfiguration(\n  val host: String,   // e.g., \"localhost\"\n  val port: Int       // The actual port WireMock is listening on\n) {\n  val baseUrl: String // e.g., \"http://localhost:54321\"\n}\n</code></pre>"},{"location":"Components/04-wiremock/#mocking","title":"Mocking","text":"<p>Wiremock starts a mock server on <code>localhost</code>. With dynamic ports (the default), the actual port is  automatically determined and exposed via <code>configureExposedConfiguration</code>.</p> <p>Critical: External Service URLs Must Match WireMock</p> <p>All external service URLs in your application must be configured to point to the WireMock server.</p> <p>This is one of the most common configuration mistakes. If your application's external service URLs  don't match WireMock's URL, your mocks won't be hit and tests will fail or timeout.</p>"},{"location":"Components/04-wiremock/#url-configuration","title":"URL Configuration","text":"<p>Say your application calls external services in production:</p> <ul> <li><code>http://payment-service.com/api/payments</code></li> <li><code>http://inventory-service.com/api/stock</code></li> <li><code>http://notification-service.com/api/notify</code></li> </ul> <p>For testing, all these base URLs must be replaced with the WireMock URL.  Use <code>configureExposedConfiguration</code> to automatically inject the correct URL:</p> <pre><code>Stove()\n  .with {\n    wiremock {\n      WireMockSystemOptions(\n        // port = 0 (default) - dynamic port\n        configureExposedConfiguration = { cfg -&gt;\n          // cfg.baseUrl contains the actual WireMock URL (e.g., http://localhost:54321)\n          listOf(\n            \"payment.service.url=${cfg.baseUrl}\",\n            \"inventory.service.url=${cfg.baseUrl}\",\n            \"notification.service.url=${cfg.baseUrl}\"\n          )\n        }\n      )\n    }\n    springBoot( // or ktor\n      runner = { params -&gt;\n        com.myapp.run(params)\n      }\n      // External service URLs are automatically configured via configureExposedConfiguration\n    )\n  }\n  .run()\n</code></pre> <p>Why Dynamic Ports?</p> <p>Using <code>port = 0</code> (the default) lets WireMock pick an available port automatically. This is especially  important in CI environments where:</p> <ul> <li>Multiple test runs may execute in parallel</li> <li>Other services might already be using common ports like 8080, 9090</li> <li>You get \"Address already in use\" errors with fixed ports</li> </ul> <p>The <code>configureExposedConfiguration</code> callback receives the actual port after WireMock starts, ensuring your application always connects to the correct URL.</p>"},{"location":"Components/04-wiremock/#application-configuration-tips","title":"Application Configuration Tips","text":"<p>Make your external service URLs configurable in your application:</p> Spring Boot (application.yml)Ktor <pre><code>external:\n  payment-service:\n    url: ${PAYMENT_SERVICE_URL:http://payment-service.com}\n  inventory-service:\n    url: ${INVENTORY_SERVICE_URL:http://inventory-service.com}\n</code></pre> <pre><code>val paymentUrl = environment.config.propertyOrNull(\"payment.service.url\")\n    ?.getString() ?: \"http://payment-service.com\"\n</code></pre> <p>Then in your tests, Stove passes the WireMock URL through parameters, overriding the defaults.</p> <p>All service endpoints will be pointing to the WireMock server. You can now define the stubs for the services that your application calls.</p>"},{"location":"Components/04-wiremock/#usage","title":"Usage","text":""},{"location":"Components/04-wiremock/#get-requests","title":"GET Requests","text":"<p>Mock GET requests with various configurations:</p> <pre><code>stove {\n  wiremock {\n    // Simple GET mock\n    mockGet(\n      url = \"/api/products\",\n      statusCode = 200,\n      responseBody = listOf(\n        Product(\"1\", \"Laptop\", 999.99),\n        Product(\"2\", \"Mouse\", 29.99)\n      ).some()\n    )\n\n    // GET with custom headers\n    mockGet(\n      url = \"/api/user/profile\",\n      statusCode = 200,\n      responseBody = UserProfile(id = \"123\", name = \"John\").some(),\n      responseHeaders = mapOf(\n        \"Content-Type\" to \"application/json\",\n        \"X-Rate-Limit\" to \"100\"\n      )\n    )\n\n    // GET returning error\n    mockGet(\n      url = \"/api/products/999\",\n      statusCode = 404,\n      responseBody = ErrorResponse(\"Product not found\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#post-requests","title":"POST Requests","text":"<p>Mock POST requests with request/response bodies:</p> <pre><code>stove {\n  wiremock {\n    // POST with request and response body\n    mockPost(\n      url = \"/api/orders\",\n      statusCode = 201,\n      requestBody = CreateOrderRequest(items = listOf(\"item1\", \"item2\")).some(),\n      responseBody = OrderResponse(orderId = \"order-123\", status = \"CREATED\").some()\n    )\n\n    // POST with metadata matching\n    mockPost(\n      url = \"/api/users\",\n      statusCode = 201,\n      requestBody = CreateUserRequest(name = \"John\").some(),\n      responseBody = UserResponse(id = \"user-123\", name = \"John\").some(),\n      metadata = mapOf(\"Content-Type\" to \"application/json\")\n    )\n\n    // POST returning error\n    mockPost(\n      url = \"/api/orders\",\n      statusCode = 400,\n      requestBody = InvalidOrderRequest().some(),\n      responseBody = ValidationError(\"Invalid order data\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#put-requests","title":"PUT Requests","text":"<p>Mock PUT requests for updates:</p> <pre><code>stove {\n  wiremock {\n    // PUT with full update\n    mockPut(\n      url = \"/api/products/123\",\n      statusCode = 200,\n      requestBody = UpdateProductRequest(name = \"Updated Product\", price = 899.99).some(),\n      responseBody = Product(\"123\", \"Updated Product\", 899.99).some()\n    )\n\n    // PUT with no response body\n    mockPut(\n      url = \"/api/settings/update\",\n      statusCode = 204,\n      requestBody = UpdateSettingsRequest(theme = \"dark\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#patch-requests","title":"PATCH Requests","text":"<p>Mock PATCH requests for partial updates:</p> <pre><code>stove {\n  wiremock {\n    // PATCH for partial update\n    mockPatch(\n      url = \"/api/users/123\",\n      statusCode = 200,\n      requestBody = mapOf(\"email\" to \"newemail@example.com\").some(),\n      responseBody = UserResponse(id = \"123\", email = \"newemail@example.com\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#delete-requests","title":"DELETE Requests","text":"<p>Mock DELETE requests:</p> <pre><code>stove {\n  wiremock {\n    // DELETE returning success\n    mockDelete(\n      url = \"/api/products/123\",\n      statusCode = 204\n    )\n\n    // DELETE with metadata\n    mockDelete(\n      url = \"/api/users/456\",\n      statusCode = 200,\n      metadata = mapOf(\"Authorization\" to \"Bearer token123\")\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#head-requests","title":"HEAD Requests","text":"<p>Mock HEAD requests:</p> <pre><code>stove {\n  wiremock {\n    mockHead(\n      url = \"/api/products/exists/123\",\n      statusCode = 200\n    )\n\n    mockHead(\n      url = \"/api/products/exists/999\",\n      statusCode = 404\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#advanced-configuration","title":"Advanced Configuration","text":"<p>For complex scenarios, use the configure methods:</p> <pre><code>stove {\n  wiremock {\n    // Advanced GET configuration\n    mockGetConfigure(\n      url = \"/api/search\",\n      urlPatternFn = { urlPathMatching(\"/api/search.*\") }\n    ) { builder, serde -&gt;\n      builder\n        .withQueryParam(\"q\", matching(\".*laptop.*\"))\n        .willReturn(\n          aResponse()\n            .withStatus(200)\n            .withBody(serde.serialize(SearchResults(items = listOf(\"item1\", \"item2\"))))\n        )\n    }\n\n    // Advanced POST configuration\n    mockPostConfigure(\n      url = \"/api/webhooks\",\n      urlPatternFn = { urlEqualTo(it) }\n    ) { builder, serde -&gt;\n      builder\n        .withHeader(\"X-Webhook-Secret\", equalTo(\"secret123\"))\n        .withRequestBody(containing(\"event_type\"))\n        .willReturn(\n          aResponse()\n            .withStatus(200)\n            .withBody(\"Webhook received\")\n        )\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#partial-body-matching","title":"Partial Body Matching","text":"<p>When you only need to match specific fields in a request body without specifying the entire payload,  use the <code>*Containing</code> methods. This is useful when:</p> <ul> <li>The request body has fields you don't control (timestamps, generated IDs)</li> <li>You only care about matching certain business-critical fields</li> <li>The request body structure is complex but you need to match a single unique identifier</li> </ul>"},{"location":"Components/04-wiremock/#basic-partial-matching","title":"Basic Partial Matching","text":"<p>Match requests containing specific fields:</p> <pre><code>stove {\n  wiremock {\n    // Only matches requests where productId = 123, ignores other fields\n    mockPostContaining(\n      url = \"/api/orders\",\n      requestContaining = mapOf(\"productId\" to 123),\n      statusCode = 201,\n      responseBody = OrderResponse(orderId = \"order-123\").some()\n    )\n  }\n}\n\n// This request WILL match (extra fields are ignored):\n// POST /api/orders\n// {\"productId\": 123, \"quantity\": 5, \"userId\": \"user-456\", \"timestamp\": \"2024-01-01T00:00:00Z\"}\n</code></pre>"},{"location":"Components/04-wiremock/#multiple-field-matching-and-logic","title":"Multiple Field Matching (AND Logic)","text":"<p>When you specify multiple fields, they are matched using AND logic - all specified fields  must be present and match for the stub to be triggered:</p> <pre><code>stove {\n  wiremock {\n    // ALL three fields must match for this stub to respond\n    mockPostContaining(\n      url = \"/api/payments\",\n      requestContaining = mapOf(\n        \"orderId\" to \"order-123\",      // AND\n        \"amount\" to 99.99,              // AND\n        \"currency\" to \"USD\"\n      ),\n      statusCode = 200,\n      responseBody = PaymentResponse(transactionId = \"txn-789\").some()\n    )\n  }\n}\n\n// \u2705 MATCHES - all three fields present and correct:\n// {\"orderId\": \"order-123\", \"amount\": 99.99, \"currency\": \"USD\", \"extra\": \"ignored\"}\n\n// \u274c DOES NOT MATCH - missing \"currency\":\n// {\"orderId\": \"order-123\", \"amount\": 99.99}\n\n// \u274c DOES NOT MATCH - wrong value for \"amount\":\n// {\"orderId\": \"order-123\", \"amount\": 50.00, \"currency\": \"USD\"}\n</code></pre>"},{"location":"Components/04-wiremock/#deep-nested-matching-with-dot-notation","title":"Deep Nested Matching with Dot Notation","text":"<p>Match specific fields deep within nested JSON structures using dot notation:</p> <pre><code>stove {\n  wiremock {\n    // Match a single field deep in the JSON structure\n    mockPostContaining(\n      url = \"/api/orders\",\n      requestContaining = mapOf(\"order.customer.id\" to \"cust-123\"),\n      statusCode = 200,\n      responseBody = OrderConfirmation(status = \"confirmed\").some()\n    )\n  }\n}\n\n// This request WILL match:\n// POST /api/orders\n// {\n//   \"order\": {\n//     \"id\": \"order-999\",\n//     \"customer\": {\n//       \"id\": \"cust-123\",           &lt;-- Only this field is matched\n//       \"name\": \"John Doe\",\n//       \"email\": \"john@example.com\"\n//     },\n//     \"items\": [...]\n//   },\n//   \"metadata\": {...}\n// }\n</code></pre>"},{"location":"Components/04-wiremock/#multiple-deep-nested-fields","title":"Multiple Deep Nested Fields","text":"<p>Match multiple fields at different levels of nesting:</p> <pre><code>stove {\n  wiremock {\n    mockPostContaining(\n      url = \"/api/checkout\",\n      requestContaining = mapOf(\n        \"order.customer.id\" to \"cust-123\",\n        \"order.payment.method\" to \"credit_card\",\n        \"metadata.source\" to \"mobile_app\"\n      ),\n      statusCode = 200,\n      responseBody = CheckoutResponse(success = true).some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#nested-object-matching","title":"Nested Object Matching","text":"<p>Match nested objects with partial comparison (extra fields in nested objects are ignored):</p> <pre><code>stove {\n  wiremock {\n    // Match if the \"settings\" object contains at least {enabled: true}\n    mockPutContaining(\n      url = \"/api/config\",\n      requestContaining = mapOf(\n        \"settings\" to mapOf(\"enabled\" to true)\n      ),\n      statusCode = 200\n    )\n  }\n}\n\n// This request WILL match (extra fields in settings are ignored):\n// PUT /api/config\n// {\n//   \"settings\": {\n//     \"enabled\": true,      &lt;-- Matched\n//     \"level\": 5,           &lt;-- Ignored\n//     \"features\": [...]     &lt;-- Ignored\n//   }\n// }\n</code></pre>"},{"location":"Components/04-wiremock/#available-partial-matching-methods","title":"Available Partial Matching Methods","text":"Method HTTP Method Description <code>mockPostContaining</code> POST Partial body matching for POST requests <code>mockPutContaining</code> PUT Partial body matching for PUT requests <code>mockPatchContaining</code> PATCH Partial body matching for PATCH requests <p>All methods support:</p> <ul> <li>Simple values: strings, numbers, booleans</li> <li>Dot notation: <code>\"order.customer.id\"</code> for deep nested access</li> <li>Nested objects: <code>mapOf(\"user\" to mapOf(\"id\" to 123))</code></li> <li>Arrays: <code>mapOf(\"tags\" to listOf(\"important\", \"urgent\"))</code></li> <li>URL patterns: Use <code>urlPatternFn</code> parameter for regex URL matching</li> </ul>"},{"location":"Components/04-wiremock/#url-pattern-with-partial-matching","title":"URL Pattern with Partial Matching","text":"<p>Combine URL patterns with partial body matching:</p> <pre><code>stove {\n  wiremock {\n    mockPostContaining(\n      url = \"/api/v[0-9]+/orders\",\n      requestContaining = mapOf(\"orderId\" to \"order-123\"),\n      statusCode = 200,\n      urlPatternFn = { urlPathMatching(it) }  // Enable regex URL matching\n    )\n  }\n}\n\n// Matches: POST /api/v1/orders, POST /api/v2/orders, etc.\n</code></pre>"},{"location":"Components/04-wiremock/#behavioral-mocking","title":"Behavioral Mocking","text":"<p>Simulate service behavior changes over multiple calls:</p> <pre><code>test(\"service recovers from failure\") {\n  stove {\n    wiremock {\n      behaviourFor(\"/api/external-service\", WireMock::get) {\n        initially {\n          aResponse()\n            .withStatus(503)\n            .withBody(\"Service unavailable\")\n        }\n        then {\n          aResponse()\n            .withStatus(503)\n            .withBody(\"Still unavailable\")\n        }\n        then {\n          aResponse()\n            .withStatus(200)\n            .withHeader(\"Content-Type\", \"application/json\")\n            .withBody(it.serialize(ServiceResponse(status = \"OK\")))\n        }\n      }\n    }\n\n    http {\n      // First call - failure\n      getResponse(\"/api/external-service\") { response -&gt;\n        response.status shouldBe 503\n      }\n\n      // Second call - still failing\n      getResponse(\"/api/external-service\") { response -&gt;\n        response.status shouldBe 503\n      }\n\n      // Third call - success\n      get&lt;ServiceResponse&gt;(\"/api/external-service\") { response -&gt;\n        response.status shouldBe \"OK\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#testing-circuit-breaker","title":"Testing Circuit Breaker","text":"<p>Test circuit breaker patterns with WireMock:</p> <pre><code>test(\"circuit breaker opens after failures\") {\n  stove {\n    wiremock {\n      // Mock service that fails\n      mockGet(\n        url = \"/api/unreliable-service\",\n        statusCode = 500,\n        responseBody = \"Internal Server Error\".some()\n      )\n    }\n\n    // Application calls the service multiple times\n    repeat(5) {\n      http {\n        getResponse(\"/api/call-external\") { response -&gt;\n          // First few calls fail\n          response.status shouldBe 500\n        }\n      }\n    }\n\n    // Update mock to return success\n    wiremock {\n      mockGet(\n        url = \"/api/unreliable-service\",\n        statusCode = 200,\n        responseBody = ServiceResponse(status = \"OK\").some()\n      )\n    }\n\n    // Circuit breaker should open, need to wait for recovery\n    delay(5.seconds)\n\n    http {\n      get&lt;ServiceResponse&gt;(\"/api/call-external\") { response -&gt;\n        response.status shouldBe \"OK\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#complete-example","title":"Complete Example","text":"<p>Here's a complete test with multiple external service mocks:</p> <pre><code>test(\"should create order with external service validation\") {\n  stove {\n    val userId = \"user-123\"\n    val productId = \"product-456\"\n    val categoryId = 1\n\n    // Mock user service\n    wiremock {\n      mockGet(\n        url = \"/users/$userId\",\n        statusCode = 200,\n        responseBody = User(id = userId, name = \"John Doe\", active = true).some(),\n        responseHeaders = mapOf(\"X-Service\" to \"UserService\")\n      )\n    }\n\n    // Mock product catalog service\n    wiremock {\n      mockGet(\n        url = \"/products/$productId\",\n        statusCode = 200,\n        responseBody = Product(\n          id = productId,\n          name = \"Laptop\",\n          price = 999.99,\n          stock = 10\n        ).some()\n      )\n    }\n\n    // Mock category service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Mock inventory service (POST to reserve stock)\n    wiremock {\n      mockPost(\n        url = \"/inventory/reserve\",\n        statusCode = 200,\n        requestBody = ReserveStockRequest(productId = productId, quantity = 1).some(),\n        responseBody = ReservationResponse(reservationId = \"res-789\", success = true).some()\n      )\n    }\n\n    // Create order via your API\n    http {\n      postAndExpectBody&lt;OrderResponse&gt;(\n        uri = \"/orders\",\n        body = CreateOrderRequest(\n          userId = userId,\n          productId = productId,\n          quantity = 1\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().orderId shouldNotBe null\n        response.body().status shouldBe \"CREATED\"\n      }\n    }\n\n    // Verify order was stored\n    postgresql {\n      shouldQuery&lt;Order&gt;(\n        \"SELECT * FROM orders WHERE user_id = ?\",\n        mapper = { row -&gt;\n          Order(\n            id = row.long(\"id\"),\n            userId = row.string(\"user_id\"),\n            productId = row.string(\"product_id\"),\n            quantity = row.int(\"quantity\")\n          )\n        }\n      ) { orders -&gt;\n        orders.size shouldBe 1\n        orders.first().userId shouldBe userId\n        orders.first().productId shouldBe productId\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.userId == userId &amp;&amp;\n        actual.productId == productId\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#error-scenarios","title":"Error Scenarios","text":"<p>Test how your application handles external service failures:</p> <pre><code>test(\"should handle external service unavailability\") {\n  stove {\n    // Mock external service returning 503\n    wiremock {\n      mockGet(\n        url = \"/external-api/data\",\n        statusCode = 503,\n        responseBody = ErrorResponse(\"Service temporarily unavailable\").some()\n      )\n    }\n\n    // Your application should handle this gracefully\n    http {\n      getResponse(\"/api/fetch-data\") { response -&gt;\n        response.status shouldBe 503 // or your fallback status\n      }\n    }\n  }\n}\n\ntest(\"should handle timeout\") {\n  stove {\n    wiremock {\n      mockGetConfigure(\"/slow-endpoint\") { builder, _ -&gt;\n        builder.willReturn(\n          aResponse()\n            .withStatus(200)\n            .withBody(\"Response\")\n            .withFixedDelay(5000) // 5 second delay\n        )\n      }\n    }\n\n    http {\n      getResponse(\"/api/call-slow-service\") { response -&gt;\n        // Your application should timeout and handle it\n        response.status shouldBe 504 // Gateway timeout\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#integration-testing","title":"Integration Testing","text":"<p>Test complex integrations with multiple services:</p> <pre><code>test(\"should orchestrate multiple services\") {\n  stove {\n    val userId = \"user-123\"\n\n    // Mock authentication service\n    wiremock {\n      mockPost(\n        url = \"/auth/validate\",\n        statusCode = 200,\n        requestBody = TokenRequest(token = \"jwt-token\").some(),\n        responseBody = TokenValidation(valid = true, userId = userId).some()\n      )\n    }\n\n    // Mock permissions service\n    wiremock {\n      mockGet(\n        url = \"/permissions/$userId\",\n        statusCode = 200,\n        responseBody = Permissions(\n          userId = userId,\n          roles = listOf(\"USER\", \"ADMIN\")\n        ).some()\n      )\n    }\n\n    // Make authenticated request\n    http {\n      get&lt;SecureData&gt;(\n        uri = \"/api/secure-data\",\n        token = \"jwt-token\".some()\n      ) { data -&gt;\n        data.accessible shouldBe true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#request-verification","title":"Request Verification","text":"<p>Verify that requests were made as expected:</p> <pre><code>test(\"should verify request details\") {\n  stove {\n    wiremock {\n      mockPost(\n        url = \"/api/webhook\",\n        statusCode = 200,\n        metadata = mapOf(\n          \"X-Signature\" to \"expected-signature\"\n        )\n      )\n    }\n\n    // Trigger webhook\n    http {\n      postAndExpectBodilessResponse(\n        uri = \"/trigger-webhook\",\n        body = WebhookTrigger(event = \"user.created\").some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify the webhook was called with correct signature\n    // (WireMock will only match if headers match)\n  }\n}\n</code></pre>"},{"location":"Components/05-http/","title":"HTTP Client","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-http:$version\")\n    }\n</code></pre>"},{"location":"Components/05-http/#configure","title":"Configure","text":"<p>Once you've added the dependency, you'll have access to the <code>httpClient</code> function when configuring Stove:</p> <pre><code>Stove()\n  .with {\n    httpClient {\n      HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8080\",\n      )\n    }\n  }\n  .run()\n</code></pre> <p>The other options that you can set are: <pre><code>data class HttpClientSystemOptions(\n  /**\n   * Base URL of the HTTP client.\n   */\n  val baseUrl: String,\n\n  /**\n   * Content converter for the HTTP client. Default is JacksonConverter. You can use GsonConverter or any other converter.\n   * If you want to use your own converter, you can implement ContentConverter interface.\n   */\n  val contentConverter: ContentConverter = JacksonConverter(StoveSerde.jackson.default),\n\n  /**\n   * Timeout for the HTTP client. Default is 30 seconds.\n   */\n  val timeout: Duration = 30.seconds,\n\n  /**\n   * Create client function for the HTTP client. Default is jsonHttpClient.\n   */\n  val createClient: () -&gt; io.ktor.client.HttpClient = { jsonHttpClient(timeout, contentConverter) }\n)\n</code></pre></p>"},{"location":"Components/05-http/#usage","title":"Usage","text":""},{"location":"Components/05-http/#get-requests","title":"GET Requests","text":"<p>Making GET requests with various options:</p> <pre><code>stove {\n  http {\n    // Simple GET request with type-safe response\n    get&lt;UserResponse&gt;(\"/users/123\") { user -&gt;\n      user.id shouldBe 123\n      user.name shouldBe \"John Doe\"\n    }\n\n    // GET with query parameters\n    get&lt;String&gt;(\"/api/index\", queryParams = mapOf(\"keyword\" to \"search-term\")) { response -&gt;\n      response shouldContain \"search-term\"\n    }\n\n    // GET with headers\n    get&lt;UserProfile&gt;(\"/profile\", headers = mapOf(\"X-Custom-Header\" to \"value\")) { profile -&gt;\n      profile.email shouldNotBe null\n    }\n\n    // GET with authentication token\n    get&lt;SecureData&gt;(\"/secure-endpoint\", token = \"jwt-token\".some()) { data -&gt;\n      data.isAuthorized shouldBe true\n    }\n\n    // GET multiple items (list response)\n    getMany&lt;ProductResponse&gt;(\"/products\", queryParams = mapOf(\"page\" to \"1\", \"size\" to \"10\")) { products -&gt;\n      products.size shouldBe 10\n      products.first().name shouldNotBe null\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#get-with-full-response-access","title":"GET with Full Response Access","text":"<p>When you need access to status code and headers:</p> <pre><code>stove {\n  http {\n    getResponse&lt;UserResponse&gt;(\"/users/123\") { response -&gt;\n      response.status shouldBe 200\n      response.headers[\"Content-Type\"] shouldContain \"application/json\"\n      response.body().id shouldBe 123\n    }\n\n    // Bodiless response (only status and headers)\n    getResponse(\"/health\") { response -&gt;\n      response.status shouldBe 200\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#post-requests","title":"POST Requests","text":"<p>Various POST request patterns:</p> <pre><code>stove {\n  http {\n    // POST with request body and expect JSON response\n    postAndExpectJson&lt;UserResponse&gt;(\"/users\") {\n      CreateUserRequest(name = \"John\", email = \"john@example.com\")\n    } { user -&gt;\n      user.id shouldNotBe null\n      user.name shouldBe \"John\"\n    }\n\n    // POST and expect bodiless response (only status)\n    postAndExpectBodilessResponse(\n      uri = \"/products/activate\",\n      body = ActivateRequest(productId = 123).some()\n    ) { response -&gt;\n      response.status shouldBe 200\n    }\n\n    // POST with full response access\n    postAndExpectBody&lt;ProductResponse&gt;(\n      uri = \"/products\",\n      body = CreateProductRequest(name = \"Laptop\", price = 999.99).some()\n    ) { response -&gt;\n      response.status shouldBe 201\n      response.headers[\"Location\"] shouldNotBe null\n      response.body().id shouldNotBe null\n    }\n\n    // POST with headers and token\n    postAndExpectJson&lt;OrderResponse&gt;(\n      uri = \"/orders\",\n      body = CreateOrderRequest(items = listOf(\"item1\", \"item2\")).some(),\n      headers = mapOf(\"X-Request-ID\" to \"12345\"),\n      token = \"jwt-token\".some()\n    ) { order -&gt;\n      order.id shouldNotBe null\n      order.status shouldBe \"CREATED\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#put-requests","title":"PUT Requests","text":"<p>Update operations with PUT:</p> <pre><code>stove {\n  http {\n    // PUT with response body\n    putAndExpectJson&lt;UserResponse&gt;(\"/users/123\") {\n      UpdateUserRequest(name = \"Jane Doe\", email = \"jane@example.com\")\n    } { user -&gt;\n      user.name shouldBe \"Jane Doe\"\n      user.email shouldBe \"jane@example.com\"\n    }\n\n    // PUT without response body\n    putAndExpectBodilessResponse(\n      uri = \"/products/123\",\n      body = UpdateProductRequest(name = \"Updated Product\").some()\n    ) { response -&gt;\n      response.status shouldBe 200\n    }\n\n    // PUT with full response access\n    putAndExpectBody&lt;ProductResponse&gt;(\n      uri = \"/products/456\",\n      body = UpdateProductRequest(price = 899.99).some()\n    ) { response -&gt;\n      response.status shouldBe 200\n      response.body().price shouldBe 899.99\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#patch-requests","title":"PATCH Requests","text":"<p>Partial updates with PATCH:</p> <pre><code>stove {\n  http {\n    // PATCH with response body\n    patchAndExpectBody&lt;UserResponse&gt;(\n      uri = \"/users/123\",\n      body = mapOf(\"email\" to \"newemail@example.com\").some()\n    ) { response -&gt;\n      response.status shouldBe 200\n      response.body().email shouldBe \"newemail@example.com\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#delete-requests","title":"DELETE Requests","text":"<p>Delete operations:</p> <pre><code>stove {\n  http {\n    // DELETE without response body\n    deleteAndExpectBodilessResponse(\"/users/123\") { response -&gt;\n      response.status shouldBe 204\n    }\n\n    // DELETE with authentication\n    deleteAndExpectBodilessResponse(\n      uri = \"/products/456\",\n      token = \"jwt-token\".some()\n    ) { response -&gt;\n      response.status shouldBe 200\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#file-upload-with-multipart","title":"File Upload with Multipart","text":"<p>Upload files using multipart form data:</p> <pre><code>stove {\n  http {\n    postMultipartAndExpectResponse&lt;UploadResponse&gt;(\n      uri = \"/products/import\",\n      body = listOf(\n        StoveMultiPartContent.Text(\"productName\", \"Laptop\"),\n        StoveMultiPartContent.Text(\"description\", \"A powerful laptop\"),\n        StoveMultiPartContent.File(\n          param = \"file\",\n          fileName = \"products.csv\",\n          content = csvBytes,\n          contentType = MediaType.APPLICATION_OCTET_STREAM_VALUE\n        )\n      )\n    ) { response -&gt;\n      response.status shouldBe 200\n      response.body().uploadedFiles.size shouldBe 1\n      response.body().message shouldContain \"products.csv\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#advanced-using-ktor-client-directly","title":"Advanced: Using Ktor Client Directly","text":"<p>For advanced scenarios, access the underlying Ktor HttpClient:</p> <pre><code>stove {\n  http {\n    client { baseUrl -&gt;\n      // Direct access to Ktor HttpClient\n      val response = get {\n        url(baseUrl.buildString() + \"/custom-endpoint\")\n        header(\"Custom-Header\", \"value\")\n      }\n      println(response.status)\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#complete-example","title":"Complete Example","text":"<p>Here's a complete CRUD test example:</p> <pre><code>test(\"should perform CRUD operations on products\") {\n  stove {\n    var productId: Long? = null\n\n    // CREATE\n    http {\n      postAndExpectBody&lt;ProductResponse&gt;(\n        uri = \"/products\",\n        body = CreateProductRequest(name = \"Laptop\", price = 999.99, categoryId = 1).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        productId = response.body().id\n        response.body().name shouldBe \"Laptop\"\n      }\n    }\n\n    // READ\n    http {\n      get&lt;ProductResponse&gt;(\"/products/$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe \"Laptop\"\n        product.price shouldBe 999.99\n      }\n    }\n\n    // UPDATE\n    http {\n      putAndExpectJson&lt;ProductResponse&gt;(\"/products/$productId\") {\n        UpdateProductRequest(price = 899.99)\n      } { product -&gt;\n        product.price shouldBe 899.99\n      }\n    }\n\n    // DELETE\n    http {\n      deleteAndExpectBodilessResponse(\"/products/$productId\") { response -&gt;\n        response.status shouldBe 204\n      }\n    }\n\n    // Verify deletion\n    http {\n      getResponse&lt;ErrorResponse&gt;(\"/products/$productId\") { response -&gt;\n        response.status shouldBe 404\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#integration-with-other-components","title":"Integration with Other Components","text":""},{"location":"Components/05-http/#http-database","title":"HTTP + Database","text":"<pre><code>stove {\n  // Create via API and capture user ID\n  var userId: Long = 0\n  http {\n    postAndExpectBody&lt;UserResponse&gt;(\"/users\", body = CreateUserRequest(name = \"John\").some()) { response -&gt;\n      userId = response.body().id\n    }\n  }\n\n  // Verify in database\n  postgresql {\n    shouldQuery(\n      query = \"SELECT * FROM users WHERE id = $userId\",\n      mapper = { row -&gt; User(row.long(\"id\"), row.string(\"name\")) }\n    ) { users -&gt;\n      users.size shouldBe 1\n      users.first().name shouldBe \"John\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#http-kafka","title":"HTTP + Kafka","text":"<pre><code>stove {\n  // Trigger event via API\n  http {\n    postAndExpectBodilessResponse(\"/orders\", body = CreateOrderRequest(amount = 100.0).some()) { response -&gt;\n      response.status shouldBe 201\n    }\n  }\n\n  // Verify event was published\n  kafka {\n    shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n      actual.amount == 100.0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#http-wiremock","title":"HTTP + WireMock","text":"<pre><code>stove {\n  // Mock external service\n  wiremock {\n    mockGet(\n      url = \"/external-api/data\",\n      statusCode = 200,\n      responseBody = ExternalData(id = 1, value = \"test\").some()\n    )\n  }\n\n  // Call your API that depends on external service\n  http {\n    get&lt;ResponseData&gt;(\"/data\") { response -&gt;\n      response.value shouldBe \"test\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#error-handling","title":"Error Handling","text":"<pre><code>stove {\n  http {\n    // Test validation errors\n    postAndExpectBody&lt;ValidationErrorResponse&gt;(\"/users\", body = InvalidUserRequest().some()) { response -&gt;\n      response.status shouldBe 400\n      response.body().errors shouldContain \"name is required\"\n    }\n\n    // Test authentication errors\n    getResponse&lt;ErrorResponse&gt;(\"/secure-endpoint\") { response -&gt;\n      response.status shouldBe 401\n    }\n\n    // Test not found\n    getResponse&lt;ErrorResponse&gt;(\"/users/999999\") { response -&gt;\n      response.status shouldBe 404\n    }\n\n    // Test business logic errors\n    postAndExpectBody&lt;ErrorResponse&gt;(\"/products\", body = InvalidProductRequest().some()) { response -&gt;\n      response.status shouldBe 409 // Conflict\n      response.body().message shouldContain \"already exists\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#websocket-support","title":"WebSocket Support","text":"<p>Stove provides built-in support for testing WebSocket endpoints. The WebSocket functionality is integrated into the HTTP system and uses Ktor's WebSocket client under the hood.</p>"},{"location":"Components/05-http/#basic-websocket-usage","title":"Basic WebSocket Usage","text":"<p>Send and receive messages through a WebSocket connection:</p> <pre><code>stove {\n  http {\n    webSocket(\"/chat\") {\n      // Send a text message\n      send(\"Hello, WebSocket!\")\n\n      // Receive a text message\n      val response = receiveText()\n      response shouldBe \"Echo: Hello, WebSocket!\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#sending-messages","title":"Sending Messages","text":"<p>Multiple ways to send messages:</p> <pre><code>stove {\n  http {\n    webSocket(\"/endpoint\") {\n      // Send text message\n      send(\"Hello\")\n\n      // Send binary data\n      send(byteArrayOf(1, 2, 3, 4, 5))\n\n      // Send using sealed class\n      send(StoveWebSocketMessage.Text(\"Hello via sealed class\"))\n      send(StoveWebSocketMessage.Binary(byteArrayOf(1, 2, 3)))\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#receiving-messages","title":"Receiving Messages","text":"<p>Various methods to receive messages:</p> <pre><code>stove {\n  http {\n    webSocket(\"/endpoint\") {\n      // Receive text\n      val text = receiveText()\n      text shouldBe \"expected message\"\n\n      // Receive binary\n      val bytes = receiveBinary()\n      bytes shouldBe byteArrayOf(1, 2, 3)\n\n      // Receive as sealed class (auto-detect type)\n      val message = receive()\n      when (message) {\n        is StoveWebSocketMessage.Text -&gt; println(message.content)\n        is StoveWebSocketMessage.Binary -&gt; println(message.content.size)\n        null -&gt; println(\"Connection closed\")\n      }\n\n      // Receive with timeout\n      val response = receiveTextWithTimeout(5.seconds)\n      response.isSome() shouldBe true\n      response.getOrNull() shouldBe \"expected\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#collecting-multiple-messages","title":"Collecting Multiple Messages","text":"<p>Collect a batch of messages:</p> <pre><code>stove {\n  http {\n    webSocket(\"/broadcast\") {\n      // Collect 5 text messages with a 10 second timeout\n      val messages = collectTexts(count = 5, timeout = 10.seconds)\n      messages.size shouldBe 5\n      messages[0] shouldBe \"Message 1\"\n      messages[4] shouldBe \"Message 5\"\n\n      // Collect binary messages\n      val binaryMessages = collectBinaries(count = 3, timeout = 5.seconds)\n      binaryMessages.size shouldBe 3\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#streaming-with-flow","title":"Streaming with Flow","text":"<p>Use Kotlin Flow for streaming scenarios:</p> <pre><code>stove {\n  http {\n    webSocket(\"/events\") {\n      // Stream text messages\n      val messages = incomingTexts()\n        .take(10)\n        .toList()\n\n      messages.size shouldBe 10\n\n      // Stream binary messages\n      incomingBinaries()\n        .take(5)\n        .collect { bytes -&gt;\n          println(\"Received ${bytes.size} bytes\")\n        }\n\n      // Stream all message types\n      incoming()\n        .take(5)\n        .collect { message -&gt;\n          when (message) {\n            is StoveWebSocketMessage.Text -&gt; println(message.content)\n            is StoveWebSocketMessage.Binary -&gt; println(message.content.size)\n          }\n        }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#authentication-and-headers","title":"Authentication and Headers","text":"<p>Connect with authentication or custom headers:</p> <pre><code>stove {\n  http {\n    // With bearer token\n    webSocket(\n      uri = \"/secure-chat\",\n      token = \"jwt-token\".some()\n    ) {\n      val response = receiveText()\n      response shouldBe \"Authenticated successfully\"\n    }\n\n    // With custom headers\n    webSocket(\n      uri = \"/chat\",\n      headers = mapOf(\n        \"X-Custom-Header\" to \"value\",\n        \"Authorization\" to \"Bearer custom-token\"\n      )\n    ) {\n      send(\"Hello with custom headers\")\n      receiveText() shouldNotBe null\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#websocket-expect-assertion-alias","title":"WebSocket Expect (Assertion Alias)","text":"<p>Use <code>webSocketExpect</code> for assertion-focused tests:</p> <pre><code>stove {\n  http {\n    webSocketExpect(\"/notifications\") {\n      val messages = collectTexts(count = 3)\n      messages.size shouldBe 3\n      messages.all { it.startsWith(\"notification:\") } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#raw-websocket-access","title":"Raw WebSocket Access","text":"<p>For advanced scenarios, access the underlying Ktor WebSocket session:</p> <pre><code>stove {\n  http {\n    webSocketRaw(\"/advanced\") {\n      // Direct access to Ktor's DefaultClientWebSocketSession\n      send(Frame.Text(\"raw frame\"))\n\n      for (frame in incoming) {\n        when (frame) {\n          is Frame.Text -&gt; println(frame.readText())\n          is Frame.Binary -&gt; println(frame.readBytes().size)\n          is Frame.Close -&gt; break\n          else -&gt; {}\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#underlying-session-access","title":"Underlying Session Access","text":"<p>Access the underlying session from within <code>StoveWebSocketSession</code>:</p> <pre><code>stove {\n  http {\n    webSocket(\"/endpoint\") {\n      // Use simplified API first\n      send(\"Hello\")\n\n      // Then access underlying session for advanced operations\n      underlyingSession {\n        send(Frame.Text(\"Advanced operation\"))\n        val frame = incoming.receive()\n        (frame as Frame.Text).readText() shouldBe \"Response\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#closing-connections","title":"Closing Connections","text":"<p>Gracefully close WebSocket connections:</p> <pre><code>stove {\n  http {\n    webSocket(\"/chat\") {\n      send(\"Hello\")\n      receiveText()\n\n      // Close with custom reason\n      close(\"Test completed\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#complete-websocket-test-example","title":"Complete WebSocket Test Example","text":"<p>A comprehensive example testing a chat application:</p> <pre><code>test(\"should handle chat room operations\") {\n  stove {\n    http {\n      // Test echo functionality\n      webSocket(\"/chat/echo\") {\n        send(\"Hello, World!\")\n        receiveText() shouldBe \"Echo: Hello, World!\"\n\n        send(\"Another message\")\n        receiveText() shouldBe \"Echo: Another message\"\n      }\n\n      // Test broadcast with authentication\n      webSocket(\n        uri = \"/chat/room/123\",\n        token = \"user-jwt-token\".some()\n      ) {\n        // Verify join notification\n        val joinMessage = receiveText()\n        joinMessage shouldContain \"joined\"\n\n        // Send a message\n        send(\"Hi everyone!\")\n\n        // Collect broadcast responses\n        val messages = collectTexts(count = 2, timeout = 5.seconds)\n        messages.any { it.contains(\"Hi everyone!\") } shouldBe true\n      }\n\n      // Test binary data (e.g., file sharing)\n      webSocket(\"/chat/files\") {\n        val fileData = \"Hello\".toByteArray()\n        send(fileData)\n\n        val response = receiveBinary()\n        response shouldNotBe null\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#websocket-kafka-integration","title":"WebSocket + Kafka Integration","text":"<p>Test WebSocket events that trigger Kafka messages:</p> <pre><code>stove {\n  http {\n    webSocket(\"/events\") {\n      send(\"\"\"{\"type\": \"order\", \"action\": \"create\", \"amount\": 100.0}\"\"\")\n\n      val confirmation = receiveText()\n      confirmation shouldContain \"received\"\n    }\n  }\n\n  kafka {\n    shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n      actual.amount == 100.0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/","title":"PostgreSQL","text":"Gradle <pre><code>    dependencies {\n        testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n        testImplementation(\"com.trendyol:stove-postgres\")\n    }\n</code></pre>"},{"location":"Components/06-postgresql/#configure","title":"Configure","text":"<p>Once you've added the dependency, you can configure PostgreSQL in your Stove setup:</p> <pre><code>Stove()\n  .with {\n    postgresql {\n      PostgresqlOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"postgresql.host=${cfg.host}\",\n            \"postgresql.port=${cfg.port}\",\n            \"postgresql.database=${cfg.database}\",\n            \"postgresql.username=${cfg.username}\",\n            \"postgresql.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }.run()\n</code></pre> <p>The <code>it</code> reference gives you access to the PostgreSQL container's connection details, which you can pass to your application.</p>"},{"location":"Components/06-postgresql/#migrations","title":"Migrations","text":"<p>Stove provides a way to run database migrations before tests start:</p> <pre><code>class InitialMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: PostgresSqlMigrationContext) {\n    connection.operations.execute(\n      \"\"\"\n      CREATE TABLE IF NOT EXISTS users (\n        id serial PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        email VARCHAR(100) NOT NULL UNIQUE,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n      \"\"\".trimIndent()\n    )\n  }\n}\n</code></pre> <p>Register migrations in your Stove configuration:</p> <pre><code>Stove()\n  .with {\n    postgresql {\n      PostgresqlOptions(\n        databaseName = \"testing\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      ).migrations {\n        register&lt;InitialMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/06-postgresql/#usage","title":"Usage","text":""},{"location":"Components/06-postgresql/#executing-sql","title":"Executing SQL","text":"<p>Execute DDL and DML statements:</p> <pre><code>stove {\n  postgresql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      DROP TABLE IF EXISTS products;\n      CREATE TABLE IF NOT EXISTS products (\n        id serial PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        price DECIMAL(10, 2) NOT NULL,\n        stock INT DEFAULT 0\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert data\n    shouldExecute(\n      \"\"\"\n      INSERT INTO products (name, price, stock) \n      VALUES ('Laptop', 999.99, 10)\n      \"\"\".trimIndent()\n    )\n\n    // Update data\n    shouldExecute(\"UPDATE products SET stock = 5 WHERE name = 'Laptop'\")\n\n    // Delete data\n    shouldExecute(\"DELETE FROM products WHERE stock = 0\")\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#querying-data","title":"Querying Data","text":"<p>Query data with type-safe mappers:</p> <pre><code>data class Product(\n  val id: Long,\n  val name: String,\n  val price: Double,\n  val stock: Int\n)\n\nstove {\n  postgresql {\n    shouldQuery&lt;Product&gt;(\n      query = \"SELECT * FROM products WHERE price &gt; 500\",\n      mapper = { row -&gt;\n        Product(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          price = row.double(\"price\"),\n          stock = row.int(\"stock\")\n        )\n      }\n    ) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.price &gt; 500 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#query-with-parameters","title":"Query with Parameters","text":"<p>Use parameterized queries for safety:</p> <pre><code>stove {\n  postgresql {\n    val minPrice = 100.0\n    shouldQuery&lt;Product&gt;(\n      query = \"SELECT * FROM products WHERE price &gt;= ?\",\n      mapper = { row -&gt;\n        Product(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          price = row.double(\"price\"),\n          stock = row.int(\"stock\")\n        )\n      }\n    ) { products -&gt;\n      products.all { it.price &gt;= minPrice } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#working-with-nullable-fields","title":"Working with Nullable Fields","text":"<p>Handle nullable columns:</p> <pre><code>data class User(\n  val id: Long,\n  val name: String,\n  val email: String?,\n  val phone: String?\n)\n\nstove {\n  postgresql {\n    shouldQuery&lt;User&gt;(\n      query = \"SELECT * FROM users\",\n      mapper = { row -&gt;\n        User(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          email = row.stringOrNull(\"email\"),\n          phone = row.stringOrNull(\"phone\")\n        )\n      }\n    ) { users -&gt;\n      users.size shouldBeGreaterThan 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#complex-queries","title":"Complex Queries","text":"<p>Execute joins and aggregations:</p> <pre><code>data class OrderSummary(\n  val userId: Long,\n  val userName: String,\n  val totalOrders: Int,\n  val totalAmount: Double\n)\n\nstove {\n  postgresql {\n    shouldQuery&lt;OrderSummary&gt;(\n      query = \"\"\"\n        SELECT \n          u.id as user_id,\n          u.name as user_name,\n          COUNT(o.id) as total_orders,\n          SUM(o.amount) as total_amount\n        FROM users u\n        LEFT JOIN orders o ON u.id = o.user_id\n        GROUP BY u.id, u.name\n        HAVING COUNT(o.id) &gt; 0\n      \"\"\".trimIndent(),\n      mapper = { row -&gt;\n        OrderSummary(\n          userId = row.long(\"user_id\"),\n          userName = row.string(\"user_name\"),\n          totalOrders = row.int(\"total_orders\"),\n          totalAmount = row.double(\"total_amount\")\n        )\n      }\n    ) { summaries -&gt;\n      summaries.all { it.totalOrders &gt; 0 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Test failure scenarios:</p> <pre><code>stove {\n  postgresql {\n    // Database is running\n    shouldQuery&lt;Product&gt;(\n      \"SELECT COUNT(*) as count FROM products\",\n      mapper = { row -&gt; row.int(\"count\") }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n\n    // Pause the database\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the database\n    unpause()\n\n    // Verify recovery\n    shouldQuery&lt;Product&gt;(\n      \"SELECT COUNT(*) as count FROM products\",\n      mapper = { row -&gt; row.int(\"count\") }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test:</p> <pre><code>test(\"should create user via API and verify in database\") {\n  stove {\n    val userName = \"John Doe\"\n    val userEmail = \"john@example.com\"\n\n    // Create user via API\n    http {\n      postAndExpectBody&lt;UserResponse&gt;(\n        uri = \"/users\",\n        body = CreateUserRequest(name = userName, email = userEmail).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().name shouldBe userName\n      }\n    }\n\n    // Verify in PostgreSQL\n    postgresql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM users WHERE email = ?\",\n        mapper = { row -&gt;\n          User(\n            id = row.long(\"id\"),\n            name = row.string(\"name\"),\n            email = row.string(\"email\")\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().name shouldBe userName\n        users.first().email shouldBe userEmail\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;UserCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.name == userName &amp;&amp;\n        actual.email == userEmail\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#integration-with-application","title":"Integration with Application","text":"<p>Use the bridge to access application components:</p> <pre><code>test(\"should use repository to save user\") {\n  stove {\n    val user = User(id = 1L, name = \"Jane Doe\", email = \"jane@example.com\")\n\n    // Use application's repository\n    using&lt;UserRepository&gt; {\n      save(user)\n    }\n\n    // Verify in database\n    postgresql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM users WHERE id = ?\",\n        mapper = { row -&gt;\n          User(\n            id = row.long(\"id\"),\n            name = row.string(\"name\"),\n            email = row.string(\"email\")\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().name shouldBe \"Jane Doe\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#batch-operations","title":"Batch Operations","text":"<p>Execute multiple operations:</p> <pre><code>stove {\n  postgresql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE IF NOT EXISTS categories (\n        id serial PRIMARY KEY,\n        name VARCHAR(50) NOT NULL\n      );\n      CREATE TABLE IF NOT EXISTS products (\n        id serial PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        category_id INT REFERENCES categories(id)\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert categories\n    listOf(\"Electronics\", \"Books\", \"Clothing\").forEach { category -&gt;\n      shouldExecute(\"INSERT INTO categories (name) VALUES ('$category')\")\n    }\n\n    // Verify all inserted\n    shouldQuery&lt;String&gt;(\n      \"SELECT name FROM categories\",\n      mapper = { it.string(\"name\") }\n    ) { categories -&gt;\n      categories.size shouldBe 3\n      categories shouldContain \"Electronics\"\n      categories shouldContain \"Books\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#advanced-direct-sql-operations","title":"Advanced: Direct SQL Operations","text":"<p>Access SQL operations directly for advanced use cases:</p> <pre><code>stove {\n  postgresql {\n    val ops = operations()\n\n    // Execute with parameters\n    ops.execute(\n      \"INSERT INTO users (name, email) VALUES (?, ?)\",\n      Parameter(\"name\", \"Alice\"),\n      Parameter(\"email\", \"alice@example.com\")\n    )\n\n    // Custom select operation\n    val users = ops.select(\"SELECT * FROM users\") { row -&gt;\n      User(\n        id = row.long(\"id\"),\n        name = row.string(\"name\"),\n        email = row.string(\"email\")\n      )\n    }\n\n    users.size shouldBeGreaterThan 0\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#multiple-databases","title":"Multiple Databases","text":"<p>In production, your application might connect to multiple PostgreSQL instances (e.g., separate databases for users, orders, analytics). With Stove, you can achieve the same behavior using a single PostgreSQL container by creating multiple databases through migrations.</p>"},{"location":"Components/06-postgresql/#the-pattern","title":"The Pattern","text":"<ol> <li>Create additional databases in migrations</li> <li>Expose all database configurations to your application</li> <li>Your application connects to each database as if they were separate instances</li> </ol>"},{"location":"Components/06-postgresql/#implementation","title":"Implementation","text":""},{"location":"Components/06-postgresql/#step-1-create-a-multi-database-migration","title":"Step 1: Create a Multi-Database Migration","text":"<pre><code>class CreateDatabasesMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 0  // Run first!\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        // Create additional databases\n        // Note: You're connected to the default database, create others from here\n        connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS users_db\")\n        connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS orders_db\")\n        connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS analytics_db\")\n    }\n}\n\nclass UsersDbMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 1\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        // This runs on the default database\n        // For users_db schema, you'll set it up via application or separate connection\n        connection.operations.execute(\n            \"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(100),\n                email VARCHAR(100)\n            )\n            \"\"\".trimIndent()\n        )\n    }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#step-2-configure-stove-with-multiple-database-urls","title":"Step 2: Configure Stove with Multiple Database URLs","text":"<pre><code>Stove()\n    .with {\n        postgresql {\n            PostgresqlOptions(\n                databaseName = \"main_db\",  // Default/main database\n                configureExposedConfiguration = { cfg -&gt;\n                    // Expose multiple database URLs to the application\n                    // All databases are on the same host:port, just different DB names\n                    listOf(\n                        // Main database\n                        \"spring.datasource.url=${cfg.jdbcUrl}\",\n                        \"spring.datasource.username=${cfg.username}\",\n                        \"spring.datasource.password=${cfg.password}\",\n\n                        // Users database (same host, different database name)\n                        \"users.datasource.url=jdbc:postgresql://${cfg.host}:${cfg.port}/users_db\",\n                        \"users.datasource.username=${cfg.username}\",\n                        \"users.datasource.password=${cfg.password}\",\n\n                        // Orders database\n                        \"orders.datasource.url=jdbc:postgresql://${cfg.host}:${cfg.port}/orders_db\",\n                        \"orders.datasource.username=${cfg.username}\",\n                        \"orders.datasource.password=${cfg.password}\",\n\n                        // Analytics database\n                        \"analytics.datasource.url=jdbc:postgresql://${cfg.host}:${cfg.port}/analytics_db\",\n                        \"analytics.datasource.username=${cfg.username}\",\n                        \"analytics.datasource.password=${cfg.password}\"\n                    )\n                }\n            ).migrations {\n                register&lt;CreateDatabasesMigration&gt;()\n                register&lt;UsersDbMigration&gt;()\n            }\n        }\n    }\n    .run()\n</code></pre>"},{"location":"Components/06-postgresql/#step-3-application-configuration","title":"Step 3: Application Configuration","text":"<p>Your application should read these separate datasource configurations:</p> <pre><code>// Spring Boot example with multiple DataSources\n@Configuration\nclass DataSourceConfig {\n\n    @Bean\n    @Primary\n    @ConfigurationProperties(\"spring.datasource\")\n    fun mainDataSource(): DataSource = DataSourceBuilder.create().build()\n\n    @Bean\n    @ConfigurationProperties(\"users.datasource\")\n    fun usersDataSource(): DataSource = DataSourceBuilder.create().build()\n\n    @Bean\n    @ConfigurationProperties(\"orders.datasource\")\n    fun ordersDataSource(): DataSource = DataSourceBuilder.create().build()\n\n    @Bean\n    @ConfigurationProperties(\"analytics.datasource\")\n    fun analyticsDataSource(): DataSource = DataSourceBuilder.create().build()\n}\n</code></pre>"},{"location":"Components/06-postgresql/#complete-example_1","title":"Complete Example","text":"<pre><code>object DatabaseNames {\n    const val USERS = \"users_db\"\n    const val ORDERS = \"orders_db\"\n    const val ANALYTICS = \"analytics_db\"\n}\n\nclass SetupDatabasesMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 0\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        listOf(DatabaseNames.USERS, DatabaseNames.ORDERS, DatabaseNames.ANALYTICS).forEach { db -&gt;\n            connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS $db\")\n        }\n    }\n}\n\n// Test configuration\nStove()\n    .with {\n        postgresql {\n            PostgresqlOptions(\n                databaseName = \"main\",\n                configureExposedConfiguration = { cfg -&gt;\n                    val baseUrl = \"jdbc:postgresql://${cfg.host}:${cfg.port}\"\n                    listOf(\n                        \"db.users.url=$baseUrl/${DatabaseNames.USERS}\",\n                        \"db.users.username=${cfg.username}\",\n                        \"db.users.password=${cfg.password}\",\n\n                        \"db.orders.url=$baseUrl/${DatabaseNames.ORDERS}\",\n                        \"db.orders.username=${cfg.username}\",\n                        \"db.orders.password=${cfg.password}\",\n\n                        \"db.analytics.url=$baseUrl/${DatabaseNames.ANALYTICS}\",\n                        \"db.analytics.username=${cfg.username}\",\n                        \"db.analytics.password=${cfg.password}\"\n                    )\n                }\n            ).migrations {\n                register&lt;SetupDatabasesMigration&gt;()\n            }\n        }\n        springBoot(\n            runner = { params -&gt; myApp.run(params) }\n        )\n    }\n    .run()\n\n// In tests\ntest(\"should save user and create order in separate databases\") {\n    stove {\n        // Create user (goes to users_db)\n        http {\n            postAndExpectBodilessResponse(\"/users\", body = CreateUserRequest(...).some()) {\n                it.status shouldBe 201\n            }\n        }\n\n        // Create order (goes to orders_db)\n        http {\n            postAndExpectBodilessResponse(\"/orders\", body = CreateOrderRequest(...).some()) {\n                it.status shouldBe 201\n            }\n        }\n\n        // Verify using application repositories (each connects to its own DB)\n        using&lt;UserRepository, OrderRepository&gt; { userRepo, orderRepo -&gt;\n            userRepo.count() shouldBe 1\n            orderRepo.count() shouldBe 1\n        }\n    }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#with-provided-instances","title":"With Provided Instances","text":"<p>The same pattern works with provided PostgreSQL instances:</p> <pre><code>Stove()\n    .with {\n        postgresql {\n            PostgresqlOptions.provided(\n                jdbcUrl = \"jdbc:postgresql://shared-postgres:5432/main_db\",\n                host = \"shared-postgres\",\n                port = 5432,\n                databaseName = \"main_db\",\n                username = \"postgres\",\n                password = \"postgres\",\n                runMigrations = true,  // Creates additional databases\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"db.users.url=jdbc:postgresql://${cfg.host}:${cfg.port}/users_db\",\n                        \"db.orders.url=jdbc:postgresql://${cfg.host}:${cfg.port}/orders_db\",\n                        // ... credentials\n                    )\n                }\n            ).migrations {\n                register&lt;SetupDatabasesMigration&gt;()\n            }\n        }\n    }\n</code></pre> <p>Production vs Test</p> <p>In production, these might be completely separate PostgreSQL instances (even in different regions). In tests, they're all in one container but behave identically from your application's perspective.</p>"},{"location":"Components/07-mongodb/","title":"MongoDB","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-mongodb:$version\")\n    }\n</code></pre>"},{"location":"Components/07-mongodb/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>mongodb</code> function. This function configures the MongoDB Docker container that is going to be started.</p> <pre><code>Stove()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#container-options","title":"Container Options","text":"<p>Customize the MongoDB container:</p> <pre><code>Stove()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        container = MongoContainerOptions(\n          registry = \"docker.io\",\n          image = \"mongo\",\n          tag = \"6.0\",\n          containerFn = { container -&gt;\n            // Additional container configuration\n            container.withEnv(\"MONGO_INITDB_DATABASE\", \"testdb\")\n          }\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#database-options","title":"Database Options","text":"<p>Configure the default database and collection:</p> <pre><code>Stove()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        databaseOptions = DatabaseOptions(\n          default = DatabaseOptions.DefaultDatabase(\n            name = \"myDatabase\",\n            collection = \"myCollection\"\n          )\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#custom-client-configuration","title":"Custom Client Configuration","text":"<p>Customize the MongoDB client settings:</p> <pre><code>Stove()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        configureClient = { settings -&gt;\n          settings.applyToConnectionPoolSettings { pool -&gt;\n            pool.maxSize(10)\n            pool.minSize(1)\n          }\n          settings.applyToSocketSettings { socket -&gt;\n            socket.connectTimeout(10, TimeUnit.SECONDS)\n            socket.readTimeout(30, TimeUnit.SECONDS)\n          }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\"mongodb.uri=${cfg.connectionString}\")\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#custom-serialization","title":"Custom Serialization","text":"<p>Configure custom serialization for your documents:</p> <pre><code>Stove()\n  .with {\n    mongodb {\n      val customSerde = StoveSerde.jackson.anyJsonStringSerde(\n        StoveSerde.jackson.byConfiguring {\n          disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n          enable(MapperFeature.DEFAULT_VIEW_INCLUSION)\n          registerModule(JavaTimeModule())\n          registerModule(KotlinModule.Builder().build())\n        }\n      )\n\n      MongodbSystemOptions(\n        serde = customSerde,\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\"mongodb.uri=${cfg.connectionString}\")\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#migrations","title":"Migrations","text":"<p>Stove provides a way to run migrations before tests start:</p> <pre><code>class CreateIndexesMigration : DatabaseMigration&lt;MongodbMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: MongodbMigrationContext) {\n    val db = connection.client.getDatabase(connection.options.databaseOptions.default.name)\n\n    // Create indexes\n    db.getCollection&lt;Document&gt;(\"users\").createIndex(\n      Indexes.ascending(\"email\"),\n      IndexOptions().unique(true)\n    )\n\n    db.getCollection&lt;Document&gt;(\"products\").createIndex(\n      Indexes.compoundIndex(\n        Indexes.ascending(\"category\"),\n        Indexes.descending(\"createdAt\")\n      )\n    )\n  }\n}\n</code></pre> <p>Register migrations in your Stove configuration:</p> <pre><code>Stove()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\"mongodb.uri=${cfg.connectionString}\")\n        }\n      ).migrations {\n        register&lt;CreateIndexesMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#usage","title":"Usage","text":""},{"location":"Components/07-mongodb/#saving-documents","title":"Saving Documents","text":"<p>Save documents to MongoDB collections:</p> <pre><code>data class User(\n  val id: String,\n  val name: String,\n  val email: String,\n  val age: Int\n)\n\nstove {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // Save to default collection\n    save(\n      instance = User(id = userId, name = \"John Doe\", email = \"john@example.com\", age = 30),\n      objectId = userId\n    )\n\n    // Save to specific collection\n    save(\n      instance = User(id = userId, name = \"Jane Doe\", email = \"jane@example.com\", age = 28),\n      objectId = userId,\n      collection = \"users\"\n    )\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#getting-documents","title":"Getting Documents","text":"<p>Retrieve and validate documents by ObjectId:</p> <pre><code>stove {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // First save the document\n    save(\n      instance = User(id = userId, name = \"John Doe\", email = \"john@example.com\", age = 30),\n      objectId = userId,\n      collection = \"users\"\n    )\n\n    // Get from specific collection\n    shouldGet&lt;User&gt;(objectId = userId, collection = \"users\") { user -&gt;\n      user.id shouldBe userId\n      user.name shouldBe \"John Doe\"\n      user.email shouldBe \"john@example.com\"\n      user.age shouldBe 30\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#checking-non-existence","title":"Checking Non-Existence","text":"<p>Verify that documents don't exist:</p> <pre><code>stove {\n  mongodb {\n    val nonExistentId = ObjectId().toHexString()\n\n    // Check default collection\n    shouldNotExist(objectId = nonExistentId)\n\n    // Check specific collection\n    shouldNotExist(objectId = nonExistentId, collection = \"users\")\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#deleting-documents","title":"Deleting Documents","text":"<p>Delete documents and verify deletion:</p> <pre><code>stove {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // Save a document\n    save(\n      instance = User(id = userId, name = \"John Doe\", email = \"john@example.com\", age = 30),\n      objectId = userId,\n      collection = \"users\"\n    )\n\n    // Delete it\n    shouldDelete(objectId = userId, collection = \"users\")\n\n    // Verify deletion\n    shouldNotExist(objectId = userId, collection = \"users\")\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#querying-documents","title":"Querying Documents","text":"<p>Query documents using MongoDB query syntax:</p> <pre><code>stove {\n  mongodb {\n    // Setup test data\n    listOf(\n      User(id = ObjectId().toHexString(), name = \"Alice\", email = \"alice@example.com\", age = 25),\n      User(id = ObjectId().toHexString(), name = \"Bob\", email = \"bob@example.com\", age = 35),\n      User(id = ObjectId().toHexString(), name = \"Charlie\", email = \"charlie@example.com\", age = 28)\n    ).forEach { user -&gt;\n      save(instance = user, objectId = ObjectId().toHexString(), collection = \"users\")\n    }\n\n    // Simple query\n    shouldQuery&lt;User&gt;(\n      query = \"\"\"{ \"age\": { \"${'$'}gte\": 30 } }\"\"\",\n      collection = \"users\"\n    ) { users -&gt;\n      users.size shouldBe 1\n      users.first().name shouldBe \"Bob\"\n    }\n\n    // Query with multiple conditions\n    shouldQuery&lt;User&gt;(\n      query = \"\"\"\n        {\n          \"${'$'}and\": [\n            { \"age\": { \"${'$'}gte\": 25 } },\n            { \"age\": { \"${'$'}lte\": 30 } }\n          ]\n        }\n      \"\"\".trimIndent(),\n      collection = \"users\"\n    ) { users -&gt;\n      users.size shouldBe 2\n      users.map { it.name } shouldContainAll listOf(\"Alice\", \"Charlie\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#accessing-the-client-directly","title":"Accessing the Client Directly","text":"<p>For advanced operations, access the MongoDB client:</p> <pre><code>stove {\n  mongodb {\n    val mongoClient = client()\n\n    // Access the database\n    val db = mongoClient.getDatabase(\"myDatabase\")\n\n    // List collections\n    val collections = db.listCollectionNames().toList()\n\n    // Perform custom operations\n    db.getCollection&lt;Document&gt;(\"users\")\n      .find()\n      .limit(10)\n      .toList()\n      .also { documents -&gt;\n        documents.size shouldBeLessThanOrEqual 10\n      }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Control the MongoDB container for testing failure scenarios:</p> <pre><code>stove {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // MongoDB is running\n    save(\n      instance = User(id = userId, name = \"John\", email = \"john@example.com\", age = 30),\n      objectId = userId,\n      collection = \"users\"\n    )\n\n    // Pause the container\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the container\n    unpause()\n\n    // Verify recovery\n    shouldGet&lt;User&gt;(objectId = userId, collection = \"users\") { user -&gt;\n      user.name shouldBe \"John\"\n    }\n  }\n}\n</code></pre> <p>Warning</p> <p><code>pause()</code>, <code>unpause()</code>, and <code>inspect()</code> operations are not supported when using a provided instance.</p>"},{"location":"Components/07-mongodb/#container-inspection","title":"Container Inspection","text":"<p>Inspect the MongoDB container:</p> <pre><code>stove {\n  mongodb {\n    val info = inspect()\n    info?.let {\n      println(\"Container ID: ${it.containerId}\")\n      println(\"Network: ${it.network}\")\n      println(\"IP Address: ${it.ipAddress}\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, MongoDB, and Kafka:</p> <pre><code>data class Product(\n  val id: String,\n  val name: String,\n  val description: String,\n  val price: Double,\n  val categoryId: Int,\n  val stock: Int,\n  val createdAt: Instant = Instant.now()\n)\n\ntest(\"should create product and store in mongodb\") {\n  stove {\n    val productId = ObjectId().toHexString()\n    val productName = \"Gaming Laptop\"\n    val categoryId = 1\n\n    // Mock external service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Create product via API\n    http {\n      postAndExpectBody&lt;ProductResponse&gt;(\n        uri = \"/products\",\n        body = ProductCreateRequest(\n          name = productName,\n          description = \"High-performance gaming laptop\",\n          price = 1299.99,\n          categoryId = categoryId,\n          stock = 10\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().id shouldNotBe null\n      }\n    }\n\n    // Verify stored in MongoDB\n    mongodb {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"{ \"name\": \"$productName\" }\"\"\",\n        collection = \"products\"\n      ) { products -&gt;\n        products.size shouldBe 1\n        products.first().also { product -&gt;\n          product.name shouldBe productName\n          product.price shouldBe 1299.99\n          product.categoryId shouldBe categoryId\n          product.stock shouldBe 10\n        }\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.name == productName &amp;&amp;\n        actual.price == 1299.99\n      }\n    }\n\n    // Update product stock via API\n    http {\n      putAndExpectBodilessResponse(\n        uri = \"/products/$productId/stock\",\n        body = UpdateStockRequest(quantity = -2).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify stock updated in MongoDB\n    mongodb {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"{ \"name\": \"$productName\" }\"\"\",\n        collection = \"products\"\n      ) { products -&gt;\n        products.first().stock shouldBe 8\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#integration-with-application","title":"Integration with Application","text":"<p>Verify application behavior using the bridge:</p> <pre><code>test(\"should use repository to save product\") {\n  stove {\n    val productId = ObjectId().toHexString()\n    val product = Product(\n      id = productId,\n      name = \"Test Product\",\n      description = \"Test Description\",\n      price = 99.99,\n      categoryId = 1,\n      stock = 5\n    )\n\n    // Use application's repository\n    using&lt;ProductRepository&gt; {\n      save(product)\n    }\n\n    // Verify in MongoDB\n    mongodb {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"{ \"name\": \"Test Product\" }\"\"\",\n        collection = \"products\"\n      ) { products -&gt;\n        products.size shouldBe 1\n        products.first().id shouldBe productId\n        products.first().price shouldBe 99.99\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#advanced-operations","title":"Advanced Operations","text":""},{"location":"Components/07-mongodb/#aggregation-queries","title":"Aggregation Queries","text":"<pre><code>stove {\n  mongodb {\n    val mongoClient = client()\n    val db = mongoClient.getDatabase(\"myDatabase\")\n\n    // Aggregation pipeline\n    val pipeline = listOf(\n      Aggregates.match(Filters.gte(\"price\", 100)),\n      Aggregates.group(\"${'$'}categoryId\", \n        Accumulators.sum(\"totalProducts\", 1),\n        Accumulators.avg(\"avgPrice\", \"${'$'}price\")\n      ),\n      Aggregates.sort(Sorts.descending(\"totalProducts\"))\n    )\n\n    db.getCollection&lt;Document&gt;(\"products\")\n      .aggregate(pipeline)\n      .toList()\n      .also { results -&gt;\n        results.size shouldBeGreaterThan 0\n        // Each result has categoryId, totalProducts, and avgPrice\n      }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#bulk-operations","title":"Bulk Operations","text":"<pre><code>stove {\n  mongodb {\n    val mongoClient = client()\n    val db = mongoClient.getDatabase(\"myDatabase\")\n    val collection = db.getCollection&lt;Document&gt;(\"users\")\n\n    // Bulk insert\n    val users = (1..100).map { i -&gt;\n      Document()\n        .append(\"_id\", ObjectId())\n        .append(\"name\", \"User $i\")\n        .append(\"email\", \"user$i@example.com\")\n        .append(\"age\", 20 + (i % 50))\n    }\n\n    collection.insertMany(users)\n\n    // Bulk update\n    collection.updateMany(\n      Filters.gte(\"age\", 40),\n      Updates.set(\"status\", \"senior\")\n    )\n\n    // Verify\n    val seniorCount = collection.countDocuments(Filters.eq(\"status\", \"senior\"))\n    seniorCount shouldBeGreaterThan 0\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#transaction-support","title":"Transaction Support","text":"<pre><code>stove {\n  mongodb {\n    val mongoClient = client()\n\n    mongoClient.startSession().use { session -&gt;\n      session.startTransaction()\n      try {\n        val db = mongoClient.getDatabase(\"myDatabase\")\n\n        // Perform operations in transaction\n        db.getCollection&lt;Document&gt;(\"accounts\")\n          .updateOne(\n            session,\n            Filters.eq(\"accountId\", \"sender\"),\n            Updates.inc(\"balance\", -100.0)\n          )\n\n        db.getCollection&lt;Document&gt;(\"accounts\")\n          .updateOne(\n            session,\n            Filters.eq(\"accountId\", \"receiver\"),\n            Updates.inc(\"balance\", 100.0)\n          )\n\n        session.commitTransaction()\n      } catch (e: Exception) {\n        session.abortTransaction()\n        throw e\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#working-with-indexes","title":"Working with Indexes","text":"<pre><code>stove {\n  mongodb {\n    val mongoClient = client()\n    val db = mongoClient.getDatabase(\"myDatabase\")\n    val collection = db.getCollection&lt;Document&gt;(\"users\")\n\n    // Create unique index\n    collection.createIndex(\n      Indexes.ascending(\"email\"),\n      IndexOptions().unique(true)\n    )\n\n    // Create compound index\n    collection.createIndex(\n      Indexes.compoundIndex(\n        Indexes.ascending(\"status\"),\n        Indexes.descending(\"createdAt\")\n      )\n    )\n\n    // Create text index for search\n    collection.createIndex(\n      Indexes.text(\"name\")\n    )\n\n    // List indexes\n    collection.listIndexes().toList().also { indexes -&gt;\n      indexes.size shouldBeGreaterThan 1\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#provided-instance-external-mongodb","title":"Provided Instance (External MongoDB)","text":"<p>For CI/CD pipelines or shared infrastructure:</p> <pre><code>Stove()\n  .with {\n    mongodb {\n      MongodbSystemOptions.provided(\n        connectionString = System.getenv(\"MONGODB_URI\") ?: \"mongodb://localhost:27017\",\n        host = System.getenv(\"MONGODB_HOST\") ?: \"localhost\",\n        port = System.getenv(\"MONGODB_PORT\")?.toInt() ?: 27017,\n        cleanup = { client -&gt;\n          // Clean up test data after tests\n          client.getDatabase(\"testdb\").drop()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#error-handling","title":"Error Handling","text":"<pre><code>stove {\n  mongodb {\n    // Document not found\n    val nonExistentId = ObjectId().toHexString()\n    shouldNotExist(objectId = nonExistentId, collection = \"users\")\n\n    // Attempting to get non-existent document throws exception\n    assertThrows&lt;NoSuchElementException&gt; {\n      shouldGet&lt;User&gt;(objectId = nonExistentId, collection = \"users\") { }\n    }\n\n    // Verify existence check on existing document\n    val existingId = ObjectId().toHexString()\n    save(\n      instance = User(id = existingId, name = \"Existing\", email = \"existing@example.com\", age = 25),\n      objectId = existingId,\n      collection = \"users\"\n    )\n\n    assertThrows&lt;AssertionError&gt; {\n      shouldNotExist(objectId = existingId, collection = \"users\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#working-with-objectid","title":"Working with ObjectId","text":"<p>MongoDB uses <code>ObjectId</code> as the default identifier. Stove handles this transparently:</p> <pre><code>data class UserWithStringId(\n  val id: String, // String representation of ObjectId\n  val name: String,\n  val email: String\n)\n\nstove {\n  mongodb {\n    // Generate ObjectId\n    val objectId = ObjectId()\n    val stringId = objectId.toHexString()\n\n    // Save with string ID\n    save(\n      instance = UserWithStringId(id = stringId, name = \"Test\", email = \"test@example.com\"),\n      objectId = stringId,\n      collection = \"users\"\n    )\n\n    // Retrieve using string ID\n    shouldGet&lt;UserWithStringId&gt;(objectId = stringId, collection = \"users\") { user -&gt;\n      user.id shouldBe stringId\n      user.name shouldBe \"Test\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/","title":"Microsoft SQL Server (MSSQL)","text":"Gradle <pre><code>    dependencies {\n        testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n        testImplementation(\"com.trendyol:stove-mssql\")\n    }\n</code></pre>"},{"location":"Components/08-mssql/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>mssql</code> function. This function configures the MSSQL Docker container that is going to be started.</p> <pre><code>Stove()\n  .with {\n    mssql {\n      MsSqlOptions(\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#container-options","title":"Container Options","text":"<p>Customize the MSSQL container:</p> <pre><code>Stove()\n  .with {\n    mssql {\n      MsSqlOptions(\n        container = MsSqlContainerOptions(\n          registry = \"mcr.microsoft.com/\",\n          image = \"mssql/server\",\n          tag = \"2019-latest\",\n          containerFn = { container -&gt;\n            container.withEnv(\"ACCEPT_EULA\", \"Y\")\n          }\n        ),\n        applicationName = \"stove-tests\",\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#migrations","title":"Migrations","text":"<p>Stove provides a way to run database migrations before tests start:</p> <pre><code>class InitialMigration : DatabaseMigration&lt;MsSqlMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: MsSqlMigrationContext) {\n    connection.operations.execute(\n      \"\"\"\n      CREATE TABLE Person (\n        PersonID INT PRIMARY KEY IDENTITY(1,1),\n        LastName VARCHAR(255) NOT NULL,\n        FirstName VARCHAR(255) NOT NULL,\n        Address VARCHAR(255),\n        City VARCHAR(255)\n      );\n      \"\"\".trimIndent()\n    )\n  }\n}\n\nclass CreateOrdersTableMigration : DatabaseMigration&lt;MsSqlMigrationContext&gt; {\n  override val order: Int = 2\n\n  override suspend fun execute(connection: MsSqlMigrationContext) {\n    connection.operations.execute(\n      \"\"\"\n      CREATE TABLE Orders (\n        OrderID INT PRIMARY KEY IDENTITY(1,1),\n        PersonID INT NOT NULL,\n        OrderDate DATETIME DEFAULT GETDATE(),\n        Amount DECIMAL(10, 2),\n        FOREIGN KEY (PersonID) REFERENCES Person(PersonID)\n      );\n      \"\"\".trimIndent()\n    )\n  }\n}\n</code></pre> <p>Register migrations in your Stove configuration:</p> <pre><code>Stove()\n  .with {\n    mssql {\n      MsSqlOptions(\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      ).migrations {\n        register&lt;InitialMigration&gt;()\n        register&lt;CreateOrdersTableMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#usage","title":"Usage","text":""},{"location":"Components/08-mssql/#executing-sql","title":"Executing SQL","text":"<p>Execute DDL and DML statements:</p> <pre><code>stove {\n  mssql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE Products (\n        ProductID INT PRIMARY KEY IDENTITY(1,1),\n        ProductName NVARCHAR(100) NOT NULL,\n        Price DECIMAL(10, 2) NOT NULL,\n        Stock INT DEFAULT 0,\n        CreatedAt DATETIME DEFAULT GETDATE()\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert data\n    shouldExecute(\n      \"\"\"\n      INSERT INTO Products (ProductName, Price, Stock) \n      VALUES ('Laptop', 999.99, 10)\n      \"\"\".trimIndent()\n    )\n\n    // Update data\n    shouldExecute(\"UPDATE Products SET Stock = 5 WHERE ProductName = 'Laptop'\")\n\n    // Delete data\n    shouldExecute(\"DELETE FROM Products WHERE Stock = 0\")\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#querying-data","title":"Querying Data","text":"<p>Query data with type-safe mappers:</p> <pre><code>data class Person(\n  val personId: Int,\n  val lastName: String,\n  val firstName: String,\n  val address: String?,\n  val city: String?\n)\n\nstove {\n  mssql {\n    // Insert test data\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, Address, City) VALUES ('Doe', 'John', '123 Main St', 'Springfield')\")\n\n    // Query with mapper\n    shouldQuery&lt;Person&gt;(\n      query = \"SELECT * FROM Person\",\n      mapper = { resultSet -&gt;\n        Person(\n          personId = resultSet.getInt(1),\n          lastName = resultSet.getString(2),\n          firstName = resultSet.getString(3),\n          address = resultSet.getString(4),\n          city = resultSet.getString(5)\n        )\n      }\n    ) { result -&gt;\n      result.size shouldBe 1\n      result.first().apply {\n        personId shouldBe 1\n        lastName shouldBe \"Doe\"\n        firstName shouldBe \"John\"\n        address shouldBe \"123 Main St\"\n        city shouldBe \"Springfield\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#using-operations-directly","title":"Using Operations Directly","text":"<p>Access SQL operations directly for advanced use cases:</p> <pre><code>stove {\n  mssql {\n    ops {\n      // Simple select\n      val result = select(\"SELECT 1 AS value\") {\n        it.getInt(1)\n      }\n      result.first() shouldBe 1\n\n      // Execute insert\n      execute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Smith', 'Jane')\")\n\n      // Select with parameters\n      val users = select(\"SELECT * FROM Person WHERE LastName = 'Smith'\") { rs -&gt;\n        Person(\n          personId = rs.getInt(\"PersonID\"),\n          lastName = rs.getString(\"LastName\"),\n          firstName = rs.getString(\"FirstName\"),\n          address = rs.getString(\"Address\"),\n          city = rs.getString(\"City\")\n        )\n      }\n      users.size shouldBeGreaterThan 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#complex-queries","title":"Complex Queries","text":"<p>Execute joins, aggregations, and complex queries:</p> <pre><code>data class OrderSummary(\n  val personId: Int,\n  val personName: String,\n  val totalOrders: Int,\n  val totalAmount: Double\n)\n\nstove {\n  mssql {\n    // Setup test data\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, Address, City) VALUES ('Doe', 'John', '123 Main St', 'NYC')\")\n    shouldExecute(\"INSERT INTO Orders (PersonID, Amount) VALUES (1, 100.00)\")\n    shouldExecute(\"INSERT INTO Orders (PersonID, Amount) VALUES (1, 250.50)\")\n    shouldExecute(\"INSERT INTO Orders (PersonID, Amount) VALUES (1, 75.25)\")\n\n    // Aggregate query\n    shouldQuery&lt;OrderSummary&gt;(\n      query = \"\"\"\n        SELECT \n          p.PersonID,\n          CONCAT(p.FirstName, ' ', p.LastName) AS PersonName,\n          COUNT(o.OrderID) AS TotalOrders,\n          SUM(o.Amount) AS TotalAmount\n        FROM Person p\n        INNER JOIN Orders o ON p.PersonID = o.PersonID\n        GROUP BY p.PersonID, p.FirstName, p.LastName\n        HAVING COUNT(o.OrderID) &gt; 0\n      \"\"\".trimIndent(),\n      mapper = { rs -&gt;\n        OrderSummary(\n          personId = rs.getInt(\"PersonID\"),\n          personName = rs.getString(\"PersonName\"),\n          totalOrders = rs.getInt(\"TotalOrders\"),\n          totalAmount = rs.getDouble(\"TotalAmount\")\n        )\n      }\n    ) { summaries -&gt;\n      summaries.size shouldBe 1\n      summaries.first().apply {\n        personName shouldBe \"John Doe\"\n        totalOrders shouldBe 3\n        totalAmount shouldBe 425.75\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#working-with-nullable-fields","title":"Working with Nullable Fields","text":"<p>Handle nullable columns properly:</p> <pre><code>data class PersonWithNullable(\n  val personId: Int,\n  val firstName: String,\n  val lastName: String,\n  val address: String?,\n  val city: String?,\n  val email: String?\n)\n\nstove {\n  mssql {\n    // Insert with null values\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Solo', 'Han')\")\n\n    shouldQuery&lt;PersonWithNullable&gt;(\n      query = \"SELECT * FROM Person WHERE LastName = 'Solo'\",\n      mapper = { rs -&gt;\n        PersonWithNullable(\n          personId = rs.getInt(\"PersonID\"),\n          firstName = rs.getString(\"FirstName\"),\n          lastName = rs.getString(\"LastName\"),\n          address = rs.getString(\"Address\"), // Can be null\n          city = rs.getString(\"City\"), // Can be null\n          email = rs.getString(\"Email\") // Can be null\n        )\n      }\n    ) { persons -&gt;\n      persons.first().apply {\n        firstName shouldBe \"Han\"\n        lastName shouldBe \"Solo\"\n        address shouldBe null\n        city shouldBe null\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Test failure scenarios:</p> <pre><code>stove {\n  mssql {\n    // Database is running\n    shouldQuery&lt;Int&gt;(\n      \"SELECT COUNT(*) FROM Person\",\n      mapper = { rs -&gt; rs.getInt(1) }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n\n    // Pause the database\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the database\n    unpause()\n\n    // Verify recovery\n    shouldQuery&lt;Int&gt;(\n      \"SELECT COUNT(*) FROM Person\",\n      mapper = { rs -&gt; rs.getInt(1) }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test:</p> <pre><code>data class User(\n  val id: Int,\n  val username: String,\n  val email: String,\n  val createdAt: LocalDateTime\n)\n\ntest(\"should create user via API and verify in database\") {\n  stove {\n    val username = \"johndoe\"\n    val email = \"john@example.com\"\n\n    // Create user via API\n    http {\n      postAndExpectBody&lt;UserResponse&gt;(\n        uri = \"/users\",\n        body = CreateUserRequest(username = username, email = email).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().username shouldBe username\n      }\n    }\n\n    // Verify in MSSQL\n    mssql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM Users WHERE Email = '$email'\",\n        mapper = { rs -&gt;\n          User(\n            id = rs.getInt(\"UserID\"),\n            username = rs.getString(\"Username\"),\n            email = rs.getString(\"Email\"),\n            createdAt = rs.getTimestamp(\"CreatedAt\").toLocalDateTime()\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().apply {\n          username shouldBe \"johndoe\"\n          email shouldBe \"john@example.com\"\n        }\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;UserCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.username == username &amp;&amp;\n        actual.email == email\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#integration-with-application","title":"Integration with Application","text":"<p>Use the bridge to access application components:</p> <pre><code>test(\"should use repository to save user\") {\n  stove {\n    val user = User(id = 0, username = \"janedoe\", email = \"jane@example.com\", createdAt = LocalDateTime.now())\n\n    // Use application's repository\n    using&lt;UserRepository&gt; {\n      save(user)\n    }\n\n    // Verify in database\n    mssql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM Users WHERE Username = 'janedoe'\",\n        mapper = { rs -&gt;\n          User(\n            id = rs.getInt(\"UserID\"),\n            username = rs.getString(\"Username\"),\n            email = rs.getString(\"Email\"),\n            createdAt = rs.getTimestamp(\"CreatedAt\").toLocalDateTime()\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().email shouldBe \"jane@example.com\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#batch-operations","title":"Batch Operations","text":"<p>Execute multiple operations:</p> <pre><code>stove {\n  mssql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE Categories (\n        CategoryID INT PRIMARY KEY IDENTITY(1,1),\n        CategoryName NVARCHAR(50) NOT NULL\n      );\n      CREATE TABLE Products (\n        ProductID INT PRIMARY KEY IDENTITY(1,1),\n        ProductName NVARCHAR(100) NOT NULL,\n        CategoryID INT REFERENCES Categories(CategoryID)\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert categories\n    listOf(\"Electronics\", \"Books\", \"Clothing\").forEach { category -&gt;\n      shouldExecute(\"INSERT INTO Categories (CategoryName) VALUES ('$category')\")\n    }\n\n    // Verify all inserted\n    shouldQuery&lt;String&gt;(\n      \"SELECT CategoryName FROM Categories\",\n      mapper = { it.getString(\"CategoryName\") }\n    ) { categories -&gt;\n      categories.size shouldBe 3\n      categories shouldContainAll listOf(\"Electronics\", \"Books\", \"Clothing\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#stored-procedures","title":"Stored Procedures","text":"<p>Test stored procedures:</p> <pre><code>stove {\n  mssql {\n    // Create stored procedure\n    shouldExecute(\n      \"\"\"\n      CREATE PROCEDURE GetPersonsByCity\n        @City NVARCHAR(100)\n      AS\n      BEGIN\n        SELECT * FROM Person WHERE City = @City\n      END\n      \"\"\".trimIndent()\n    )\n\n    // Insert test data\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, City) VALUES ('Doe', 'John', 'NYC')\")\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, City) VALUES ('Smith', 'Jane', 'NYC')\")\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, City) VALUES ('Brown', 'Bob', 'LA')\")\n\n    // Execute stored procedure\n    shouldQuery&lt;Person&gt;(\n      query = \"EXEC GetPersonsByCity @City = 'NYC'\",\n      mapper = { rs -&gt;\n        Person(\n          personId = rs.getInt(\"PersonID\"),\n          lastName = rs.getString(\"LastName\"),\n          firstName = rs.getString(\"FirstName\"),\n          address = rs.getString(\"Address\"),\n          city = rs.getString(\"City\")\n        )\n      }\n    ) { persons -&gt;\n      persons.size shouldBe 2\n      persons.all { it.city == \"NYC\" } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#transactions","title":"Transactions","text":"<p>Test transaction behavior:</p> <pre><code>stove {\n  mssql {\n    ops {\n      // Start transaction manually via SQL\n      execute(\"BEGIN TRANSACTION\")\n\n      try {\n        execute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Test', 'User1')\")\n        execute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Test', 'User2')\")\n\n        // Commit transaction\n        execute(\"COMMIT TRANSACTION\")\n      } catch (e: Exception) {\n        execute(\"ROLLBACK TRANSACTION\")\n        throw e\n      }\n\n      // Verify\n      val count = select(\"SELECT COUNT(*) FROM Person WHERE LastName = 'Test'\") { it.getInt(1) }\n      count.first() shouldBe 2\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#provided-instance-external-mssql","title":"Provided Instance (External MSSQL)","text":"<p>For CI/CD pipelines or shared infrastructure:</p> <pre><code>Stove()\n  .with {\n    mssql {\n      MsSqlOptions.provided(\n        jdbcUrl = System.getenv(\"MSSQL_JDBC_URL\") ?: \"jdbc:sqlserver://localhost:1433;databaseName=testdb\",\n        host = System.getenv(\"MSSQL_HOST\") ?: \"localhost\",\n        port = System.getenv(\"MSSQL_PORT\")?.toInt() ?: 1433,\n        databaseName = \"testdb\",\n        username = System.getenv(\"MSSQL_USERNAME\") ?: \"sa\",\n        password = System.getenv(\"MSSQL_PASSWORD\") ?: \"YourStrong@Passw0rd\",\n        runMigrations = true,\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM Orders\")\n          operations.execute(\"DELETE FROM Person\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#data-types","title":"Data Types","text":"<p>Working with various SQL Server data types:</p> <pre><code>data class DataTypesExample(\n  val id: Int,\n  val intValue: Int,\n  val bigIntValue: Long,\n  val decimalValue: BigDecimal,\n  val floatValue: Double,\n  val bitValue: Boolean,\n  val dateValue: LocalDate,\n  val timeValue: LocalTime,\n  val dateTimeValue: LocalDateTime,\n  val nvarcharValue: String,\n  val varcharValue: String\n)\n\nstove {\n  mssql {\n    // Create table with various types\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE DataTypes (\n        ID INT PRIMARY KEY IDENTITY(1,1),\n        IntValue INT,\n        BigIntValue BIGINT,\n        DecimalValue DECIMAL(18, 4),\n        FloatValue FLOAT,\n        BitValue BIT,\n        DateValue DATE,\n        TimeValue TIME,\n        DateTimeValue DATETIME2,\n        NVarcharValue NVARCHAR(100),\n        VarcharValue VARCHAR(100)\n      )\n      \"\"\".trimIndent()\n    )\n\n    // Insert test data\n    shouldExecute(\n      \"\"\"\n      INSERT INTO DataTypes \n        (IntValue, BigIntValue, DecimalValue, FloatValue, BitValue, DateValue, TimeValue, DateTimeValue, NVarcharValue, VarcharValue)\n      VALUES \n        (42, 9223372036854775807, 1234.5678, 3.14159, 1, '2024-01-15', '14:30:00', '2024-01-15 14:30:00', N'Unicode: \u65e5\u672c\u8a9e', 'ASCII text')\n      \"\"\".trimIndent()\n    )\n\n    // Query and verify\n    shouldQuery&lt;DataTypesExample&gt;(\n      query = \"SELECT * FROM DataTypes\",\n      mapper = { rs -&gt;\n        DataTypesExample(\n          id = rs.getInt(\"ID\"),\n          intValue = rs.getInt(\"IntValue\"),\n          bigIntValue = rs.getLong(\"BigIntValue\"),\n          decimalValue = rs.getBigDecimal(\"DecimalValue\"),\n          floatValue = rs.getDouble(\"FloatValue\"),\n          bitValue = rs.getBoolean(\"BitValue\"),\n          dateValue = rs.getDate(\"DateValue\").toLocalDate(),\n          timeValue = rs.getTime(\"TimeValue\").toLocalTime(),\n          dateTimeValue = rs.getTimestamp(\"DateTimeValue\").toLocalDateTime(),\n          nvarcharValue = rs.getString(\"NVarcharValue\"),\n          varcharValue = rs.getString(\"VarcharValue\")\n        )\n      }\n    ) { results -&gt;\n      results.first().apply {\n        intValue shouldBe 42\n        bitValue shouldBe true\n        nvarcharValue shouldContain \"\u65e5\u672c\u8a9e\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/","title":"Redis","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-redis:$version\")\n    }\n</code></pre>"},{"location":"Components/09-redis/#configure","title":"Configure","text":"<pre><code>Stove()\n  .with {\n    redis {\n      RedisOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"redis.host=${cfg.host}\",\n            \"redis.port=${cfg.port}\",\n            \"redis.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }.run()\n</code></pre>"},{"location":"Components/09-redis/#migrations","title":"Migrations","text":"<p>Redis supports migrations for setting up initial data or configuration:</p> <pre><code>class SeedCacheData : DatabaseMigration&lt;RedisMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: RedisMigrationContext) {\n    connection.connection.sync().apply {\n      // Seed initial cache data\n      set(\"config:feature-flag\", \"enabled\")\n      hset(\"defaults:settings\", mapOf(\n        \"timeout\" to \"30\",\n        \"retries\" to \"3\"\n      ))\n    }\n  }\n}\n\n// Register migrations\nredis {\n  RedisOptions(\n    configureExposedConfiguration = { cfg -&gt; listOf(...) }\n  ).migrations {\n    register&lt;SeedCacheData&gt;()\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#usage","title":"Usage","text":"<p>The Redis component provides access to the underlying Lettuce Redis client, allowing you to test all Redis operations.</p>"},{"location":"Components/09-redis/#accessing-the-redis-client","title":"Accessing the Redis Client","text":"<p>Access the Redis client using the <code>client()</code> extension function:</p> <pre><code>stove {\n  redis {\n    val redisClient = client()\n    val connection = redisClient.connect()\n    // Use the connection for Redis operations\n    connection.close()\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#string-operations","title":"String Operations","text":"<p>Test basic string operations:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    // SET and GET\n    connection.set(\"user:123:name\", \"John Doe\")\n    val name = connection.get(\"user:123:name\")\n    name shouldBe \"John Doe\"\n\n    // SET with expiration\n    connection.setex(\"session:abc\", 3600, \"session-data\")\n    val ttl = connection.ttl(\"session:abc\")\n    ttl shouldBeGreaterThan 0\n\n    // INCREMENT\n    connection.set(\"counter\", \"0\")\n    connection.incr(\"counter\")\n    connection.incr(\"counter\")\n    val counter = connection.get(\"counter\")\n    counter shouldBe \"2\"\n\n    // Multiple keys\n    connection.mset(mapOf(\n      \"key1\" to \"value1\",\n      \"key2\" to \"value2\",\n      \"key3\" to \"value3\"\n    ))\n    val values = connection.mget(\"key1\", \"key2\", \"key3\")\n    values.size shouldBe 3\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#hash-operations","title":"Hash Operations","text":"<p>Test Redis hash operations:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    // HSET and HGET\n    connection.hset(\"user:123\", \"name\", \"John Doe\")\n    connection.hset(\"user:123\", \"email\", \"john@example.com\")\n    connection.hset(\"user:123\", \"age\", \"30\")\n\n    val name = connection.hget(\"user:123\", \"name\")\n    name shouldBe \"John Doe\"\n\n    // HGETALL\n    val user = connection.hgetall(\"user:123\")\n    user[\"name\"] shouldBe \"John Doe\"\n    user[\"email\"] shouldBe \"john@example.com\"\n    user[\"age\"] shouldBe \"30\"\n\n    // HMSET\n    connection.hmset(\"product:456\", mapOf(\n      \"name\" to \"Laptop\",\n      \"price\" to \"999.99\",\n      \"stock\" to \"10\"\n    ))\n\n    // HINCRBY\n    connection.hincrby(\"product:456\", \"stock\", -1)\n    val stock = connection.hget(\"product:456\", \"stock\")\n    stock shouldBe \"9\"\n\n    // HDEL\n    connection.hdel(\"user:123\", \"age\")\n    val age = connection.hget(\"user:123\", \"age\")\n    age shouldBe null\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#list-operations","title":"List Operations","text":"<p>Test Redis list operations:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    // LPUSH and RPUSH\n    connection.rpush(\"queue:tasks\", \"task1\", \"task2\", \"task3\")\n    connection.lpush(\"queue:tasks\", \"urgent-task\")\n\n    // LRANGE\n    val tasks = connection.lrange(\"queue:tasks\", 0, -1)\n    tasks.size shouldBe 4\n    tasks.first() shouldBe \"urgent-task\"\n\n    // LPOP and RPOP\n    val firstTask = connection.lpop(\"queue:tasks\")\n    firstTask shouldBe \"urgent-task\"\n\n    val lastTask = connection.rpop(\"queue:tasks\")\n    lastTask shouldBe \"task3\"\n\n    // LLEN\n    val length = connection.llen(\"queue:tasks\")\n    length shouldBe 2\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#set-operations","title":"Set Operations","text":"<p>Test Redis set operations:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    // SADD\n    connection.sadd(\"tags:123\", \"kotlin\", \"testing\", \"redis\")\n\n    // SMEMBERS\n    val tags = connection.smembers(\"tags:123\")\n    tags.size shouldBe 3\n    tags shouldContain \"kotlin\"\n\n    // SISMEMBER\n    val isKotlin = connection.sismember(\"tags:123\", \"kotlin\")\n    isKotlin shouldBe true\n\n    // SREM\n    connection.srem(\"tags:123\", \"redis\")\n    val remainingTags = connection.smembers(\"tags:123\")\n    remainingTags.size shouldBe 2\n\n    // Set operations\n    connection.sadd(\"set1\", \"a\", \"b\", \"c\")\n    connection.sadd(\"set2\", \"b\", \"c\", \"d\")\n\n    // SINTER (intersection)\n    val intersection = connection.sinter(\"set1\", \"set2\")\n    intersection.size shouldBe 2\n    intersection shouldContain \"b\"\n    intersection shouldContain \"c\"\n\n    // SUNION\n    val union = connection.sunion(\"set1\", \"set2\")\n    union.size shouldBe 4\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#sorted-set-operations","title":"Sorted Set Operations","text":"<p>Test Redis sorted set operations:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    // ZADD\n    connection.zadd(\"leaderboard\", 100.0, \"player1\")\n    connection.zadd(\"leaderboard\", 250.0, \"player2\")\n    connection.zadd(\"leaderboard\", 175.0, \"player3\")\n\n    // ZRANGE (ascending)\n    val ascending = connection.zrange(\"leaderboard\", 0, -1)\n    ascending.size shouldBe 3\n    ascending.first() shouldBe \"player1\"\n    ascending.last() shouldBe \"player2\"\n\n    // ZREVRANGE (descending)\n    val descending = connection.zrevrange(\"leaderboard\", 0, -1)\n    descending.first() shouldBe \"player2\"\n\n    // ZSCORE\n    val score = connection.zscore(\"leaderboard\", \"player2\")\n    score shouldBe 250.0\n\n    // ZRANK\n    val rank = connection.zrank(\"leaderboard\", \"player3\")\n    rank shouldBe 1L // 0-indexed\n\n    // ZINCRBY\n    connection.zincrby(\"leaderboard\", 50.0, \"player1\")\n    val newScore = connection.zscore(\"leaderboard\", \"player1\")\n    newScore shouldBe 150.0\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#async-operations","title":"Async Operations","text":"<p>Use async operations for better performance:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().async()\n\n    // Async SET\n    val setFuture = connection.set(\"async:key\", \"async:value\")\n    setFuture.await() shouldBe \"OK\"\n\n    // Async GET\n    val getFuture = connection.get(\"async:key\")\n    val value = getFuture.await()\n    value shouldBe \"async:value\"\n\n    // Pipeline multiple operations\n    connection.setAutoFlushCommands(false)\n    val futures = listOf(\n      connection.set(\"key1\", \"value1\"),\n      connection.set(\"key2\", \"value2\"),\n      connection.set(\"key3\", \"value3\")\n    )\n    connection.flushCommands()\n\n    futures.forEach { it.await() shouldBe \"OK\" }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#pubsub-operations","title":"Pub/Sub Operations","text":"<p>Test Redis Pub/Sub:</p> <pre><code>stove {\n  redis {\n    val pubConnection = client().connectPubSub().sync()\n    val subConnection = client().connectPubSub().sync()\n\n    // Subscribe to channel\n    val messages = mutableListOf&lt;String&gt;()\n    subConnection.addListener(object : RedisPubSubAdapter&lt;String, String&gt;() {\n      override fun message(channel: String, message: String) {\n        messages.add(message)\n      }\n    })\n\n    subConnection.subscribe(\"notifications\")\n\n    // Publish messages\n    pubConnection.publish(\"notifications\", \"User logged in\")\n    pubConnection.publish(\"notifications\", \"Order created\")\n\n    // Wait for messages\n    delay(1.seconds)\n\n    messages.size shouldBe 2\n    messages shouldContain \"User logged in\"\n    messages shouldContain \"Order created\"\n\n    subConnection.unsubscribe(\"notifications\")\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#expiration-and-ttl","title":"Expiration and TTL","text":"<p>Test key expiration:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    // Set with expiration\n    connection.setex(\"temp:data\", 5, \"temporary-value\")\n\n    // Check TTL\n    val ttl = connection.ttl(\"temp:data\")\n    ttl shouldBeGreaterThan 0\n    ttl shouldBeLessThanOrEqual 5\n\n    // Set expiration on existing key\n    connection.set(\"permanent\", \"data\")\n    connection.expire(\"permanent\", 10)\n    val newTtl = connection.ttl(\"permanent\")\n    newTtl shouldBeGreaterThan 0\n\n    // Remove expiration\n    connection.persist(\"permanent\")\n    val persistedTtl = connection.ttl(\"permanent\")\n    persistedTtl shouldBe -1 // No expiration\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#transactions","title":"Transactions","text":"<p>Test Redis transactions:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    connection.multi()\n    connection.set(\"account:1:balance\", \"1000\")\n    connection.decrby(\"account:1:balance\", 100)\n    connection.incrby(\"account:2:balance\", 100)\n    val results = connection.exec()\n\n    results.size shouldBe 3\n\n    val balance1 = connection.get(\"account:1:balance\")\n    balance1 shouldBe \"900\"\n\n    val balance2 = connection.get(\"account:2:balance\")\n    balance2 shouldBe \"100\"\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Test failure scenarios:</p> <pre><code>stove {\n  redis {\n    val connection = client().connect().sync()\n\n    // Redis is running\n    connection.set(\"test\", \"value\")\n    connection.get(\"test\") shouldBe \"value\"\n\n    // Pause container\n    pause()\n\n    // Operations should fail\n    shouldThrow&lt;RedisException&gt; {\n      connection.get(\"test\")\n    }\n\n    // Unpause container\n    unpause()\n\n    // Wait for recovery\n    delay(2.seconds)\n\n    // Operations should work again\n    val value = connection.get(\"test\")\n    value shouldBe \"value\"\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#complete-example","title":"Complete Example","text":"<p>Here's a complete caching test example:</p> <pre><code>test(\"should cache product data in redis\") {\n  stove {\n    val productId = \"product-123\"\n\n    // Product not in cache - verify using client()\n    redis {\n      val conn = client().connect().sync()\n      val cached = conn.get(\"cache:product:$productId\")\n      cached shouldBe null\n    }\n\n    // Fetch from database via API (application should cache the result)\n    http {\n      get&lt;ProductResponse&gt;(\"/products/$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldNotBe null\n      }\n    }\n\n    // Application should have cached the product - verify\n    redis {\n      val conn = client().connect().sync()\n      val cachedData = conn.get(\"cache:product:$productId\")\n      cachedData shouldNotBe null\n\n      val cachedProduct = objectMapper.readValue(cachedData, ProductResponse::class.java)\n      cachedProduct.id shouldBe productId\n    }\n\n    // Verify TTL is set\n    redis {\n      val conn = client().connect().sync()\n      val ttl = conn.ttl(\"cache:product:$productId\")\n      ttl shouldBeGreaterThan 0\n      ttl shouldBeLessThanOrEqual 3600\n    }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#integration-with-application","title":"Integration with Application","text":"<p>Test application caching behavior:</p> <pre><code>test(\"should use redis for session management\") {\n  stove {\n    val sessionId = UUID.randomUUID().toString()\n\n    // Create session via API\n    http {\n      postAndExpectBody&lt;SessionResponse&gt;(\n        uri = \"/auth/login\",\n        body = LoginRequest(username = \"user\", password = \"pass\").some()\n      ) { response -&gt;\n        response.status shouldBe 200\n        response.body().sessionId shouldBe sessionId\n      }\n    }\n\n    // Verify session in Redis\n    redis {\n      val connection = client().connect().sync()\n      val sessionData = connection.get(\"session:$sessionId\")\n      sessionData shouldNotBe null\n\n      val session = objectMapper.readValue(sessionData, Session::class.java)\n      session.username shouldBe \"user\"\n      session.createdAt shouldNotBe null\n    }\n\n    // Use session\n    http {\n      get&lt;UserProfile&gt;(\n        uri = \"/profile\",\n        headers = mapOf(\"X-Session-ID\" to sessionId)\n      ) { profile -&gt;\n        profile.username shouldBe \"user\"\n      }\n    }\n\n    // Logout\n    http {\n      postAndExpectBodilessResponse(\n        uri = \"/auth/logout\",\n        body = LogoutRequest(sessionId = sessionId).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify session removed from Redis\n    redis {\n      val connection = client().connect().sync()\n      val sessionData = connection.get(\"session:$sessionId\")\n      sessionData shouldBe null\n    }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#advanced-custom-extensions","title":"Advanced: Custom Extensions","text":"<p>Create reusable extensions for common patterns:</p> <pre><code>// Custom extension functions\nfun RedisSystem.shouldGet(key: String, assertion: (String?) -&gt; Unit): RedisSystem {\n  val connection = client().connect().sync()\n  val value = connection.get(key)\n  assertion(value)\n  return this\n}\n\nfun RedisSystem.shouldSet(key: String, value: String): RedisSystem {\n  val connection = client().connect().sync()\n  connection.set(key, value)\n  return this\n}\n\n// Usage in tests\nstove {\n  redis {\n    shouldSet(\"user:123\", \"John Doe\")\n    shouldGet(\"user:123\") { value -&gt;\n      value shouldBe \"John Doe\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/10-bridge/","title":"Bridge","text":"<p>The Bridge component gives you direct access to your application's dependency injection (DI) container from your tests. This lets you grab any bean or service your application has registered, which is super useful for testing internal state, verifying side effects, or setting up test data through your application's own services.</p>"},{"location":"Components/10-bridge/#when-youd-use-this","title":"When You'd Use This","text":"<p>When writing end-to-end tests, you often need to:</p> <ul> <li>Check internal state that isn't exposed through APIs</li> <li>Use application services to set up test data</li> <li>Call domain services directly to test business logic</li> <li>Swap out time-dependent implementations for deterministic tests</li> <li>Verify side effects that happen inside the application</li> </ul> <p>Bridge gives you a type-safe way to access any component from your application's DI container.</p>"},{"location":"Components/10-bridge/#configuration","title":"Configuration","text":"<p>Bridge is built into the framework starters, so no extra dependency is needed.</p> Spring BootKtor <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-spring:$version\")\n}\n</code></pre> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-ktor:$version\")\n}\n</code></pre>"},{"location":"Components/10-bridge/#setup","title":"Setup","text":"<p>Enable Bridge in your Stove configuration:</p> <pre><code>Stove()\n  .with {\n    httpClient { HttpClientSystemOptions(baseUrl = \"http://localhost:8080\") }\n\n    bridge()  // Enable access to DI container\n\n    springBoot(\n      runner = { params -&gt; myApp.run(params) },\n      withParameters = listOf(\"server.port=8080\")\n    )\n  }\n  .run()\n</code></pre>"},{"location":"Components/10-bridge/#framework-support","title":"Framework Support","text":""},{"location":"Components/10-bridge/#spring-boot","title":"Spring Boot","text":"<p>For Spring Boot applications, Bridge provides access to the <code>ApplicationContext</code>:</p> <pre><code>// Bridge resolves beans from ApplicationContext\nusing&lt;UserService&gt; {\n    // 'this' is the UserService bean from Spring context\n    findById(123)\n}\n</code></pre> <p>Under the hood, it uses <code>ApplicationContext.getBean()</code>:</p> <pre><code>class SpringBridgeSystem(testSystem: TestSystem) : BridgeSystem&lt;ApplicationContext&gt;(testSystem) {\n    override fun &lt;D : Any&gt; get(klass: KClass&lt;D&gt;): D = ctx.getBean(klass.java)\n}\n</code></pre>"},{"location":"Components/10-bridge/#ktor","title":"Ktor","text":"<p>Ktor Bridge supports multiple dependency injection frameworks with automatic detection:</p> <ul> <li>Koin - Popular DI framework for Kotlin</li> <li>Ktor-DI - Ktor's native DI plugin</li> <li>Custom - Any DI framework via custom resolver</li> </ul> <pre><code>// Bridge resolves beans from your DI container\nusing&lt;UserRepository&gt; {\n    // 'this' is the UserRepository from your DI\n    save(user)\n}\n</code></pre>"},{"location":"Components/10-bridge/#di-framework-setup","title":"DI Framework Setup","text":"<p>Using Koin:</p> <pre><code>dependencies {\n    testImplementation(\"io.insert-koin:koin-ktor:$koinVersion\")\n}\n\n// In your test setup - bridge() auto-detects Koin\nStove()\n    .with {\n        bridge()\n        ktor(runner = { params -&gt; MyApp.run(params) })\n    }\n    .run()\n</code></pre> <p>Using Ktor-DI:</p> <pre><code>dependencies {\n    testImplementation(\"io.ktor:ktor-server-di:$ktorVersion\")\n}\n\n// In your test setup - bridge() auto-detects Ktor-DI\nStove()\n    .with {\n        bridge()\n        ktor(runner = { params -&gt; MyApp.run(params) })\n    }\n    .run()\n</code></pre> <p>Using Custom Resolver:</p> <pre><code>// For any other DI framework (Kodein, Dagger, etc.)\nStove()\n    .with {\n        bridge { application, type -&gt;\n            // type is KType - preserves generic info like List&lt;T&gt;\n            myDiContainer.resolve(type)\n        }\n        ktor(runner = { params -&gt; MyApp.run(params) })\n    }\n    .run()\n</code></pre>"},{"location":"Components/10-bridge/#generic-type-resolution","title":"Generic Type Resolution","text":"<p>Bridge preserves generic type information, enabling resolution of types like <code>List&lt;Service&gt;</code>:</p> <pre><code>// Works with Koin or Ktor-DI\nusing&lt;List&lt;PaymentService&gt;&gt; {\n    forEach { service -&gt; service.pay(order) }\n}\n</code></pre>"},{"location":"Components/10-bridge/#registering-test-dependencies-in-ktor","title":"Registering Test Dependencies in Ktor","text":"<p>Unlike Spring Boot's unified <code>addTestDependencies</code>, Ktor test dependency registration differs by DI framework:</p> <p>Koin - Using Modules:</p> <pre><code>object MyApp {\n    fun run(\n        args: Array&lt;String&gt;,\n        testModules: List&lt;Module&gt; = emptyList()  // Accept test modules\n    ): Application {\n        return embeddedServer(Netty, port = args.getPort()) {\n            install(Koin) {\n                modules(\n                    productionModule,\n                    *testModules.toTypedArray()  // Add test modules\n                )\n            }\n            configureRouting()\n        }.start(wait = false).application\n    }\n}\n\n// In your test setup\nStove()\n    .with {\n        bridge()\n        ktor(\n            runner = { params -&gt;\n                MyApp.run(\n                    params,\n                    testModules = listOf(\n                        module {\n                            // Override production beans with test doubles\n                            single&lt;TimeProvider&gt;(override = true) { FixedTimeProvider() }\n                            single&lt;EmailService&gt;(override = true) { MockEmailService() }\n                        }\n                    )\n                )\n            }\n        )\n    }\n    .run()\n</code></pre> <p>Ktor-DI - Using Dependencies Block:</p> <pre><code>object MyApp {\n    fun run(\n        args: Array&lt;String&gt;,\n        testDependencies: (DependencyRegistrar.() -&gt; Unit)? = null  // Accept test registrations\n    ): Application {\n        return embeddedServer(Netty, port = args.getPort()) {\n            install(DI) {\n                dependencies {\n                    // Production dependencies\n                    provide&lt;UserService&gt; { UserServiceImpl() }\n                    provide&lt;TimeProvider&gt; { SystemTimeProvider() }\n\n                    // Apply test overrides if provided\n                    testDependencies?.invoke(this)\n                }\n            }\n            configureRouting()\n        }.start(wait = false).application\n    }\n}\n\n// In your test setup\nStove()\n    .with {\n        bridge()\n        ktor(\n            runner = { params -&gt;\n                MyApp.run(params) {\n                    // Override production beans with test doubles\n                    provide&lt;TimeProvider&gt; { FixedTimeProvider() }\n                    provide&lt;EmailService&gt; { MockEmailService() }\n                }\n            }\n        )\n    }\n    .run()\n</code></pre> <p>Test Dependency Patterns</p> <ul> <li>Koin: Use <code>override = true</code> in test modules to replace production beans</li> <li>Ktor-DI: Later <code>provide&lt;T&gt;</code> calls override earlier ones</li> <li>Both frameworks support the pattern of passing test-specific configuration to your app's run function</li> </ul>"},{"location":"Components/10-bridge/#usage","title":"Usage","text":""},{"location":"Components/10-bridge/#single-bean-access","title":"Single Bean Access","text":"<p>Access a single bean and perform operations:</p> <pre><code>stove {\n    using&lt;UserService&gt; {\n        // 'this' refers to UserService\n        val user = findById(123)\n        user.name shouldBe \"John Doe\"\n        user.email shouldBe \"john@example.com\"\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#multiple-bean-access","title":"Multiple Bean Access","text":"<p>Access multiple beans in a single block (up to 5 beans supported):</p> <pre><code>stove {\n    // Two beans\n    using&lt;UserService, OrderService&gt; { userService, orderService -&gt;\n        val user = userService.findById(123)\n        val orders = orderService.findByUserId(123)\n        orders.size shouldBeGreaterThan 0\n    }\n\n    // Three beans\n    using&lt;UserService, ProductService, InventoryService&gt; { users, products, inventory -&gt;\n        val product = products.findById(\"SKU-123\")\n        val stock = inventory.getStock(product.id)\n        stock shouldBeGreaterThan 0\n    }\n\n    // Four beans\n    using&lt;A, B, C, D&gt; { a, b, c, d -&gt;\n        // Work with all four services\n    }\n\n    // Five beans\n    using&lt;A, B, C, D, E&gt; { a, b, c, d, e -&gt;\n        // Work with all five services\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#capturing-values-for-later-use","title":"Capturing Values for Later Use","text":"<p>When you need to capture a value from inside the <code>using</code> block for later use, declare a variable outside the block and assign it inside:</p> <pre><code>stove {\n    // Declare variable outside, assign inside\n    var userId: Long = 0\n    using&lt;UserService&gt; {\n        userId = createUser(CreateUserRequest(name = \"John\", email = \"john@example.com\")).id\n    }\n\n    // Use the captured value in subsequent operations\n    http {\n        get&lt;UserResponse&gt;(\"/users/$userId\") { user -&gt;\n            user.name shouldBe \"John\"\n        }\n    }\n\n    // Capture multiple values\n    var user: User? = null\n    var token: String? = null\n    using&lt;AuthService&gt; {\n        user = register(email = \"test@example.com\", password = \"secret\")\n        token = generateToken(user!!)\n    }\n\n    // Or use lateinit for non-nullable types\n    lateinit var order: Order\n    using&lt;OrderService&gt; {\n        order = findById(orderId)\n    }\n\n    // Use captured values\n    http {\n        getResponse(\"/orders/${order.id}\", headers = mapOf(\"Authorization\" to \"Bearer $token\")) { response -&gt;\n            response.status shouldBe 200\n        }\n    }\n}\n</code></pre> <p>Variable Capture Pattern</p> <p>Since <code>using</code> blocks don't return values, use the pattern of declaring variables outside and assigning inside when you need to pass data between blocks.</p>"},{"location":"Components/10-bridge/#use-cases","title":"Use Cases","text":""},{"location":"Components/10-bridge/#1-setting-up-test-data","title":"1. Setting Up Test Data","text":"<p>Use application repositories to set up test data:</p> <pre><code>test(\"should return user orders\") {\n    stove {\n        // Create test data using application's repository\n        var userId: Long = 0\n        using&lt;UserRepository&gt; {\n            userId = save(User(name = \"Test User\", email = \"test@example.com\")).id\n        }\n\n        using&lt;OrderRepository&gt; {\n            save(Order(userId = userId, amount = 100.0))\n            save(Order(userId = userId, amount = 250.0))\n        }\n\n        // Test the API\n        http {\n            get&lt;List&lt;OrderResponse&gt;&gt;(\"/users/$userId/orders\") { orders -&gt;\n                orders.size shouldBe 2\n                orders.sumOf { it.amount } shouldBe 350.0\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#2-verifying-internal-state","title":"2. Verifying Internal State","text":"<p>Verify state that isn't exposed through APIs:</p> <pre><code>test(\"should update inventory after order\") {\n    stove {\n        val productId = \"PROD-123\"\n\n        // Check initial inventory\n        var initialStock = 0\n        using&lt;InventoryService&gt; {\n            initialStock = getStock(productId)\n        }\n\n        // Place an order via API\n        http {\n            postAndExpectBodilessResponse(\n                uri = \"/orders\",\n                body = CreateOrderRequest(productId = productId, quantity = 5).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // Verify inventory was reduced (internal side effect)\n        using&lt;InventoryService&gt; {\n            getStock(productId) shouldBe (initialStock - 5)\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#3-testing-domain-services-directly","title":"3. Testing Domain Services Directly","text":"<p>Test business logic that may be complex to trigger through APIs:</p> <pre><code>test(\"should calculate shipping cost correctly\") {\n    stove {\n        using&lt;ShippingCalculator&gt; {\n            // Test various scenarios directly\n            calculate(weight = 1.0, destination = \"US\") shouldBe 5.99\n            calculate(weight = 5.0, destination = \"US\") shouldBe 12.99\n            calculate(weight = 1.0, destination = \"EU\") shouldBe 15.99\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#4-triggering-scheduled-jobs","title":"4. Triggering Scheduled Jobs","text":"<p>Manually trigger scheduled jobs for testing:</p> <pre><code>test(\"should process pending orders when scheduler runs\") {\n    stove {\n        // Setup: Create pending orders\n        using&lt;OrderRepository&gt; {\n            save(Order(status = \"PENDING\", createdAt = Instant.now().minusHours(2)))\n            save(Order(status = \"PENDING\", createdAt = Instant.now().minusHours(3)))\n        }\n\n        // Trigger the scheduled job manually\n        using&lt;OrderProcessingScheduler&gt; {\n            processPendingOrders()\n        }\n\n        // Verify orders were processed\n        using&lt;OrderRepository&gt; {\n            findByStatus(\"PENDING\").size shouldBe 0\n            findByStatus(\"PROCESSED\").size shouldBe 2\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#5-time-control","title":"5. Time Control","text":"<p>Control time-dependent behavior:</p> <pre><code>// First, create a testable time provider interface\ninterface TimeProvider {\n    fun now(): Instant\n}\n\n// Production implementation\nclass SystemTimeProvider : TimeProvider {\n    override fun now(): Instant = Instant.now()\n}\n\n// Test implementation\nclass FixedTimeProvider(private var time: Instant) : TimeProvider {\n    override fun now(): Instant = time\n    fun advance(duration: Duration) { time = time.plus(duration) }\n}\n\n// Register test implementation in your Stove setup\naddTestDependencies {\n    bean&lt;TimeProvider&gt;(isPrimary = true) { FixedTimeProvider(Instant.parse(\"2024-01-01T00:00:00Z\")) }\n}\n\n// Use in tests\ntest(\"should expire session after timeout\") {\n    stove {\n        // Create session and capture the session ID\n        var sessionId: String = \"\"\n        http {\n            postAndExpectBody&lt;SessionResponse&gt;(\"/login\", body = credentials.some()) { response -&gt;\n                sessionId = response.body().sessionId\n            }\n        }\n\n        // Advance time past session timeout\n        using&lt;FixedTimeProvider&gt; {\n            advance(Duration.ofHours(2))\n        }\n\n        // Session should be expired\n        http {\n            getResponse(\"/protected\", headers = mapOf(\"Session-ID\" to sessionId)) { response -&gt;\n                response.status shouldBe 401\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#6-event-verification","title":"6. Event Verification","text":"<p>Capture and verify domain events:</p> <pre><code>// Test event listener (registered via addTestDependencies)\nclass TestEventCapture {\n    private val events = ConcurrentLinkedQueue&lt;Any&gt;()\n\n    @EventListener\n    fun capture(event: Any) {\n        events.add(event)\n    }\n\n    inline fun &lt;reified T&gt; getEvents(): List&lt;T&gt; = events.filterIsInstance&lt;T&gt;()\n    fun clear() = events.clear()\n}\n\ntest(\"should publish UserCreatedEvent when user registers\") {\n    stove {\n        // Clear previous events\n        using&lt;TestEventCapture&gt; { clear() }\n\n        // Perform action\n        http {\n            postAndExpectBodilessResponse(\"/users\", body = newUser.some()) { \n                it.status shouldBe 201 \n            }\n        }\n\n        // Verify event was published\n        using&lt;TestEventCapture&gt; {\n            val events = getEvents&lt;UserCreatedEvent&gt;()\n            events.size shouldBe 1\n            events.first().email shouldBe newUser.email\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#test-bean-registration","title":"Test Bean Registration","text":"<p>Register test-specific beans using <code>addTestDependencies</code>:</p> <p>Spring Boot 2.x / 3.x:</p> <pre><code>import com.trendyol.stove.addTestDependencies\n\nStove()\n    .with {\n        bridge()\n        springBoot(\n            runner = { params -&gt; \n                runApplication&lt;MyApp&gt;(*params) {\n                    addTestDependencies {\n                        // Replace production beans with test doubles\n                        bean&lt;TimeProvider&gt;(isPrimary = true) { FixedTimeProvider(Instant.now()) }\n                        bean&lt;EmailService&gt;(isPrimary = true) { MockEmailService() }\n\n                        // Add test utilities\n                        bean&lt;TestEventCapture&gt;()\n                        bean&lt;TestDataBuilder&gt;()\n                    }\n                }\n            }\n        )\n    }\n    .run()\n</code></pre> <p>Spring Boot 4.x:</p> <pre><code>import com.trendyol.stove.addTestDependencies4x\n\nStove()\n    .with {\n        bridge()\n        springBoot(\n            runner = { params -&gt; \n                runApplication&lt;MyApp&gt;(*params) {\n                    addTestDependencies4x {\n                        // Replace production beans with test doubles\n                        registerBean&lt;TimeProvider&gt;(primary = true) { FixedTimeProvider(Instant.now()) }\n                        registerBean&lt;EmailService&gt;(primary = true) { MockEmailService() }\n\n                        // Add test utilities\n                        registerBean&lt;TestEventCapture&gt;()\n                        registerBean&lt;TestDataBuilder&gt;()\n                    }\n                }\n            }\n        )\n    }\n    .run()\n</code></pre>"},{"location":"Components/10-bridge/#alternative-using-addinitializers-directly","title":"Alternative: Using <code>addInitializers</code> Directly","text":"<p>For more control, you can use <code>addInitializers</code> with <code>stoveSpringRegistrar</code>:</p> <pre><code>// Spring Boot 2.x / 3.x\naddInitializers(stoveSpringRegistrar {\n    bean&lt;TimeProvider&gt;(isPrimary = true) { FixedTimeProvider(Instant.now()) }\n    bean&lt;TestEventCapture&gt;()\n})\n\n// Spring Boot 4.x\naddInitializers(stoveSpring4xRegistrar {\n    registerBean&lt;TimeProvider&gt;(primary = true) { FixedTimeProvider(Instant.now()) }\n    registerBean&lt;TestEventCapture&gt;()\n})\n</code></pre>"},{"location":"Components/10-bridge/#integration-with-other-systems","title":"Integration with Other Systems","text":"<p>Bridge works seamlessly with other Stove systems:</p> <pre><code>test(\"should process order end-to-end\") {\n    stove {\n        val orderId = UUID.randomUUID().toString()\n\n        // Mock external payment service\n        wiremock {\n            mockPost(\"/payments/charge\", statusCode = 200, responseBody = PaymentResult(success = true).some())\n        }\n\n        // Create order via API\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(id = orderId, amount = 99.99).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // Verify in database using application's repository\n        using&lt;OrderRepository&gt; {\n            val order = findById(orderId)\n            order.status shouldBe \"PAID\"\n            order.paymentId shouldNotBe null\n        }\n\n        // Verify Kafka event\n        kafka {\n            shouldBePublished&lt;OrderPaidEvent&gt;(atLeastIn = 10.seconds) {\n                actual.orderId == orderId\n            }\n        }\n\n        // Verify in Couchbase (if using)\n        couchbase {\n            shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n                order.status shouldBe \"PAID\"\n            }\n        }\n\n        // Access domain service for additional verification\n        using&lt;OrderAnalytics&gt; {\n            getTodaysTotalRevenue() shouldBeGreaterThanOrEqual 99.99\n        }\n  }\n}\n</code></pre>"},{"location":"Components/10-bridge/#best-practices","title":"Best Practices","text":""},{"location":"Components/10-bridge/#1-use-bridge-for-setup-http-for-actions","title":"1. Use Bridge for Setup, HTTP for Actions","text":"<pre><code>// \u2705 Good: Use bridge for setup, HTTP for testing\nusing&lt;ProductRepository&gt; {\n    save(Product(id = \"123\", name = \"Test\", price = 99.99))\n}\nhttp {\n    get&lt;ProductResponse&gt;(\"/products/123\") { product -&gt;\n        product.name shouldBe \"Test\"\n    }\n}\n\n// \u274c Avoid: Using bridge for everything\nusing&lt;ProductService&gt; {\n    create(product)\n    val retrieved = findById(\"123\")  // Not testing actual API\n    retrieved.name shouldBe \"Test\"\n}\n</code></pre>"},{"location":"Components/10-bridge/#2-prefer-application-services-over-direct-repository-access","title":"2. Prefer Application Services Over Direct Repository Access","text":"<pre><code>// \u2705 Good: Use application services that encapsulate business logic\nusing&lt;OrderService&gt; {\n    createOrder(CreateOrderRequest(...))  // Triggers all business logic\n}\n\n// \u26a0\ufe0f Be careful: Direct repository access bypasses business logic\nusing&lt;OrderRepository&gt; {\n    save(Order(...))  // No validation, no events, no side effects\n}\n</code></pre>"},{"location":"Components/10-bridge/#3-clean-up-test-data","title":"3. Clean Up Test Data","text":"<pre><code>// Use cleanup functions or explicit cleanup in tests\nstove {\n    var userId: Long = 0\n    using&lt;UserRepository&gt; {\n        userId = save(user).id\n    }\n\n    try {\n        // Test logic\n        http { /* ... */ }\n    } finally {\n        // Cleanup\n        using&lt;UserRepository&gt; {\n            deleteById(userId)\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#4-keep-test-beans-minimal","title":"4. Keep Test Beans Minimal","text":"<p>Only replace what's necessary:</p> <pre><code>// \u2705 Good: Replace only time-sensitive components\naddTestDependencies {\n    bean&lt;Clock&gt;(isPrimary = true) { Clock.fixed(fixedInstant, ZoneId.UTC) }\n}\n\n// \u274c Avoid: Replacing too many components (reduces test value)\naddTestDependencies {\n    bean&lt;UserService&gt;(isPrimary = true) { MockUserService() }\n    bean&lt;OrderService&gt;(isPrimary = true) { MockOrderService() }\n    bean&lt;PaymentService&gt;(isPrimary = true) { MockPaymentService() }\n}\n</code></pre>"},{"location":"Components/10-bridge/#summary","title":"Summary","text":"<p>The Bridge component enables:</p> Capability Example Use Case Bean Access Resolve any bean from DI container State Verification Check internal state not exposed by APIs Test Setup Create test data using application services Time Control Replace time providers for deterministic tests Event Capture Verify domain events were published Job Triggering Manually trigger scheduled tasks Service Testing Test domain services directly <p>Bridge is essential for comprehensive e2e testing, allowing you to verify and control aspects of your application that aren't accessible through external interfaces alone.</p>"},{"location":"Components/11-provided-instances/","title":"Provided Instances (Testcontainer-less Mode)","text":"<p>Stove supports using externally provided infrastructure instances instead of testcontainers. This is particularly useful for:</p> <ul> <li>CI/CD pipelines with shared infrastructure</li> <li>Reducing startup time by reusing existing instances</li> <li>Lower memory/CPU usage by avoiding container overhead</li> <li>Working with pre-configured environments</li> </ul>"},{"location":"Components/11-provided-instances/#overview","title":"Overview","text":"<p>Instead of starting a testcontainer, you can configure Stove to connect to an existing instance using the <code>.provided(...)</code> companion function on the options class itself.</p>"},{"location":"Components/11-provided-instances/#core-concept","title":"Core Concept","text":"<p>Each system's options class (e.g., <code>CouchbaseSystemOptions</code>, <code>PostgresqlOptions</code>) has a companion function called <code>provided(...)</code> that returns a specialized options subclass configured for external instances.</p>"},{"location":"Components/11-provided-instances/#usage-pattern","title":"Usage Pattern","text":"<p>All systems follow the same pattern:</p> <pre><code>Stove()\n  .with {\n    // Option 1: Container-based (default)\n    systemName {\n      SystemOptions(\n        // System-specific options\n        cleanup = { client -&gt; /* cleanup logic */ },\n        configureExposedConfiguration = { cfg -&gt; listOf(\"property=${cfg.value}\") }\n      )\n    }\n\n    // Option 2: Provided instance using .provided() companion function\n    systemName {\n      SystemOptions.provided(\n        // Connection parameters for external instance\n        runMigrations = true,\n        cleanup = { client -&gt; /* cleanup logic */ },\n        configureExposedConfiguration = { cfg -&gt; listOf(\"property=${cfg.value}\") }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#supported-systems","title":"Supported Systems","text":""},{"location":"Components/11-provided-instances/#couchbase","title":"Couchbase","text":"<pre><code>// Container-based with cleanup\nStove()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(\n        defaultBucket = \"myBucket\",\n        cleanup = { cluster -&gt;\n          cluster.query(\"DELETE FROM `myBucket` WHERE type = 'test'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"couchbase.hosts=${cfg.hostsWithPort}\",\n            \"couchbase.username=${cfg.username}\",\n            \"couchbase.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nStove()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions.provided(\n        connectionString = \"couchbase://localhost:8091\",\n        username = \"admin\",\n        password = \"password\",\n        defaultBucket = \"myBucket\",\n        runMigrations = true,\n        cleanup = { cluster -&gt;\n          cluster.query(\"DELETE FROM `myBucket` WHERE type = 'test'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"couchbase.hosts=${cfg.hostsWithPort}\",\n            \"couchbase.username=${cfg.username}\",\n            \"couchbase.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#kafka","title":"Kafka","text":"<pre><code>// Container-based\nStove()\n  .with {\n    kafka {\n      KafkaSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n            \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nStove()\n  .with {\n    kafka {\n      KafkaSystemOptions.provided(\n        bootstrapServers = \"localhost:9092\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n            \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#redis","title":"Redis","text":"<pre><code>// Container-based\nStove()\n  .with {\n    redis {\n      RedisOptions(\n        cleanup = { client -&gt;\n          client.connect().sync().flushdb()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"redis.host=${cfg.host}\",\n            \"redis.port=${cfg.port}\",\n            \"redis.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nStove()\n  .with {\n    redis {\n      RedisOptions.provided(\n        host = \"localhost\",\n        port = 6379,\n        password = \"password\",\n        database = 8,\n        cleanup = { client -&gt;\n          client.connect().sync().flushdb()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"redis.host=${cfg.host}\",\n            \"redis.port=${cfg.port}\",\n            \"redis.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#postgresql","title":"PostgreSQL","text":"<pre><code>// Container-based\nStove()\n  .with {\n    postgresql {\n      PostgresqlOptions(\n        databaseName = \"testdb\",\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM users WHERE email LIKE '%@test.com'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nStove()\n  .with {\n    postgresql {\n      PostgresqlOptions.provided(\n        jdbcUrl = \"jdbc:postgresql://localhost:5432/testdb\",\n        host = \"localhost\",\n        port = 5432,\n        databaseName = \"testdb\",\n        username = \"postgres\",\n        password = \"postgres\",\n        runMigrations = true,\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM users WHERE email LIKE '%@test.com'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#mssql","title":"MSSQL","text":"<pre><code>// Container-based\nStove()\n  .with {\n    mssql {\n      MsSqlOptions(\n        applicationName = \"stove-tests\",\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM Orders WHERE OrderDate &lt; GETDATE() - 1\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nStove()\n  .with {\n    mssql {\n      MsSqlOptions.provided(\n        jdbcUrl = \"jdbc:sqlserver://localhost:1433;databaseName=testdb\",\n        host = \"localhost\",\n        port = 1433,\n        databaseName = \"testdb\",\n        username = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        runMigrations = true,\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM Orders WHERE OrderDate &lt; GETDATE() - 1\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#mongodb","title":"MongoDB","text":"<pre><code>// Container-based\nStove()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        cleanup = { client -&gt;\n          client.getDatabase(\"testdb\").drop()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nStove()\n  .with {\n    mongodb {\n      MongodbSystemOptions.provided(\n        connectionString = \"mongodb://localhost:27017\",\n        host = \"localhost\",\n        port = 27017,\n        cleanup = { client -&gt;\n          client.getDatabase(\"testdb\").drop()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#elasticsearch","title":"Elasticsearch","text":"<pre><code>// Container-based\nStove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        cleanup = { esClient -&gt;\n          esClient.indices().delete { it.index(\"test-*\") }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nStove()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions.provided(\n        host = \"localhost\",\n        port = 9200,\n        password = \"\", // Leave empty if security is disabled\n        runMigrations = true,\n        cleanup = { esClient -&gt;\n          esClient.indices().delete { it.index(\"test-*\") }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#cleanup-function","title":"Cleanup Function","text":"<p>The <code>cleanup</code> parameter is available for both container-based and provided instance modes. It executes during <code>close()</code> before the system is stopped - this ensures cleanup runs after all tests have completed.</p>"},{"location":"Components/11-provided-instances/#use-cases","title":"Use Cases","text":"<ol> <li>Clear test data from previous runs</li> <li>Reset state to a known baseline</li> <li>Delete test-specific records that shouldn't persist</li> </ol>"},{"location":"Components/11-provided-instances/#example-with-container-mode-and-keepdependenciesrunning","title":"Example with Container Mode and keepDependenciesRunning","text":"<p>The cleanup function is especially useful when using containers with <code>keepDependenciesRunning</code>:</p> <pre><code>TestSystem {\n  keepDependenciesRunning()\n}.with {\n  couchbase {\n    CouchbaseSystemOptions(\n      defaultBucket = \"myBucket\",\n      cleanup = { cluster -&gt;\n        // Clean test data between runs when reusing containers\n        cluster.query(\"DELETE FROM `myBucket` WHERE type = 'test'\")\n      },\n      configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      }\n    )\n  }\n}.run()\n</code></pre>"},{"location":"Components/11-provided-instances/#migration-handling","title":"Migration Handling","text":"<p>When using provided instances, migrations are controlled by the <code>runMigrations</code> parameter in the <code>.provided()</code> function:</p> <ul> <li><code>runMigrations = true</code> (default for databases): Migrations will run on every test execution</li> <li><code>runMigrations = false</code> (default for Kafka/Redis): Migrations are skipped</li> </ul> <pre><code>Stove()\n  .with {\n    postgresql {\n      PostgresqlOptions.provided(\n        jdbcUrl = \"jdbc:postgresql://localhost:5432/mydb\",\n        host = \"localhost\",\n        port = 5432,\n        databaseName = \"mydb\",\n        username = \"user\",\n        password = \"pass\",\n        runMigrations = false, // Schema already exists\n        configureExposedConfiguration = { cfg -&gt; listOf(/* ... */) }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#limitations","title":"Limitations","text":"<p>When using provided instances, some operations are not available:</p> <ul> <li><code>pause()</code> - Cannot pause an external instance</li> <li><code>unpause()</code> - Cannot unpause an external instance</li> <li><code>inspect()</code> - Container inspection not available</li> </ul> <p>These methods will log a warning and return without effect when called on a provided instance.</p>"},{"location":"Components/11-provided-instances/#complete-example","title":"Complete Example","text":"<p>Here's a complete setup for a CI/CD pipeline using provided instances:</p> <pre><code>class TestSetup : AbstractProjectConfig() {\n  override suspend fun beforeProject() {\n    Stove()\n      .with {\n        httpClient {\n          HttpClientSystemOptions(baseUrl = \"http://localhost:8080\")\n        }\n        bridge()\n        couchbase {\n          CouchbaseSystemOptions.provided(\n            connectionString = System.getenv(\"COUCHBASE_CONNECTION_STRING\"),\n            username = System.getenv(\"COUCHBASE_USERNAME\"),\n            password = System.getenv(\"COUCHBASE_PASSWORD\"),\n            defaultBucket = \"app-bucket\",\n            runMigrations = true,\n            cleanup = { cluster -&gt;\n              cluster.query(\"DELETE FROM `app-bucket` WHERE _type = 'test'\")\n            },\n            configureExposedConfiguration = { cfg -&gt;\n              listOf(\n                \"couchbase.hosts=${cfg.hostsWithPort}\",\n                \"couchbase.username=${cfg.username}\",\n                \"couchbase.password=${cfg.password}\"\n              )\n            }\n          )\n        }\n        kafka {\n          KafkaSystemOptions.provided(\n            bootstrapServers = System.getenv(\"KAFKA_BOOTSTRAP_SERVERS\"),\n            configureExposedConfiguration = { cfg -&gt;\n              listOf(\n                \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n                \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n              )\n            }\n          )\n        }\n        springBoot(\n          runner = { params -&gt;\n            com.example.Application.run(params)\n          }\n        )\n      }\n      .run()\n  }\n\n  override suspend fun afterProject() {\n    Stove.stop()\n  }\n}\n</code></pre>"},{"location":"Components/11-provided-instances/#test-isolation-with-shared-infrastructure","title":"Test Isolation with Shared Infrastructure","text":"<p>Critical: Prevent Test Run Collisions</p> <p>When using provided instances (shared infrastructure), multiple test runs can interfere with each other if they use the same resource names. This is especially important in CI/CD pipelines where parallel builds may run against the same infrastructure.</p>"},{"location":"Components/11-provided-instances/#the-problem","title":"The Problem","text":"<p>Consider this scenario: - Build #1 creates records in <code>orders</code> table - Build #2 starts while Build #1 is still running - Build #2 reads Build #1's test data \u2192 Test failures! - Both builds try to create the same Kafka topic \u2192 Conflicts!</p>"},{"location":"Components/11-provided-instances/#the-solution-unique-resource-prefixes","title":"The Solution: Unique Resource Prefixes","text":"<p>Generate unique prefixes for each test run and use them for all resource names:</p> <pre><code>object TestRunContext {\n    // Unique prefix for this test run\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: System.getenv(\"BUILD_NUMBER\")\n        ?: UUID.randomUUID().toString().take(8)\n\n    // Resource names with unique prefixes\n    val databaseName = \"testdb_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n    val bucketPrefix = \"test_${runId}_\"\n    val cacheKeyPrefix = \"test:$runId:\"\n}\n</code></pre>"},{"location":"Components/11-provided-instances/#implementation-by-system","title":"Implementation by System","text":""},{"location":"Components/11-provided-instances/#postgresql-mssql-unique-database","title":"PostgreSQL / MSSQL - Unique Database","text":"<pre><code>Stove()\n    .with {\n        postgresql {\n            PostgresqlOptions.provided(\n                jdbcUrl = \"jdbc:postgresql://shared-db:5432/${TestRunContext.databaseName}\",\n                host = \"shared-db\",\n                port = 5432,\n                databaseName = TestRunContext.databaseName,\n                username = \"postgres\",\n                password = \"postgres\",\n                runMigrations = true,  // Creates tables in unique database\n                cleanup = { ops -&gt;\n                    // Optional: cleanup is less critical with unique database\n                    ops.execute(\"DROP SCHEMA public CASCADE; CREATE SCHEMA public;\")\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\"spring.datasource.url=${cfg.jdbcUrl}\")\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"spring.datasource.url=jdbc:postgresql://shared-db:5432/${TestRunContext.databaseName}\"\n            )\n        )\n    }\n</code></pre> <p>Database Creation</p> <p>You can create the database using Stove's migration system: <pre><code>class CreateDatabaseMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 0  // Run first\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        connection.operations.execute(\n            \"CREATE DATABASE IF NOT EXISTS ${TestRunContext.databaseName}\"\n        )\n    }\n}\n</code></pre></p> <p>Multiple Databases</p> <p>If your application uses multiple databases in production (e.g., separate databases for users, orders, analytics), you can create all of them via migrations and expose separate connection URLs:</p> <pre><code>configureExposedConfiguration = { cfg -&gt;\n    val baseUrl = \"jdbc:postgresql://${cfg.host}:${cfg.port}\"\n    listOf(\n        \"db.users.url=$baseUrl/users_${TestRunContext.runId}\",\n        \"db.orders.url=$baseUrl/orders_${TestRunContext.runId}\",\n        \"db.analytics.url=$baseUrl/analytics_${TestRunContext.runId}\",\n        // ... common credentials\n    )\n}\n</code></pre> <p>See PostgreSQL - Multiple Databases for a complete guide.</p>"},{"location":"Components/11-provided-instances/#kafka-unique-topic-prefix","title":"Kafka - Unique Topic Prefix","text":"<pre><code>Stove()\n    .with {\n        kafka {\n            KafkaSystemOptions.provided(\n                bootstrapServers = \"shared-kafka:9092\",\n                topicSuffixes = TopicSuffixes(\n                    // These are suffixes for error/retry topics\n                    error = \".error\",\n                    retry = \".retry\"\n                ),\n                cleanup = { admin -&gt;\n                    // Delete only topics with our prefix\n                    val ourTopics = admin.listTopics().names().get()\n                        .filter { it.startsWith(TestRunContext.topicPrefix) }\n                    if (ourTopics.isNotEmpty()) {\n                        admin.deleteTopics(ourTopics).all().get()\n                    }\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n                        \"kafka.topicPrefix=${TestRunContext.topicPrefix}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                // Application uses this prefix for all topic names\n                \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n                \"kafka.topic.payments=${TestRunContext.topicPrefix}payments\",\n                \"kafka.topic.notifications=${TestRunContext.topicPrefix}notifications\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#elasticsearch-unique-index-prefix","title":"Elasticsearch - Unique Index Prefix","text":"<pre><code>Stove()\n    .with {\n        elasticsearch {\n            ElasticsearchSystemOptions.provided(\n                host = \"shared-elasticsearch\",\n                port = 9200,\n                password = \"\",\n                runMigrations = true,\n                cleanup = { esClient -&gt;\n                    // Delete only indices with our prefix\n                    esClient.indices().delete { \n                        it.index(\"${TestRunContext.indexPrefix}*\") \n                    }\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"elasticsearch.host=${cfg.host}\",\n                        \"elasticsearch.indexPrefix=${TestRunContext.indexPrefix}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\",\n                \"elasticsearch.index.orders=${TestRunContext.indexPrefix}orders\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#couchbase-unique-document-prefix-or-scope","title":"Couchbase - Unique Document Prefix or Scope","text":"<pre><code>Stove()\n    .with {\n        couchbase {\n            CouchbaseSystemOptions.provided(\n                connectionString = \"couchbase://shared-couchbase:8091\",\n                username = \"admin\",\n                password = \"password\",\n                defaultBucket = \"shared-bucket\",\n                runMigrations = true,\n                cleanup = { cluster -&gt;\n                    // Delete only documents with our prefix\n                    cluster.query(\n                        \"DELETE FROM `shared-bucket` WHERE META().id LIKE '${TestRunContext.bucketPrefix}%'\"\n                    )\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"couchbase.documentPrefix=${TestRunContext.bucketPrefix}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"couchbase.documentPrefix=${TestRunContext.bucketPrefix}\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#mongodb-unique-database-or-collection-prefix","title":"MongoDB - Unique Database or Collection Prefix","text":"<pre><code>Stove()\n    .with {\n        mongodb {\n            MongodbSystemOptions.provided(\n                connectionString = \"mongodb://shared-mongo:27017\",\n                host = \"shared-mongo\",\n                port = 27017,\n                cleanup = { client -&gt;\n                    // Drop our unique database\n                    client.getDatabase(TestRunContext.databaseName).drop()\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"mongodb.database=${TestRunContext.databaseName}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"spring.data.mongodb.database=${TestRunContext.databaseName}\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#redis-unique-key-prefix-or-database-number","title":"Redis - Unique Key Prefix or Database Number","text":"<pre><code>Stove()\n    .with {\n        redis {\n            // Use unique database number (0-15) or key prefix\n            val redisDb = (TestRunContext.runId.hashCode() and 0xF)  // 0-15\n\n            RedisOptions.provided(\n                host = \"shared-redis\",\n                port = 6379,\n                password = \"\",\n                database = redisDb,\n                cleanup = { client -&gt;\n                    // Flush only our database\n                    client.connect().sync().flushdb()\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"spring.redis.database=$redisDb\"\n                    )\n                }\n            )\n        }\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#complete-cicd-example","title":"Complete CI/CD Example","text":"<pre><code>object TestRunContext {\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: System.getenv(\"GITHUB_RUN_ID\")\n        ?: System.getenv(\"BUILD_NUMBER\")\n        ?: UUID.randomUUID().toString().take(8)\n\n    val databaseName = \"test_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n    val keyPrefix = \"test:$runId:\"\n\n    init {\n        println(\"Test Run ID: $runId\")\n        println(\"Database: $databaseName\")\n        println(\"Topic Prefix: $topicPrefix\")\n    }\n}\n\nclass TestConfig : AbstractProjectConfig() {\n    override suspend fun beforeProject() {\n        Stove()\n            .with {\n                postgresql {\n                    PostgresqlOptions.provided(\n                        jdbcUrl = \"jdbc:postgresql://db:5432/${TestRunContext.databaseName}\",\n                        databaseName = TestRunContext.databaseName,\n                        // ... other config\n                    )\n                }\n                kafka {\n                    KafkaSystemOptions.provided(\n                        bootstrapServers = \"kafka:9092\",\n                        cleanup = { admin -&gt;\n                            val topics = admin.listTopics().names().get()\n                                .filter { it.startsWith(TestRunContext.topicPrefix) }\n                            if (topics.isNotEmpty()) admin.deleteTopics(topics).all().get()\n                        },\n                        // ... other config\n                    )\n                }\n                elasticsearch {\n                    ElasticsearchSystemOptions.provided(\n                        host = \"elasticsearch\",\n                        port = 9200,\n                        cleanup = { es -&gt;\n                            es.indices().delete { it.index(\"${TestRunContext.indexPrefix}*\") }\n                        },\n                        // ... other config\n                    )\n                }\n                springBoot(\n                    runner = { params -&gt; myApp.run(params) },\n                    withParameters = listOf(\n                        \"spring.datasource.url=jdbc:postgresql://db:5432/${TestRunContext.databaseName}\",\n                        \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n                        \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\"\n                    )\n                )\n            }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        Stove.stop()\n        // Resources cleaned up by cleanup functions\n    }\n}\n</code></pre>"},{"location":"Components/11-provided-instances/#best-practices-for-test-isolation","title":"Best Practices for Test Isolation","text":"Practice Description Use CI Job ID Most CI systems provide unique job/build IDs - use them Prefix everything Database names, topics, indices, keys - all should be unique Clean up after Use cleanup functions to remove test data Short prefixes Keep prefixes short but unique (8 chars usually enough) Log the prefix Print the run ID at test start for debugging Application support Your app must read resource names from configuration"},{"location":"Components/11-provided-instances/#debugging-isolation-issues","title":"Debugging Isolation Issues","text":"<p>If tests fail intermittently in CI:</p> <ol> <li> <p>Check for hardcoded names: <pre><code>// \u274c Bad - hardcoded\nval topic = \"orders\"\n\n// \u2705 Good - configurable\nval topic = config.getString(\"kafka.topic.orders\")\n</code></pre></p> </li> <li> <p>Verify cleanup runs: <pre><code>cleanup = { admin -&gt;\n    println(\"Cleaning up topics with prefix: ${TestRunContext.topicPrefix}\")\n    // ... cleanup code\n}\n</code></pre></p> </li> <li> <p>Check parallel job interference: <pre><code># In CI logs, look for overlapping run IDs\ngrep \"Test Run ID\" build-*.log\n</code></pre></p> </li> </ol>"},{"location":"Components/12-grpc/","title":"gRPC","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-grpc:$version\")\n    }\n</code></pre>"},{"location":"Components/12-grpc/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>grpc</code>:</p> <pre><code>Stove()\n  .with {\n    grpc {\n      GrpcSystemOptions(\n        host = \"localhost\",\n        port = 50051\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/12-grpc/#configuration-options","title":"Configuration Options","text":"<pre><code>data class GrpcSystemOptions(\n  /**\n   * The gRPC server host.\n   */\n  val host: String,\n\n  /**\n   * The gRPC server port.\n   */\n  val port: Int,\n\n  /**\n   * Whether to use plaintext (no TLS). Default is true for testing.\n   */\n  val usePlaintext: Boolean = true,\n\n  /**\n   * Request timeout duration (default: 30 seconds).\n   */\n  val timeout: Duration = 30.seconds,\n\n  /**\n   * List of client interceptors for logging, auth, tracing, etc.\n   */\n  val interceptors: List&lt;ClientInterceptor&gt; = emptyList(),\n\n  /**\n   * Default metadata (headers) to send with every request.\n   */\n  val metadata: Map&lt;String, String&gt; = emptyMap(),\n\n  /**\n   * Factory function for creating the underlying ManagedChannel.\n   */\n  val createChannel: (host: String, port: Int) -&gt; ManagedChannel = { h, p -&gt;\n    defaultChannelBuilder(h, p, usePlaintext, timeout, interceptors, metadata)\n  },\n\n  /**\n   * Factory function for creating Wire's GrpcClient with resources.\n   */\n  val createWireClient: (host: String, port: Int) -&gt; WireClientResources = { h, p -&gt;\n    defaultWireGrpcClient(h, p, timeout, metadata)\n  }\n)\n</code></pre>"},{"location":"Components/12-grpc/#with-authentication","title":"With Authentication","text":"<pre><code>grpc {\n  GrpcSystemOptions(\n    host = \"localhost\",\n    port = 50051,\n    metadata = mapOf(\"authorization\" to \"Bearer $token\"),\n    interceptors = listOf(LoggingInterceptor())\n  )\n}\n</code></pre>"},{"location":"Components/12-grpc/#usage","title":"Usage","text":"<p>Stove's gRPC module supports multiple gRPC providers through a provider-agnostic design:</p> <ul> <li>Wire clients (<code>wireClient&lt;T&gt;</code>) - For Wire-generated clients</li> <li>Typed channel (<code>channel&lt;T&gt;</code>) - For any stub with a Channel constructor</li> <li>Custom providers (<code>withEndpoint</code>) - For any gRPC library</li> <li>Raw channel (<code>rawChannel</code>) - For advanced scenarios</li> </ul>"},{"location":"Components/12-grpc/#wire-clients","title":"Wire Clients","text":"<p>For services generated with Wire:</p> <pre><code>stove {\n  grpc {\n    wireClient&lt;GreeterServiceClient&gt; {\n      val response = SayHello().execute(HelloRequest(name = \"World\"))\n      response.message shouldBe \"Hello, World!\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#typed-channel-grpc-kotlin-and-wire-stubs","title":"Typed Channel (grpc-kotlin and Wire stubs)","text":"<p>For any stub that takes a Channel constructor. This works with both grpc-kotlin generated stubs and Wire-generated stubs:</p> <pre><code>stove {\n  grpc {\n    channel&lt;GreeterServiceStub&gt; {\n      // 'this' is the stub - direct method calls\n      val response = sayHello(HelloRequest(name = \"World\"))\n      response.message shouldBe \"Hello, World!\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#with-per-call-metadata","title":"With Per-Call Metadata","text":"<pre><code>stove {\n  grpc {\n    channel&lt;GreeterServiceStub&gt;(\n      metadata = mapOf(\"authorization\" to \"Bearer custom-token\")\n    ) {\n      val response = sayHello(HelloRequest(name = \"Authenticated\"))\n      response.message shouldBe \"Hello, Authenticated!\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#custom-providers","title":"Custom Providers","text":"<p>For any other gRPC library, use <code>withEndpoint</code> with a factory function:</p> <pre><code>stove {\n  grpc {\n    withEndpoint({ host, port -&gt; \n      // Create your client however you want\n      MyCustomGrpcClient.connect(host, port)\n    }) {\n      // 'this' is your client\n      this.call() shouldBe expected\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#raw-channel-access","title":"Raw Channel Access","text":"<p>For advanced scenarios where you need full control:</p> <pre><code>stove {\n  grpc {\n    rawChannel { channel -&gt;\n      // Full control over channel\n      val stub = GreeterGrpc.newBlockingStub(channel)\n      val response = stub.sayHello(request)\n      response.message shouldBe \"Hello!\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#streaming","title":"Streaming","text":"<p>All streaming types work naturally with Kotlin coroutines.</p>"},{"location":"Components/12-grpc/#server-streaming","title":"Server Streaming","text":"<pre><code>stove {\n  grpc {\n    channel&lt;StreamServiceStub&gt; {\n      val responses = serverStream(request).toList()\n\n      responses.size shouldBe 5\n      responses[0].message shouldBe \"Item 0\"\n      responses[4].message shouldBe \"Item 4\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#client-streaming","title":"Client Streaming","text":"<pre><code>stove {\n  grpc {\n    channel&lt;StreamServiceStub&gt; {\n      val requestFlow = flow {\n        emit(Request(message = \"First\"))\n        emit(Request(message = \"Second\"))\n        emit(Request(message = \"Third\"))\n      }\n\n      val response = clientStream(requestFlow)\n      response.message shouldBe \"Received: First, Second, Third\"\n      response.count shouldBe 3\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#bidirectional-streaming","title":"Bidirectional Streaming","text":"<pre><code>stove {\n  grpc {\n    channel&lt;StreamServiceStub&gt; {\n      val requestFlow = flow {\n        emit(Request(message = \"A\"))\n        emit(Request(message = \"B\"))\n      }\n\n      val responses = bidiStream(requestFlow).toList()\n      responses.size shouldBe 2\n      responses[0].message shouldBe \"Echo: A\"\n      responses[1].message shouldBe \"Echo: B\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#wire-client-details","title":"Wire Client Details","text":""},{"location":"Components/12-grpc/#direct-grpcclient-access","title":"Direct GrpcClient Access","text":"<pre><code>stove {\n  grpc {\n    rawWireClient { client -&gt;\n      val service = client.create(GreeterServiceClient::class)\n      val response = service.SayHello().execute(HelloRequest(name = \"Direct\"))\n      response.message shouldBe \"Hello, Direct!\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#wire-client-with-custom-okhttp-configuration","title":"Wire Client with Custom OkHttp Configuration","text":"<pre><code>stove {\n  grpc {\n    withEndpoint({ host, port -&gt;\n      val okHttpClient = OkHttpClient.Builder()\n        .protocols(listOf(Protocol.H2_PRIOR_KNOWLEDGE))\n        .addInterceptor { chain -&gt;\n          val request = chain.request().newBuilder()\n            .addHeader(\"authorization\", \"Bearer my-token\")\n            .build()\n          chain.proceed(request)\n        }\n        .build()\n\n      GrpcClient.Builder()\n        .client(okHttpClient)\n        .baseUrl(\"http://$host:$port\")\n        .build()\n        .create(GreeterServiceClient::class)\n    }) {\n      val response = SayHello().execute(HelloRequest(name = \"Custom\"))\n      response.message shouldBe \"Hello, Custom!\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#authentication-interceptors","title":"Authentication &amp; Interceptors","text":""},{"location":"Components/12-grpc/#global-interceptors","title":"Global Interceptors","text":"<pre><code>class LoggingInterceptor : ClientInterceptor {\n  override fun &lt;ReqT, RespT&gt; interceptCall(\n    method: MethodDescriptor&lt;ReqT, RespT&gt;,\n    callOptions: CallOptions,\n    next: Channel\n  ): ClientCall&lt;ReqT, RespT&gt; {\n    println(\"Calling: ${method.fullMethodName}\")\n    return next.newCall(method, callOptions)\n  }\n}\n\nStove()\n  .with {\n    grpc {\n      GrpcSystemOptions(\n        host = \"localhost\",\n        port = 50051,\n        interceptors = listOf(LoggingInterceptor())\n      )\n    }\n  }\n</code></pre>"},{"location":"Components/12-grpc/#per-call-metadata","title":"Per-Call Metadata","text":"<pre><code>stove {\n  grpc {\n    // Metadata is applied via interceptor automatically\n    channel&lt;SecureServiceStub&gt;(\n      metadata = mapOf(\n        \"authorization\" to \"Bearer jwt-token\",\n        \"x-request-id\" to \"12345\"\n      )\n    ) {\n      val response = secureEndpoint(request)\n      response.success shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#error-handling","title":"Error Handling","text":""},{"location":"Components/12-grpc/#testing-authentication-errors","title":"Testing Authentication Errors","text":"<pre><code>stove {\n  grpc {\n    // Wire client - throws GrpcException\n    wireClient&lt;SecureServiceClient&gt; {\n      val exception = shouldThrow&lt;GrpcException&gt; {\n        SecureCall().execute(Request(message = \"Hello\"))\n      }\n      exception.grpcStatus shouldBe GrpcStatus.UNAUTHENTICATED\n    }\n\n    // grpc-kotlin - throws StatusException\n    channel&lt;SecureServiceStub&gt; {\n      val exception = shouldThrow&lt;StatusException&gt; {\n        secureCall(request)\n      }\n      exception.status.code shouldBe Status.Code.UNAUTHENTICATED\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#testing-not-found","title":"Testing Not Found","text":"<pre><code>stove {\n  grpc {\n    channel&lt;UserServiceStub&gt; {\n      val exception = shouldThrow&lt;StatusException&gt; {\n        getUser(GetUserRequest(id = 999999))\n      }\n      exception.status.code shouldBe Status.Code.NOT_FOUND\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#complete-example","title":"Complete Example","text":"<p>Here's a complete test example with various gRPC operations:</p> <pre><code>test(\"should perform gRPC operations\") {\n  stove {\n    // Test unary call\n    grpc {\n      channel&lt;UserServiceStub&gt; {\n        val response = createUser(CreateUserRequest(name = \"John\", email = \"john@example.com\"))\n        response.id shouldNotBe null\n        response.name shouldBe \"John\"\n      }\n    }\n\n    // Test with authentication\n    grpc {\n      channel&lt;UserServiceStub&gt;(\n        metadata = mapOf(\"authorization\" to \"Bearer admin-token\")\n      ) {\n        val users = listUsers(ListUsersRequest(limit = 10)).toList()\n        users.size shouldBeGreaterThan 0\n      }\n    }\n\n    // Test error handling\n    grpc {\n      channel&lt;UserServiceStub&gt; {\n        shouldThrow&lt;StatusException&gt; {\n          getUser(GetUserRequest(id = -1))\n        }.status.code shouldBe Status.Code.INVALID_ARGUMENT\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#integration-with-other-components","title":"Integration with Other Components","text":""},{"location":"Components/12-grpc/#grpc-database","title":"gRPC + Database","text":"<pre><code>stove {\n  // Create via gRPC\n  var userId: Long = 0\n  grpc {\n    channel&lt;UserServiceStub&gt; {\n      val response = createUser(CreateUserRequest(name = \"John\"))\n      userId = response.id\n    }\n  }\n\n  // Verify in database\n  postgresql {\n    shouldQuery(\n      query = \"SELECT * FROM users WHERE id = $userId\",\n      mapper = { row -&gt; User(row.long(\"id\"), row.string(\"name\")) }\n    ) { users -&gt;\n      users.size shouldBe 1\n      users.first().name shouldBe \"John\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#grpc-kafka","title":"gRPC + Kafka","text":"<pre><code>stove {\n  // Trigger event via gRPC\n  grpc {\n    channel&lt;OrderServiceStub&gt; {\n      createOrder(CreateOrderRequest(amount = 100.0))\n    }\n  }\n\n  // Verify event was published\n  kafka {\n    shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n      actual.amount == 100.0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/12-grpc/#provider-support","title":"Provider Support","text":"Provider DSL Method Notes Wire <code>wireClient&lt;T&gt;</code> For Wire-generated service clients grpc-kotlin <code>channel&lt;T&gt;</code> Works with any stub with Channel constructor Wire stubs <code>channel&lt;T&gt;</code> Works with Wire server stubs Custom <code>withEndpoint</code> Any library with factory function Advanced <code>rawChannel</code> Direct ManagedChannel access Advanced <code>rawWireClient</code> Direct Wire GrpcClient access"},{"location":"Components/13-reporting/","title":"Reporting","text":"<p>When tests fail, you want to know what went wrong. Stove's reporting system tracks everything that happens during test execution\u2014every HTTP call, database query, Kafka message, and more. When something fails, you get a detailed report showing exactly what happened, making debugging much easier.</p>"},{"location":"Components/13-reporting/#what-you-get","title":"What You Get","text":"<ul> <li>Automatic tracking of all system interactions (HTTP requests, Kafka messages, database queries, etc.)</li> <li>Rich failure reports that show what happened before the failure</li> <li>Multiple output formats - human-readable console output or machine-readable JSON</li> <li>Framework integration with Kotest and JUnit (optional extensions)</li> </ul>"},{"location":"Components/13-reporting/#quick-start","title":"Quick Start","text":"<p>The reporting extensions are optional but recommended. They automatically enrich test failures with detailed execution reports, making debugging much easier.</p>"},{"location":"Components/13-reporting/#kotest-integration","title":"Kotest Integration","text":"<p>If you're using Kotest, add the extension dependency:</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-extensions-kotest\")\n}\n</code></pre> <p>Test Framework Extensions</p> <p><code>StoveKotestExtension</code> (<code>stove-extensions-kotest</code>) and <code>StoveJUnitExtension</code> (<code>stove-extensions-junit</code>) are separate packages. Kotest requires 6.1.3+; JUnit requires Jupiter 6.x if possible. For Kotest, add a <code>kotest.properties</code> file with <code>kotest.framework.config.fqn=&lt;your config class FQN&gt;</code>. See the Getting Started guide for details.</p> <p>Then register it in your project config:</p> <pre><code>import com.trendyol.stove.extensions.kotest.StoveKotestExtension\nimport com.trendyol.stove.system.Stove\n\nclass TestConfig : AbstractProjectConfig() {\n    override val extensions: List&lt;Extension&gt; = listOf(StoveKotestExtension())\n\n    override suspend fun beforeProject() {\n        Stove()\n            .with {\n                // your configuration\n            }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        Stove.stop()\n    }\n}\n</code></pre>"},{"location":"Components/13-reporting/#junit-integration","title":"JUnit Integration","text":"<p>For JUnit, add the extension dependency:</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-extensions-junit\")\n}\n</code></pre> <p>Then annotate your test class:</p> <pre><code>import com.trendyol.stove.extensions.junit.StoveJUnitExtension\nimport org.junit.jupiter.api.extension.ExtendWith\n\n@ExtendWith(StoveJUnitExtension::class)\nclass MyE2ETest {\n    // your tests\n}\n</code></pre> <p>The JUnit extension works with both JUnit 5 and 6 since they share the same Jupiter API.</p>"},{"location":"Components/13-reporting/#configuration","title":"Configuration","text":"<p>You can configure reporting options when setting up Stove:</p> <pre><code>Stove {\n    reporting {\n        enabled()           // Enable reporting (default: true)\n        dumpOnFailure()     // Dump report when tests fail (default: true)\n        failureRenderer(PrettyConsoleRenderer)  // Set the renderer\n    }\n}.with {\n    // your configuration\n}.run()\n</code></pre> <p>Or use the direct methods if you prefer:</p> <pre><code>Stove {\n    reportingEnabled(true)\n    dumpReportOnTestFailure(true)\n    failureRenderer(PrettyConsoleRenderer)\n}.with {\n    // your configuration\n}.run()\n</code></pre>"},{"location":"Components/13-reporting/#what-gets-reported","title":"What Gets Reported","text":""},{"location":"Components/13-reporting/#actions","title":"Actions","text":"<p>Every interaction with a Stove system is recorded:</p>  - **HTTP**: All requests and responses (GET, POST, PUT, DELETE, etc.) - **Kafka**: Message publishing, consumption, and failure assertions - **Database**: Queries, saves, deletes (Couchbase, PostgreSQL, MongoDB, etc.) - **WireMock**: Stub registrations and verifications - **gRPC**: Client connections and calls"},{"location":"Components/13-reporting/#assertions","title":"Assertions","text":"<p>Both successful and failed assertions are tracked:</p> <ul> <li>Expected vs. actual values</li> <li>Assertion descriptions</li> <li>Error messages</li> </ul>"},{"location":"Components/13-reporting/#example-output","title":"Example Output","text":"<p>When a test fails, you'll see output like this:</p> <pre><code>expected:&lt;2&gt; but was:&lt;1&gt;\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                         STOVE EXECUTION REPORT\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                           STOVE TEST REPORT                                  \u2551\n\u2551 Test: ExampleTest::should save the product                                   \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 14:47:38.215 \u2713 PASSED [HTTP] POST /api/products                              \u2551\n\u2551     Input: {\"id\":1234,\"name\":\"Test Product\"}                                 \u2551\n\u2551     Output: 201 Created                                                      \u2551\n\u2551                                                                              \u2551\n\u2551 14:47:38.341 \u2717 FAILED [PostgreSQL] Query                                     \u2551\n\u2551     Input: SELECT * FROM Products WHERE id=1234                              \u2551\n\u2551     Output: 1 row(s) returned                                                \u2551\n\u2551     Expected: 2                                                              \u2551\n\u2551     Actual: 1                                                                \u2551\n\u2551     Error: expected:&lt;2&gt; but was:&lt;1&gt;                                          \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre>"},{"location":"Components/13-reporting/#renderers","title":"Renderers","text":"<p>Stove provides two built-in renderers:</p>"},{"location":"Components/13-reporting/#prettyconsolerenderer-default","title":"PrettyConsoleRenderer (Default)","text":"<p>Human-readable format with:</p> <ul> <li>Colorized output (when terminal supports ANSI)</li> <li>Box-drawing characters for structure</li> <li>Timestamps for each action</li> <li>Clear pass/fail indicators</li> </ul>"},{"location":"Components/13-reporting/#jsonreportrenderer","title":"JsonReportRenderer","text":"<p>Machine-readable JSON format, useful for:</p> <ul> <li>CI/CD integration</li> <li>Log aggregation systems</li> <li>Custom report processing</li> </ul> <pre><code>Stove {\n    failureRenderer(JsonReportRenderer)\n}\n</code></pre> <p>Example JSON output:</p> <pre><code>{\n  \"testId\": \"ExampleTest::should save the product\",\n  \"testName\": \"should save the product\",\n  \"entries\": [\n    {\n      \"type\": \"action\",\n      \"system\": \"HTTP\",\n      \"action\": \"POST /api/products\",\n      \"timestamp\": \"2025-01-05T14:47:38.215\",\n      \"result\": \"PASSED\",\n      \"input\": {\"id\": 1234, \"name\": \"Test Product\"},\n      \"output\": \"201 Created\"\n    },\n    {\n      \"type\": \"action_with_result\",\n      \"system\": \"PostgreSQL\",\n      \"action\": \"Query\",\n      \"timestamp\": \"2025-01-05T14:47:38.341\",\n      \"result\": \"FAILED\",\n      \"expected\": 2,\n      \"actual\": 1,\n      \"error\": \"expected:&lt;2&gt; but was:&lt;1&gt;\"\n    }\n  ],\n  \"summary\": {\n    \"totalActions\": 2,\n    \"totalAssertions\": 0,\n    \"passedAssertions\": 0,\n    \"failedAssertions\": 1\n  }\n}\n</code></pre> <p>To use the JSON renderer:</p> <pre><code>Stove {\n    failureRenderer(JsonReportRenderer)\n}\n</code></pre>"},{"location":"Components/13-reporting/#system-snapshots","title":"System Snapshots","text":"<p>Some systems provide state snapshots when tests fail, giving you visibility into the system's internal state:</p>"},{"location":"Components/13-reporting/#kafka-snapshot","title":"Kafka Snapshot","text":"<p>Shows all messages in the message store:</p> <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 \u250c\u2500 KAFKA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2551\n\u2551                                                                              \u2551\n\u2551   Consumed: 1                                                                \u2551\n\u2551   Produced: 1                                                                \u2551\n\u2551   Failed: 0                                                                  \u2551\n\u2551                                                                              \u2551\n\u2551   State Details:                                                             \u2551\n\u2551     produced: 1 item(s)                                                      \u2551\n\u2551       [0]                                                                    \u2551\n\u2551         topic: product-events                                                \u2551\n\u2551         key: 1234                                                            \u2551\n\u2551         value: {\"id\":1234,\"name\":\"Test Product\"}                             \u2551\n\u2551     consumed: 1 item(s)                                                      \u2551\n\u2551       [0]                                                                    \u2551\n\u2551         topic: product-events                                                \u2551\n\u2551         value: {\"id\":1234,\"name\":\"Test Product\"}                             \u2551\n\u2551     failed: 0 item(s)                                                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre>"},{"location":"Components/13-reporting/#wiremock-snapshot","title":"WireMock Snapshot","text":"<p>Shows registered stubs and unmatched requests:</p> <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 \u250c\u2500 WIREMOCK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2551\n\u2551                                                                              \u2551\n\u2551   Registered stubs: 2                                                        \u2551\n\u2551   Served requests: 1 (matched: 1)                                            \u2551\n\u2551   Unmatched requests: 0                                                      \u2551\n\u2551                                                                              \u2551\n\u2551   State Details:                                                             \u2551\n\u2551     registeredStubs: 2 item(s)                                               \u2551\n\u2551     servedRequests: 1 item(s)                                                \u2551\n\u2551     unmatchedRequests: 0 item(s)                                             \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre>"},{"location":"Components/13-reporting/#disabling-reporting","title":"Disabling Reporting","text":"<p>If you need to disable reporting (e.g., for performance-sensitive test runs):</p> <pre><code>Stove {\n    reporting {\n        disabled()\n    }\n}\n</code></pre> <p>Or:</p> <pre><code>Stove {\n    reportingEnabled(false)\n}\n</code></pre>"},{"location":"Components/13-reporting/#best-practices","title":"Best Practices","text":""},{"location":"Components/13-reporting/#1-use-the-extension-for-better-debugging","title":"1. Use the Extension for Better Debugging","text":"<p>While optional, the extensions make debugging much easier by automatically tracking test context and enriching failures with detailed reports. Just add the dependency for your test framework:</p> <ul> <li>Kotest: <code>testImplementation(\"com.trendyol:stove-extensions-kotest\")</code></li> <li>JUnit: <code>testImplementation(\"com.trendyol:stove-extensions-junit\")</code></li> </ul>"},{"location":"Components/13-reporting/#2-use-descriptive-actions","title":"2. Use Descriptive Actions","text":"<p>When writing custom assertions, provide meaningful descriptions:</p> <pre><code>shouldQuery&lt;Product&gt;(\"SELECT * FROM products WHERE active = true\") { products -&gt;\n    products.size shouldBe expectedCount\n}\n</code></pre>"},{"location":"Components/13-reporting/#3-review-reports-on-ci","title":"3. Review Reports on CI","text":"<p>The JSON renderer is particularly useful for CI/CD pipelines. You can:</p> <ul> <li>Parse the JSON output for custom reporting</li> <li>Store reports as build artifacts</li> <li>Integrate with test management tools</li> </ul>"},{"location":"Components/13-reporting/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Components/13-reporting/#reports-not-showing","title":"Reports Not Showing","text":"<p>If you're not seeing reports when tests fail, check these:</p> <ol> <li>Extension dependency added? (optional but recommended)</li> <li>Kotest: <code>testImplementation(\"com.trendyol:stove-extensions-kotest\")</code></li> <li> <p>JUnit: <code>testImplementation(\"com.trendyol:stove-extensions-junit\")</code></p> </li> <li> <p>Extension registered?</p> </li> <li>Kotest: <code>override val extensions = listOf(StoveKotestExtension())</code></li> <li> <p>JUnit: <code>@ExtendWith(StoveJUnitExtension::class)</code></p> </li> <li> <p>Reporting enabled? <pre><code>Stove {\n    reportingEnabled(true)\n    dumpReportOnTestFailure(true)\n}\n</code></pre></p> </li> <li> <p>Stove initialized? Make sure <code>Stove().run()</code> is called before your tests execute.</p> </li> </ol>"},{"location":"Components/13-reporting/#truncated-output","title":"Truncated Output","text":"<p>If output appears truncated in your console, try:</p> <ul> <li>Using a wider terminal window</li> <li>Switching to <code>JsonReportRenderer</code> for full output</li> <li>Checking your logging configuration</li> </ul>"},{"location":"Components/14-grpc-mock/","title":"gRPC Mock","text":"<p><code>stove-grpc-mock</code> provides a native gRPC mock server for testing gRPC service integrations. Unlike WireMock-based solutions, this implementation provides full support for all gRPC RPC types without external dependency conflicts.</p>"},{"location":"Components/14-grpc-mock/#features","title":"Features","text":"Feature Support Unary RPC \u2705 Full support Server Streaming \u2705 Full support Client Streaming \u2705 Full support Bidirectional Streaming \u2705 Full support Error responses \u2705 Full support Request matching \u2705 Full support Authentication \u2705 Full support Multiple services \u2705 Same port"},{"location":"Components/14-grpc-mock/#installation","title":"Installation","text":"<pre><code>dependencies {\n  testImplementation(\"com.trendyol:stove-grpc-mock:$stoveVersion\")\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#configuration","title":"Configuration","text":"<p>By default, gRPC Mock uses a dynamic port (port = 0), which lets the system pick an available port automatically. This avoids port conflicts, especially in CI environments.</p> <pre><code>Stove()\n  .with {\n    grpcMock {\n      GrpcMockSystemOptions(\n        // port = 0 by default (dynamic port)\n        removeStubAfterRequestMatched = true, // optional, default false\n        configureExposedConfiguration = { cfg -&gt;\n          // cfg.host = \"localhost\"\n          // cfg.port = &lt;dynamic-port&gt;\n          listOf(\n            \"grpcService.host=${cfg.host}\",\n            \"grpcService.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n    // Your application configuration - gRPC settings are auto-injected\n    ktor(\n      runner = { parameters -&gt; run(parameters) }\n    )\n  }\n</code></pre>"},{"location":"Components/14-grpc-mock/#using-fixed-port-not-recommended-for-ci","title":"Using Fixed Port (Not Recommended for CI)","text":"<p>If you need a specific port:</p> <pre><code>grpcMock {\n  GrpcMockSystemOptions(\n    port = 9090  // Fixed port\n  )\n}\n</code></pre> <p>Dynamic Ports Avoid CI Conflicts</p> <p>Using <code>port = 0</code> (the default) lets the system pick an available port automatically. This is essential in CI environments where:</p> <ul> <li>Multiple test runs may execute in parallel</li> <li>Other services might already be using common ports</li> <li>You get \"Address already in use\" errors with fixed ports</li> </ul> <p>The <code>configureExposedConfiguration</code> callback receives the actual port after the server starts.</p>"},{"location":"Components/14-grpc-mock/#usage","title":"Usage","text":""},{"location":"Components/14-grpc-mock/#mocking-unary-calls","title":"Mocking Unary Calls","text":"<pre><code>test(\"should mock unary gRPC call\") {\n  stove {\n    grpcMock {\n      mockUnary(\n        serviceName = \"greeting.GreeterService\",\n        methodName = \"SayHello\",\n        response = HelloResponse.newBuilder()\n          .setMessage(\"Hello from mock!\")\n          .build()\n      )\n    }\n\n    // Your test that triggers the gRPC call\n    http {\n      get(\"/api/greet/World\") { response -&gt;\n        response.body shouldContain \"Hello from mock!\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#mocking-with-request-matching","title":"Mocking with Request Matching","text":"<pre><code>grpcMock {\n  // Match specific request\n  mockUnary(\n    serviceName = \"users.UserService\",\n    methodName = \"GetUser\",\n    requestMatcher = RequestMatcher.ExactMessage(\n      GetUserRequest.newBuilder().setUserId(\"123\").build()\n    ),\n    response = GetUserResponse.newBuilder()\n      .setName(\"John Doe\")\n      .build()\n  )\n\n  // Custom matcher\n  mockUnary(\n    serviceName = \"users.UserService\",\n    methodName = \"GetUser\",\n    requestMatcher = RequestMatcher.Custom { bytes -&gt;\n      // Parse and inspect request bytes\n      val request = GetUserRequest.parseFrom(bytes)\n      request.userId.startsWith(\"vip-\")\n    },\n    response = GetUserResponse.newBuilder()\n      .setName(\"VIP User\")\n      .build()\n  )\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#mocking-server-streaming","title":"Mocking Server Streaming","text":"<pre><code>grpcMock {\n  mockServerStream(\n    serviceName = \"streaming.ItemService\",\n    methodName = \"ListItems\",\n    responses = listOf(\n      Item.newBuilder().setId(\"1\").setName(\"Item 1\").build(),\n      Item.newBuilder().setId(\"2\").setName(\"Item 2\").build(),\n      Item.newBuilder().setId(\"3\").setName(\"Item 3\").build()\n    )\n  )\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#mocking-client-streaming","title":"Mocking Client Streaming","text":"<pre><code>grpcMock {\n  mockClientStream(\n    serviceName = \"upload.UploadService\",\n    methodName = \"UploadChunks\",\n    response = UploadResponse.newBuilder()\n      .setTotalSize(1024)\n      .setSuccess(true)\n      .build()\n  )\n}\n</code></pre> <p>Note: For client streaming, the <code>requestMatcher</code> is evaluated against only the first request in the stream. This is because stub matching happens before the full stream is received. If you need to validate all requests in a client stream, use the bidirectional streaming mock with a custom handler instead.</p>"},{"location":"Components/14-grpc-mock/#mocking-bidirectional-streaming","title":"Mocking Bidirectional Streaming","text":"<pre><code>grpcMock {\n  mockBidiStream(\n    serviceName = \"chat.ChatService\",\n    methodName = \"Chat\"\n  ) { requestFlow -&gt;\n    // Transform each request into a response\n    requestFlow.map { requestBytes -&gt;\n      val request = ChatMessage.parseFrom(requestBytes)\n      ChatMessage.newBuilder()\n        .setMessage(\"Echo: ${request.message}\")\n        .build()\n    }\n  }\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#mocking-error-responses","title":"Mocking Error Responses","text":"<pre><code>grpcMock {\n  mockError(\n    serviceName = \"users.UserService\",\n    methodName = \"GetUser\",\n    status = Status.Code.NOT_FOUND,\n    message = \"User not found\"\n  )\n\n  // With request matching\n  mockError(\n    serviceName = \"users.UserService\",\n    methodName = \"DeleteUser\",\n    requestMatcher = RequestMatcher.ExactMessage(\n      DeleteUserRequest.newBuilder().setUserId(\"admin\").build()\n    ),\n    status = Status.Code.PERMISSION_DENIED,\n    message = \"Cannot delete admin user\"\n  )\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#authentication-support","title":"Authentication Support","text":"<p><code>stove-grpc-mock</code> provides full support for mocking authenticated gRPC calls.</p>"},{"location":"Components/14-grpc-mock/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<pre><code>grpcMock {\n  mockUnary(\n    serviceName = \"secure.SecureService\",\n    methodName = \"GetSecret\",\n    metadataMatcher = MetadataMatcher.BearerToken(\"valid-token-123\"),\n    response = SecretResponse.newBuilder()\n      .setData(\"confidential\")\n      .build()\n  )\n}\n\n// Call with proper token\ngrpc {\n  channel&lt;SecureServiceGrpcKt.SecureServiceCoroutineStub&gt;(\n    metadata = mapOf(\"authorization\" to \"Bearer valid-token-123\")\n  ) {\n    val response = getSecret(request)  // Works!\n  }\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#custom-header-matching","title":"Custom Header Matching","text":"<pre><code>grpcMock {\n  mockUnary(\n    serviceName = \"api.ApiService\",\n    methodName = \"GetData\",\n    metadataMatcher = MetadataMatcher.HasHeader(\"x-api-key\", \"secret-key\"),\n    response = DataResponse.newBuilder().build()\n  )\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#require-any-authentication","title":"Require Any Authentication","text":"<pre><code>grpcMock {\n  // Matches any request with a non-empty authorization header\n  mockUnary(\n    serviceName = \"auth.AuthService\",\n    methodName = \"GetProfile\",\n    metadataMatcher = MetadataMatcher.RequiresAuth,\n    response = ProfileResponse.newBuilder().build()\n  )\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#combined-matchers","title":"Combined Matchers","text":"<pre><code>grpcMock {\n  mockUnary(\n    serviceName = \"multi.MultiAuthService\",\n    methodName = \"GetResource\",\n    metadataMatcher = MetadataMatcher.All(\n      MetadataMatcher.BearerToken(\"valid-token\"),\n      MetadataMatcher.HasHeader(\"x-tenant-id\", \"tenant-123\")\n    ),\n    response = ResourceResponse.newBuilder().build()\n  )\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#authenticated-streaming","title":"Authenticated Streaming","text":"<pre><code>grpcMock {\n  mockServerStream(\n    serviceName = \"secure.DataService\",\n    methodName = \"StreamData\",\n    metadataMatcher = MetadataMatcher.BearerToken(\"stream-token\"),\n    responses = listOf(data1, data2, data3)\n  )\n\n  mockClientStream(\n    serviceName = \"secure.UploadService\",\n    methodName = \"Upload\",\n    metadataMatcher = MetadataMatcher.BearerToken(\"upload-token\"),\n    response = UploadResponse.newBuilder().setSuccess(true).build()\n  )\n\n  mockBidiStream(\n    serviceName = \"secure.ChatService\",\n    methodName = \"Chat\",\n    metadataMatcher = MetadataMatcher.BearerToken(\"chat-token\")\n  ) { requestFlow -&gt;\n    requestFlow.map { parseAndRespond(it) }\n  }\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#testing-auth-failures","title":"Testing Auth Failures","text":"<pre><code>test(\"should reject unauthenticated request\") {\n  stove {\n    grpcMock {\n      // Only accepts valid token\n      mockUnary(\n        serviceName = \"secure.SecureService\",\n        methodName = \"GetSecret\",\n        metadataMatcher = MetadataMatcher.BearerToken(\"valid-token\"),\n        response = SecretResponse.newBuilder().build()\n      )\n    }\n\n    grpc {\n      // Call WITHOUT token - fails with UNIMPLEMENTED (no matching stub)\n      channel&lt;SecureServiceGrpcKt.SecureServiceCoroutineStub&gt; {\n        val exception = shouldThrow&lt;StatusException&gt; {\n          getSecret(request)\n        }\n        exception.status.code shouldBe Status.Code.UNIMPLEMENTED\n      }\n\n      // Call WITH wrong token - also fails\n      channel&lt;SecureServiceGrpcKt.SecureServiceCoroutineStub&gt;(\n        metadata = mapOf(\"authorization\" to \"Bearer wrong-token\")\n      ) {\n        val exception = shouldThrow&lt;StatusException&gt; {\n          getSecret(request)\n        }\n        exception.status.code shouldBe Status.Code.UNIMPLEMENTED\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#multiple-grpc-services","title":"Multiple gRPC Services","text":"<p>The mock server can handle multiple services on the same port. Simply register stubs for different services:</p> <pre><code>Stove()\n  .with {\n    grpcMock {\n      GrpcMockSystemOptions(port = 9090)\n    }\n    ktor(\n      withParameters = listOf(\n        // All services point to the same mock server\n        \"featureToggle.host=localhost\",\n        \"featureToggle.port=9090\",\n        \"pricing.host=localhost\", \n        \"pricing.port=9090\",\n        \"inventory.host=localhost\",\n        \"inventory.port=9090\"\n      ),\n      runner = { parameters -&gt; run(parameters) }\n    )\n  }\n</code></pre> <p>Then mock each service in your tests:</p> <pre><code>test(\"should handle multiple gRPC services\") {\n  stove {\n    grpcMock {\n      // Service 1: Feature Toggle\n      mockUnary(\n        serviceName = \"featuretoggle.FeatureToggleService\",\n        methodName = \"IsFeatureEnabled\",\n        response = IsFeatureEnabledResponse.newBuilder()\n          .setEnabled(true)\n          .build()\n      )\n\n      // Service 2: Pricing\n      mockUnary(\n        serviceName = \"pricing.PricingService\",\n        methodName = \"CalculatePrice\",\n        response = CalculatePriceResponse.newBuilder()\n          .setFinalPrice(29.99)\n          .build()\n      )\n\n      // Service 3: Inventory (error case)\n      mockError(\n        serviceName = \"inventory.InventoryService\",\n        methodName = \"CheckStock\",\n        status = Status.Code.UNAVAILABLE,\n        message = \"Inventory service is down\"\n      )\n    }\n\n    // Test your application logic\n    http {\n      post(\"/api/checkout\", body = checkoutRequest.some()) { response -&gt;\n        // Assert based on mocked responses\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#stub-removal-options","title":"Stub Removal Options","text":"<p>By default, stubs persist across requests. You can configure automatic removal:</p> <pre><code>grpcMock {\n  GrpcMockSystemOptions(\n    port = 9090,\n    removeStubAfterRequestMatched = true // Remove stub after first match\n  )\n}\n</code></pre> <p>This is useful when testing retry logic or different responses for sequential calls.</p>"},{"location":"Components/14-grpc-mock/#direct-grpc-client-testing","title":"Direct gRPC Client Testing","text":"<p>You can also test gRPC calls directly using the <code>grpc</code> system:</p> <pre><code>test(\"should call mocked gRPC service directly\") {\n  stove {\n    grpcMock {\n      mockUnary(\n        serviceName = \"greeting.GreeterService\",\n        methodName = \"SayHello\",\n        response = HelloResponse.newBuilder()\n          .setMessage(\"Hello!\")\n          .build()\n      )\n    }\n\n    grpc {\n      channel&lt;GreeterServiceGrpcKt.GreeterServiceCoroutineStub&gt; {\n        val response = sayHello(\n          HelloRequest.newBuilder().setName(\"Test\").build()\n        )\n        response.message shouldBe \"Hello!\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/14-grpc-mock/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Your Application                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  ServiceA Client    \u2502      ServiceB Client                  \u2502\n\u2502  (port 9090)        \u2502      (port 9090)                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                        \u2502\n             \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              stove-grpc-mock Server (port 9090)             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502              Dynamic Handler Registry                   \u2502 \u2502\n\u2502  \u2502  Routes by: serviceName/methodName                      \u2502 \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502\n\u2502  \u2502 serviceA.*          \u2502    serviceB.*                     \u2502 \u2502\n\u2502  \u2502 \u2192 stub responses    \u2502    \u2192 stub responses               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"Components/14-grpc-mock/#comparison-with-wiremock-grpc","title":"Comparison with WireMock gRPC","text":"Feature stove-grpc-mock WireMock gRPC Unary RPC \u2705 \u2705 Server Streaming \u2705 Full \u26a0\ufe0f First response only Client Streaming \u2705 \u274c Not supported Bidi Streaming \u2705 \u274c Not supported Proto descriptors Not needed Required Dependency conflicts None Shaded protobuf issues Setup complexity Simple Requires descriptor generation"},{"location":"Components/14-grpc-mock/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Register stubs before triggering calls - Stubs must be registered before your application makes gRPC calls.</p> </li> <li> <p>Use specific request matchers - When testing different scenarios, use <code>RequestMatcher.ExactMessage</code> to ensure the right stub is matched.</p> </li> <li> <p>Test error scenarios - Use <code>mockError()</code> to test how your application handles gRPC failures.</p> </li> <li> <p>Multiple services, single port - Point all gRPC clients to the same mock server port for simpler configuration.</p> </li> <li> <p>Use <code>removeStubAfterRequestMatched</code> - Enable this when testing retry logic or sequential calls with different responses.</p> </li> </ol>"},{"location":"Components/15-tracing/","title":"Tracing","text":"<p>Your end-to-end test just failed. Now what?</p> <p>You stare at a stack trace that says \"expected message not found within timeout\". You dig through application logs. You check Kafka topics. You wonder if the HTTP request even reached the controller. Was it a database error? A serialization issue? A Kafka consumer that silently died?</p> <p>What if your test failure told you exactly what happened inside your application?</p> <pre><code>\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nEXECUTION TRACE (Call Chain)\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2713 POST (377ms)\n  \u2713 POST /api/product/create (361ms)\n    \u2713 ProductController.create (141ms)\n      \u2713 ProductCreator.create (0ms)\n      \u2713 KafkaProducer.send (137ms)\n        \u2713 orders.created publish (81ms)\n          \u2717 orders.created process (82ms)  \u2190 FAILURE POINT\n</code></pre> <p>That's Stove tracing. When a test fails, you see the entire call chain of your application, powered by OpenTelemetry: every controller method, every database query, every Kafka message, every HTTP call, with timing and the exact point of failure. It's a unique feature.</p>"},{"location":"Components/15-tracing/#what-you-get","title":"What You Get","text":"<p>When tracing is enabled, every test failure comes with the full story:</p> <pre><code>STOVE EXECUTION REPORT\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nTIMELINE\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n14:45:38.439 \u2713 PASSED [HTTP] POST /api/product/create\n14:45:38.472 \u2717 FAILED [Kafka] shouldBePublished&lt;ProductCreatedEvent&gt;\n\nSYSTEM SNAPSHOTS\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nKAFKA\n  Consumed: 0\n  Produced: 1\n  Failed: 1\n    [0] topic: orders.created\n        reason: Something went wrong\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nEXECUTION TRACE (Call Chain)\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2713 POST (377ms)\n  \u2713 POST /api/product/create (361ms)\n    \u2713 ProductController.create (141ms)\n      \u2713 ProductCreator.create (0ms)\n      \u2713 KafkaProducer.send (137ms)\n        \u2713 orders.created publish (81ms)\n          \u2717 orders.created process (82ms)  \u2190 FAILURE POINT\n</code></pre> <p>Everything is automatic:</p> <ul> <li>Traces start and end with each test</li> <li>W3C <code>traceparent</code> headers are injected into HTTP requests</li> <li>Trace headers are injected into Kafka messages</li> <li>Trace metadata is injected into gRPC calls</li> <li>All spans are correlated back to the originating test</li> <li>Failure reports are enriched with the execution trace</li> </ul> <p>When failures include exceptions, you see those too:</p> <pre><code>\u2717 PaymentGateway.charge [80ms] \u26a0 FAILURE POINT\n\u251c\u2500\u2500 Exception: PaymentDeclinedException\n\u2502   Message: Card declined\n\u2502   at PaymentGateway.charge(PaymentGateway.kt:42)\n</code></pre> <p>Successful traces render as clean hierarchical trees:</p> <pre><code>\u2713 OrderController.createOrder [100ms]\n\u251c\u2500\u2500 \u2713 OrderService.processOrder [95ms]\n\u2502   \u251c\u2500\u2500 \u2713 UserRepository.findById [10ms]\n\u2502   \u2502   \u2514\u2500\u2500 db.system: postgresql\n\u2502   \u2514\u2500\u2500 \u2713 PaymentClient.charge [65ms]\n\u2502       \u2514\u2500\u2500 http.url: https://payment.api/charge\n\nSummary: 4 spans, 0 failures, total: 100ms\n</code></pre>"},{"location":"Components/15-tracing/#setup","title":"Setup","text":"<p>Two steps. That's it.</p>"},{"location":"Components/15-tracing/#step-1-enable-tracing-in-your-stove-config","title":"Step 1: Enable tracing in your Stove config","text":"<pre><code>Stove()\n    .with {\n        tracing {\n            enableSpanReceiver()\n        }\n        // ... your other systems (http, kafka, etc.)\n    }\n    .run()\n</code></pre>"},{"location":"Components/15-tracing/#step-2-attach-the-opentelemetry-agent-in-your-build","title":"Step 2: Attach the OpenTelemetry agent in your build","text":"Gradle Plugin (Recommended)buildSrc (Copy-Paste) <pre><code>plugins {\n    id(\"com.trendyol.stove.tracing\") version \"&lt;stove-version&gt;\"\n}\n\nstoveTracing {\n    serviceName.set(\"my-service\")\n}\n</code></pre> <p>The plugin is published to both the Gradle Plugin Portal and Maven Central.</p> <p>Copy StoveTracingConfiguration.kt to your project's <code>buildSrc/src/main/kotlin/</code> directory, then add to your <code>build.gradle.kts</code>:</p> <pre><code>import com.trendyol.stove.gradle.stoveTracing\n\nstoveTracing {\n    serviceName = \"my-service\"\n}\n</code></pre> <p>Both approaches handle everything: downloading the OpenTelemetry Java Agent, configuring JVM arguments, attaching the agent to your test tasks, and dynamically assigning ports so parallel test runs don't conflict.</p> <p>That's all you need</p> <p>Now write your tests as usual. When a test fails, you'll see the execution trace automatically. No code changes to your application required. The OpenTelemetry agent instruments 100+ libraries (Spring, JDBC, Kafka, gRPC, HTTP clients, Redis, MongoDB, and more) with zero code changes.</p>"},{"location":"Components/15-tracing/#dependencies","title":"Dependencies","text":"<pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-tracing:$stoveVersion\")\n    testImplementation(\"com.trendyol:stove-extensions-kotest:$stoveVersion\")\n    // or\n    testImplementation(\"com.trendyol:stove-extensions-junit:$stoveVersion\")\n}\n</code></pre> <p>Test Framework Extensions</p> <p><code>StoveKotestExtension</code> (<code>stove-extensions-kotest</code>) and <code>StoveJUnitExtension</code> (<code>stove-extensions-junit</code>) are separate packages that must be on your classpath. Kotest requires 6.1.3+; JUnit requires Jupiter 6.x if possible. For Kotest, add a <code>kotest.properties</code> file with <code>kotest.framework.config.fqn=&lt;your config class FQN&gt;</code>. See the Getting Started guide for details.</p>"},{"location":"Components/15-tracing/#zero-effort-trace-propagation","title":"Zero-Effort Trace Propagation","text":"<p>You don't need to do anything special in your test code. Stove injects trace headers into every interaction automatically:</p> HTTPKafkagRPC <pre><code>http {\n    get&lt;UserResponse&gt;(\"/users/123\") { user -&gt;\n        user.name shouldBe \"John\"\n    }\n}\n</code></pre> <pre><code>kafka {\n    publish(\"orders.created\", OrderCreatedEvent(orderId = \"123\"))\n}\n</code></pre> <pre><code>grpc {\n    channel&lt;GreeterServiceStub&gt; {\n        sayHello(HelloRequest(name = \"World\"))\n    }\n}\n</code></pre> <p>Every HTTP request gets a <code>traceparent</code> header. Every Kafka message gets trace headers. Every gRPC call gets trace metadata. Your application picks these up through the OpenTelemetry agent, and Stove collects the resulting spans, all without you writing a single line of tracing code.</p>"},{"location":"Components/15-tracing/#trace-validation-dsl","title":"Trace Validation DSL","text":"<p>Beyond automatic failure reports, you can actively query and assert on traces using the <code>tracing { }</code> DSL. This is useful when you want to verify how your application handled a request, not just that it did.</p> <pre><code>test(\"order processing should call payment service\") {\n    stove {\n        http {\n            post&lt;OrderResponse&gt;(\"/orders\", orderRequest) { response -&gt;\n                response.status shouldBe \"created\"\n            }\n        }\n\n        tracing {\n            shouldContainSpan(\"OrderService.processOrder\")\n            shouldContainSpan(\"PaymentClient.charge\")\n            shouldNotHaveFailedSpans()\n            executionTimeShouldBeLessThan(500.milliseconds)\n        }\n    }\n}\n</code></pre>"},{"location":"Components/15-tracing/#span-assertions","title":"Span Assertions","text":"<p>Verify which operations happened (or didn't) during a test:</p> <pre><code>tracing {\n    shouldContainSpan(\"UserService.findById\")\n    shouldContainSpanMatching { it.operationName.contains(\"Repository\") }\n    shouldNotContainSpan(\"AdminService.delete\")\n\n    shouldNotHaveFailedSpans()\n    shouldHaveFailedSpan(\"PaymentGateway.charge\")\n\n    shouldHaveSpanWithAttribute(\"http.method\", \"GET\")\n    shouldHaveSpanWithAttributeContaining(\"http.url\", \"/api/users\")\n}\n</code></pre>"},{"location":"Components/15-tracing/#performance-assertions","title":"Performance Assertions","text":"<p>Assert on execution timing and span counts:</p> <pre><code>tracing {\n    executionTimeShouldBeLessThan(500.milliseconds)\n    executionTimeShouldBeGreaterThan(10.milliseconds)\n\n    spanCountShouldBe(10)\n    spanCountShouldBeAtLeast(5)\n    spanCountShouldBeAtMost(20)\n}\n</code></pre>"},{"location":"Components/15-tracing/#debugging-helpers","title":"Debugging Helpers","text":"<p>When you need to understand what happened during a test, render the trace:</p> <pre><code>tracing {\n    println(renderTree())    // Hierarchical tree view\n    println(renderSummary()) // Compact summary\n\n    val failedSpans = getFailedSpans()\n    val totalDuration = getTotalDuration()\n    val span = findSpanByName(\"OrderService.process\")\n\n    // Wait for spans to arrive before asserting (useful for async flows)\n    waitForSpans(expectedCount = 5, timeoutMs = 3000)\n}\n</code></pre>"},{"location":"Components/15-tracing/#real-world-example","title":"Real-World Example","text":"<p>Here's a realistic scenario: an HTTP request triggers order processing, which publishes a Kafka event, which is consumed and writes to the database.</p> <pre><code>test(\"should create order and notify downstream services\") {\n    stove {\n        val orderId = UUID.randomUUID().toString()\n\n        // 1. Create order via HTTP\n        http {\n            post&lt;OrderResponse&gt;(\"/orders\", CreateOrderRequest(orderId, amount = 99.99)) { response -&gt;\n                response.status shouldBe \"created\"\n            }\n        }\n\n        // 2. Verify Kafka event was published\n        kafka {\n            shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n                actual.orderId == orderId\n            }\n        }\n\n        // 3. Verify database state\n        postgresql {\n            shouldQuery&lt;Order&gt;(\"SELECT * FROM orders WHERE id = '$orderId'\") { orders -&gt;\n                orders.size shouldBe 1\n                orders.first().status shouldBe \"CREATED\"\n            }\n        }\n\n        // 4. Verify the execution flow\n        tracing {\n            shouldContainSpan(\"OrderController.create\")\n            shouldContainSpan(\"OrderService.processOrder\")\n            shouldContainSpan(\"orders.created publish\")\n            shouldNotHaveFailedSpans()\n        }\n    }\n}\n</code></pre> <p>If any step fails, the trace tree shows you exactly where and why:</p> <pre><code>\u2713 POST (250ms)\n  \u2713 POST /orders (245ms)\n    \u2713 OrderController.create [120ms]\n    \u251c\u2500\u2500 \u2713 OrderService.processOrder [115ms]\n    \u2502   \u251c\u2500\u2500 \u2713 INSERT INTO orders [15ms]\n    \u2502   \u2502   \u2514\u2500\u2500 db.system: postgresql\n    \u2502   \u2514\u2500\u2500 \u2713 KafkaProducer.send [90ms]\n    \u2502       \u2514\u2500\u2500 \u2713 orders.created publish [45ms]\n    \u2502           \u2514\u2500\u2500 \u2713 orders.created process [40ms]\n    \u2502               \u2514\u2500\u2500 \u2713 UPDATE orders SET status='CREATED' [8ms]\n\nSummary: 8 spans, 0 failures, total: 250ms\n</code></pre> <p>Working example</p> <p>For a complete working project with tracing, see the spring-showcase recipe.</p>"},{"location":"Components/15-tracing/#configuration-reference","title":"Configuration Reference","text":""},{"location":"Components/15-tracing/#stove-test-config","title":"Stove Test Config","text":"<p>Configure tracing behavior in your Stove setup:</p> <pre><code>tracing {\n    enableSpanReceiver()              // Required: starts the span receiver\n    spanCollectionTimeout(10.seconds) // How long to wait for spans (default: 5s)\n    maxSpansPerTrace(2000)            // Cap spans per trace (default: 1000)\n    spanFilter { span -&gt;              // Filter which spans are collected\n        !span.operationName.contains(\"health-check\")\n    }\n}\n</code></pre> Option Default Description <code>enableSpanReceiver(port?)</code> Port from <code>STOVE_TRACING_PORT</code> env or <code>4317</code> Starts the OTLP gRPC receiver <code>spanCollectionTimeout</code> <code>5.seconds</code> How long to wait for spans when building failure reports <code>maxSpansPerTrace</code> <code>1000</code> Maximum spans stored per trace (prevents memory issues) <code>spanFilter</code> Accept all Predicate to filter which spans are collected"},{"location":"Components/15-tracing/#gradle-plugin","title":"Gradle Plugin","text":"<p>The Stove Tracing Gradle plugin configures the OpenTelemetry Java Agent for your test tasks. It is published to both the Gradle Plugin Portal and Maven Central.</p> Gradle Plugin PortalMaven Central <pre><code>plugins {\n    id(\"com.trendyol.stove.tracing\") version \"&lt;stove-version&gt;\"\n}\n</code></pre> <p>If your project resolves plugins from Maven Central (e.g., for snapshot versions), add the Maven Central snapshot repository to your <code>pluginManagement</code> block:</p> <pre><code>// settings.gradle.kts\npluginManagement {\n    repositories {\n        gradlePluginPortal()\n        mavenCentral()\n        maven(\"https://central.sonatype.com/repository/maven-snapshots\")\n    }\n}\n</code></pre> <p>Then apply normally:</p> <pre><code>plugins {\n    id(\"com.trendyol.stove.tracing\") version \"&lt;stove-snapshot-version&gt;\"\n}\n</code></pre> <p>Configure the plugin in your <code>build.gradle.kts</code>:</p> <pre><code>stoveTracing {\n    serviceName.set(\"my-service\")\n    testTaskNames.set(listOf(\"integrationTest\")) // Only apply to specific tasks\n    disabledInstrumentations.set(listOf(\"jdbc\"))  // Exclude noisy instrumentations\n}\n</code></pre> Option Default Description <code>serviceName</code> <code>\"stove-traced-app\"</code> Service name shown in traces <code>enabled</code> <code>true</code> Toggle tracing on/off <code>protocol</code> <code>\"grpc\"</code> OTLP protocol (currently only <code>grpc</code> is supported) <code>testTaskNames</code> <code>[]</code> Apply only to specific test tasks (empty = all) <code>otelAgentVersion</code> <code>\"2.24.0\"</code> OpenTelemetry Java Agent version <code>captureHttpHeaders</code> <code>true</code> Include HTTP headers in spans <code>captureExperimentalTelemetry</code> <code>true</code> Enable experimental HTTP telemetry <code>disabledInstrumentations</code> <code>[]</code> Instrumentations to disable (e.g., <code>jdbc</code>, <code>hibernate</code>) <code>additionalInstrumentations</code> <code>[]</code> Extra instrumentations to enable <code>customAnnotations</code> <code>[]</code> Custom annotation classes to instrument <code>bspScheduleDelay</code> <code>100</code> Batch span processor delay in ms (lower = faster export) <code>bspMaxBatchSize</code> <code>1</code> Batch size for span export (1 = immediate) Alternative: buildSrc copy-paste approach <p>If you prefer not to use the plugin, copy <code>StoveTracingConfiguration.kt</code> to your project's <code>buildSrc/src/main/kotlin/</code> directory and use <code>stoveTracing { ... }</code> in your build script.</p> Alternative: Manual OTel agent setup <p>If you prefer full control, you can configure the agent manually:</p> <pre><code>// build.gradle.kts\nval otelAgent by configurations.creating { isTransitive = false }\n\ndependencies {\n    otelAgent(\"io.opentelemetry.javaagent:opentelemetry-javaagent:2.24.0\")\n}\n\ntasks.test {\n    doFirst {\n        jvmArgs(\n            \"-javaagent:${otelAgent.singleFile.absolutePath}\",\n            \"-Dotel.traces.exporter=otlp\",\n            \"-Dotel.exporter.otlp.protocol=grpc\",\n            \"-Dotel.exporter.otlp.endpoint=http://localhost:4317\",\n            \"-Dotel.metrics.exporter=none\",\n            \"-Dotel.logs.exporter=none\",\n            \"-Dotel.service.name=my-service\",\n            \"-Dotel.propagators=tracecontext,baggage\",\n            \"-Dotel.traces.sampler=always_on\",\n            \"-Dotel.bsp.schedule.delay=100\",\n            \"-Dotel.bsp.max.export.batch.size=1\",\n            \"-Dotel.instrumentation.grpc.enabled=false\"\n        )\n    }\n}\n</code></pre>"},{"location":"Components/15-tracing/#best-practices","title":"Best Practices","text":"<ol> <li>Just enable it. Tracing is automatic and low-overhead; there's no reason not to use it</li> <li>Use <code>tracing { }</code> sparingly. The automatic failure reports cover most debugging needs; use the DSL only when you want to assert on the execution flow</li> <li>Start with <code>shouldNotHaveFailedSpans()</code>. The simplest assertion that catches unexpected errors</li> <li>Filter noise. If you see too many spans, use <code>disabledInstrumentations</code> to exclude verbose libraries like <code>jdbc</code> or <code>spring-scheduling</code></li> <li>CI just works. Ports are dynamically assigned, so parallel test runs don't conflict</li> </ol> <p>Works with Reporting</p> <p>Tracing integrates seamlessly with Stove's Reporting system. When both are enabled, test failures include the execution report and the trace tree together, giving you the complete picture.</p>"},{"location":"Components/15-tracing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Components/15-tracing/#no-trace-in-failure-reports","title":"No trace in failure reports","text":"<ol> <li>Ensure <code>stove-tracing</code> is in your dependencies</li> <li>Verify <code>enableSpanReceiver()</code> is called in your Stove config</li> <li>Verify the <code>com.trendyol.stove.tracing</code> plugin is applied in your <code>build.gradle.kts</code></li> <li>Look for \"Stove tracing: Attached OTel agent\" in test output</li> </ol>"},{"location":"Components/15-tracing/#too-many-spans","title":"Too many spans","text":"<p>Use <code>disabledInstrumentations</code> to exclude noisy libraries:</p> <pre><code>stoveTracing {\n    serviceName.set(\"my-service\")\n    disabledInstrumentations.set(listOf(\"jdbc\", \"hibernate\", \"spring-scheduling\"))\n}\n</code></pre>"},{"location":"Components/15-tracing/#spans-missing-parent-child-relationships","title":"Spans missing parent-child relationships","text":"<ol> <li>Ensure trace context is propagated through async boundaries</li> <li>Check that the OTel agent version is compatible with your framework version</li> </ol>"},{"location":"Components/16-mysql/","title":"MySQL","text":"Gradle <pre><code>    dependencies {\n        testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n        testImplementation(\"com.trendyol:stove-mysql\")\n    }\n</code></pre>"},{"location":"Components/16-mysql/#configure","title":"Configure","text":"<p>Once you've added the dependency, you can configure MySQL in your Stove setup:</p> <pre><code>Stove()\n  .with {\n    mysql {\n      MySqlOptions {\n        listOf(\n          \"mysql.jdbcUrl=${it.jdbcUrl}\",\n          \"mysql.host=${it.host}\",\n          \"mysql.port=${it.port}\",\n          \"mysql.username=${it.username}\",\n          \"mysql.password=${it.password}\"\n        )\n      }\n    }\n  }.run()\n</code></pre> <p>The <code>it</code> reference gives you access to the MySQL container's connection details, which you can pass to your application.</p>"},{"location":"Components/16-mysql/#migrations","title":"Migrations","text":"<p>Stove provides a way to run database migrations before tests start:</p> <pre><code>class InitialMigration : DatabaseMigration&lt;MySqlMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: MySqlMigrationContext) {\n    connection.operations.execute(\n      \"\"\"\n      CREATE TABLE IF NOT EXISTS users (\n        id INT AUTO_INCREMENT PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        email VARCHAR(100) NOT NULL UNIQUE,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n      \"\"\".trimIndent()\n    )\n  }\n}\n</code></pre> <p>Register migrations in your Stove configuration:</p> <pre><code>Stove()\n  .with {\n    mysql {\n      MySqlOptions(\n        databaseName = \"testing\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      ).migrations {\n        register&lt;InitialMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/16-mysql/#usage","title":"Usage","text":""},{"location":"Components/16-mysql/#executing-sql","title":"Executing SQL","text":"<p>Execute DDL and DML statements with <code>shouldExecute</code>:</p> <pre><code>stove {\n  mysql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      DROP TABLE IF EXISTS products;\n      CREATE TABLE IF NOT EXISTS products (\n        id INT AUTO_INCREMENT PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        price DECIMAL(10, 2) NOT NULL,\n        stock INT DEFAULT 0\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert data\n    shouldExecute(\n      \"\"\"\n      INSERT INTO products (name, price, stock)\n      VALUES ('Laptop', 999.99, 10)\n      \"\"\".trimIndent()\n    )\n\n    // Update data\n    shouldExecute(\"UPDATE products SET stock = 5 WHERE name = 'Laptop'\")\n\n    // Delete data\n    shouldExecute(\"DELETE FROM products WHERE stock = 0\")\n  }\n}\n</code></pre>"},{"location":"Components/16-mysql/#querying-data","title":"Querying Data","text":"<p>Query data with type-safe mappers:</p> <pre><code>data class Product(\n  val id: Long,\n  val name: String,\n  val price: Double,\n  val stock: Int\n)\n\nstove {\n  mysql {\n    shouldQuery&lt;Product&gt;(\n      query = \"SELECT * FROM products WHERE price &gt; 500\",\n      mapper = { row -&gt;\n        Product(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          price = row.double(\"price\"),\n          stock = row.int(\"stock\")\n        )\n      }\n    ) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.price &gt; 500 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/16-mysql/#query-with-parameters","title":"Query with Parameters","text":"<p>Use parameterized queries for safety:</p> <pre><code>stove {\n  mysql {\n    val minPrice = 100.0\n    shouldQuery&lt;Product&gt;(\n      query = \"SELECT * FROM products WHERE price &gt;= ?\",\n      mapper = { row -&gt;\n        Product(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          price = row.double(\"price\"),\n          stock = row.int(\"stock\")\n        )\n      }\n    ) { products -&gt;\n      products.all { it.price &gt;= minPrice } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/16-mysql/#working-with-nullable-fields","title":"Working with Nullable Fields","text":"<p>Handle nullable columns:</p> <pre><code>data class User(\n  val id: Long,\n  val name: String,\n  val email: String?,\n  val phone: String?\n)\n\nstove {\n  mysql {\n    shouldQuery&lt;User&gt;(\n      query = \"SELECT * FROM users\",\n      mapper = { row -&gt;\n        User(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          email = row.stringOrNull(\"email\"),\n          phone = row.stringOrNull(\"phone\")\n        )\n      }\n    ) { users -&gt;\n      users.size shouldBeGreaterThan 0\n    }\n  }\n}\n</code></pre>"},{"location":"blog/tracing-0.21.0/","title":"Execution Tracing in Stove 0.21.0","text":"<p>If you've spent any time debugging e2e test failures, you know the routine. The test says \"expected 201 but was 500\" and you're left reverse-engineering what actually happened. Did the request reach the controller? Did the database reject the write? Did a downstream service return something unexpected? You open the logs, grep for request IDs, cross-reference timestamps, and eventually piece together the story. Twenty minutes later, you have an answer.</p> <p>The fundamental problem is that e2e tests treat the application as a black box. They can tell you the output was wrong, but they have no visibility into the execution path that produced it. For simple flows that's fine. For a request that touches a gRPC service, two REST APIs, a database, and a Kafka topic before returning a response, it's a real productivity drain. In a microservice architecture with multiple integration points, this kind of failure can easily take 30 minutes to diagnose. Multiply that by every flaky test in your CI pipeline, and the cost adds up fast.</p> <p>Stove 0.21.0 introduces execution tracing to address this. When a test fails, you get the entire call chain of your application: every controller method, every database query, every Kafka message, every HTTP call, with timing and the exact point of failure. The bug might be buried deep in the persistence layer, but the trace pinpoints it without a single grep.</p>"},{"location":"blog/tracing-0.21.0/#stove-in-30-seconds","title":"Stove in 30 Seconds","text":"<p>For those new to Stove: it's an end-to-end testing framework for the JVM. It spins up your real application with real dependencies (PostgreSQL, Kafka, MongoDB, Redis, etc. via Testcontainers) and gives you a unified Kotlin DSL for assertions across all of them. It works with Spring Boot, Ktor, Micronaut, and Quarkus. Tests can be written in Kotlin, Java, or Scala.</p> <p>The key idea: test your entire application stack as it runs in production, not a stripped-down mock version.</p>"},{"location":"blog/tracing-0.21.0/#a-real-application-the-spring-showcase","title":"A Real Application: The Spring Showcase","text":"<p>To demonstrate tracing, let's walk through a realistic application. The spring-showcase recipe is an order service that touches six different integration points during a single request:</p> <pre><code>flowchart LR\n    A[\"HTTP POST /api/orders\"] --&gt; B[OrderService]\n    B --&gt; C[\"Fraud Detection (gRPC)\"]\n    B --&gt; D[\"Inventory Check (REST)\"]\n    B --&gt; E[\"Payment (REST)\"]\n    B --&gt; F[\"PostgreSQL - Save Order\"]\n    B --&gt; G[\"Kafka - Publish Events\"]\n    B --&gt; H[\"db-scheduler - Schedule Email\"]</code></pre> <p>Here's the service code. Each method is annotated with <code>@WithSpan</code> so the OpenTelemetry agent captures it:</p> <pre><code>@Service\nclass OrderService(\n  private val orderRepository: OrderRepository,\n  private val inventoryClient: InventoryClient,\n  private val paymentClient: PaymentClient,\n  private val fraudDetectionClient: FraudDetectionClient,\n  private val eventPublisher: OrderEventPublisher,\n  private val emailSchedulerService: EmailSchedulerService\n) {\n  @WithSpan(\"OrderService.createOrder\")\n  suspend fun createOrder(userId: String, productId: String, amount: Double): Order {\n    // Step 1: Check fraud via gRPC\n    checkFraudViaGrpc(orderId, userId, amount, productId)\n\n    // Step 2: Check inventory via REST\n    checkInventoryViaRest(productId)\n\n    // Step 3: Process payment via REST\n    val payment = processPaymentViaRest(userId, amount)\n\n    // Step 4: Save to database\n    val savedOrder = saveOrderToDatabase(orderId, userId, productId, amount, payment.transactionId!!)\n\n    // Step 5: Publish events to Kafka\n    publishEventsToKafka(savedOrder, payment.transactionId)\n\n    // Step 6: Schedule confirmation email\n    scheduleConfirmationEmail(savedOrder)\n\n    return savedOrder\n  }\n}\n</code></pre> <p>And here's how the Stove test covers the entire flow in a single test:</p> <pre><code>test(\"The Complete Order Flow - Every Feature in One Test\") {\n  stove {\n    // 1. Mock the external gRPC service (Fraud Detection)\n    grpcMock {\n      mockUnary(\n        serviceName = \"frauddetection.FraudDetectionService\",\n        methodName = \"CheckFraud\",\n        response = CheckFraudResponse.newBuilder()\n          .setIsFraudulent(false)\n          .setRiskScore(0.15)\n          .build()\n      )\n    }\n\n    // 2. Mock the external REST APIs (Inventory + Payment)\n    wiremock {\n      mockGet(url = \"/inventory/$productId\", statusCode = 200,\n        responseBody = InventoryResponse(productId, available = true, quantity = 10).some())\n      mockPost(url = \"/payments/charge\", statusCode = 200,\n        responseBody = PaymentResult(success = true, transactionId = \"txn-123\", amount = amount).some())\n    }\n\n    // 3. Call our API\n    http {\n      postAndExpectBody&lt;OrderResponse&gt;(uri = \"/api/orders\",\n        body = CreateOrderRequest(userId, productId, amount).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().status shouldBe \"CONFIRMED\"\n      }\n    }\n\n    // 4. Verify database state\n    postgresql {\n      shouldQuery&lt;OrderRow&gt;(\n        query = \"SELECT * FROM orders WHERE user_id = '$userId'\",\n        mapper = { row -&gt; OrderRow(/* ... */) }\n      ) { orders -&gt;\n        orders.size shouldBe 1\n        orders.first().status shouldBe \"CONFIRMED\"\n      }\n    }\n\n    // 5. Verify Kafka events\n    kafka {\n      shouldBePublished&lt;OrderCreatedEvent&gt; {\n        actual.userId == userId &amp;&amp; actual.productId == productId\n      }\n      shouldBePublished&lt;PaymentProcessedEvent&gt; {\n        actual.amount == amount &amp;&amp; actual.success\n      }\n    }\n\n    // 6. Verify the consumer updated the read model (CQRS)\n    kafka {\n      shouldBeConsumed&lt;OrderCreatedEvent&gt; {\n        actual.userId == userId\n      }\n    }\n\n    // 7. Test our gRPC server\n    grpc {\n      channel&lt;OrderQueryServiceCoroutineStub&gt; {\n        val order = getOrder(GetOrderRequest.newBuilder().setOrderId(orderId!!).build())\n        order.found shouldBe true\n      }\n    }\n\n    // 8. Verify scheduled tasks\n    tasks {\n      shouldBeExecuted&lt;OrderEmailPayload&gt; {\n        this.orderId == orderId &amp;&amp; this.userId == userId\n      }\n    }\n  }\n}\n</code></pre> <p>One test covering eight integration points against real infrastructure.</p>"},{"location":"blog/tracing-0.21.0/#setting-up-tracing","title":"Setting Up Tracing","text":"<p>Tracing takes two configuration steps.</p>"},{"location":"blog/tracing-0.21.0/#step-1-enable-in-your-stove-config","title":"Step 1: Enable in your Stove config","text":"<pre><code>Stove()\n  .with {\n    tracing {\n      enableSpanReceiver()\n    }\n    // ... your other systems (http, kafka, postgresql, etc.)\n  }\n  .run()\n</code></pre>"},{"location":"blog/tracing-0.21.0/#step-2-attach-the-opentelemetry-agent-in-your-build","title":"Step 2: Attach the OpenTelemetry agent in your build","text":"<p>Copy <code>StoveTracingConfiguration.kt</code> to your project's <code>buildSrc/src/main/kotlin/</code> directory, then add to your <code>build.gradle.kts</code>:</p> <pre><code>import com.trendyol.stove.gradle.stoveTracing\n\nstoveTracing {\n  serviceName = \"my-service\"\n  testTaskNames = listOf(\"e2eTest\") // optional: scope to specific test tasks\n}\n</code></pre> <p>This handles downloading the OpenTelemetry Java Agent, configuring JVM arguments, attaching the agent to your test tasks, and dynamically assigning ports so parallel test runs don't conflict.</p> <p>Gradle Plugin available since 0.21.2</p> <p>Starting with 0.21.2, a standalone Gradle plugin is available that eliminates the need to copy this file. See the 0.21.2 release notes for details.</p> <p>No code changes to your application are needed. The OpenTelemetry agent instruments 100+ libraries (Spring, JDBC, Kafka, gRPC, HTTP clients, Redis, MongoDB, and more) automatically. The <code>@WithSpan</code> annotations are optional. They add your own method-level spans on top of what the agent already captures.</p>"},{"location":"blog/tracing-0.21.0/#what-happens-when-a-test-fails","title":"What Happens When a Test Fails","text":"<p>To see this in practice, we ran the spring-showcase with a bug deliberately injected in the persistence layer: a validation that rejects orders over $1000. The test output included the full execution report:</p> <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                        STOVE TEST EXECUTION REPORT\n\n Test: The Complete Order Flow - Every Feature in One Test\n ID:   TheShowcase::The Complete Order Flow - Every Feature in One Test\n Status: FAILED\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n TIMELINE\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n 17:27:22.298 \u2713 PASSED [gRPC Mock] Register unary stub: FraudDetectionService/CheckFraud\n     Output: risk_score: 0.15 reason: \"low_risk_user\"\n\n 17:27:22.335 \u2713 PASSED [WireMock] Register stub: GET /inventory/macbook-pro-16\n     Metadata: {statusCode=200}\n\n 17:27:22.341 \u2713 PASSED [WireMock] Register stub: POST /payments/charge\n     Metadata: {statusCode=200}\n\n 17:27:25.092 \u2717 FAILED [HTTP] POST /api/orders\n     Input:  CreateOrderRequest(userId=user-4b9bb522, productId=macbook-pro-16, amount=2499.99)\n     Output: {\"message\":\"Internal server error\",\"errorCode\":\"INTERNAL_ERROR\"}\n     Metadata: {status=500}\n     Expected: Response&lt;OrderResponse&gt; matching expectation\n     Error: expected:&lt;201&gt; but was:&lt;500&gt;\n\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n SYSTEM SNAPSHOTS\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n \u250c\u2500 GRPC MOCK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   Registered stubs: 1\n   Received requests: 1\n   Matched requests: 1\n\n \u250c\u2500 WIREMOCK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   Registered stubs (this test): 2\n   Served requests (this test): 2 (matched: 2)\n\n \u250c\u2500 KAFKA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   Consumed: 0\n   Published: 0\n   Failed: 0\n\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550</code></pre> <p>The report is structured in two parts. First, a timeline of every test step showing what passed and what failed. Then, a snapshot of each system's state at the moment of failure. You can already read the situation: the gRPC mock matched its request, WireMock served both stubs successfully, but Kafka has zero messages. The application crashed before it could publish any events.</p> <p>Below the report, the execution trace shows what happened inside the application:</p> <pre><code>\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nEXECUTION TRACE (Call Chain)\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n\u2713 POST /api/orders [250ms]\n\u251c\u2500\u2500 \u2713 OrderService.createOrder [245ms]\n\u2502   \u251c\u2500\u2500 \u2713 OrderService.checkFraudViaGrpc [30ms]\n\u2502   \u2502   \u2514\u2500\u2500 \u2713 FraudDetectionClient.checkFraud [25ms]\n\u2502   \u251c\u2500\u2500 \u2713 OrderService.checkInventoryViaRest [40ms]\n\u2502   \u2502   \u2514\u2500\u2500 http.url: http://localhost:54648/inventory/macbook-pro-16\n\u2502   \u251c\u2500\u2500 \u2713 OrderService.processPaymentViaRest [35ms]\n\u2502   \u2502   \u2514\u2500\u2500 http.url: http://localhost:54648/payments/charge\n\u2502   \u251c\u2500\u2500 \u2717 OrderService.saveOrderToDatabase [8ms]  \u25c4\u2500\u2500 FAILURE POINT\n\u2502   \u2502   \u2514\u2500\u2500 \u2717 PostgresOrderRepository.save [5ms]\n\u2502   \u2502       \u2502  Error: OrderPersistenceException\n\u2502   \u2502       \u2502  Message: Failed to persist order: amount exceeds internal threshold\n\u2502   \u2502       \u2502    at PostgresOrderRepository.validateOrderAmount(PostgresOrderRepository.kt:102)\n\u2502   \u2502       \u2514\u2500\u2500 db.system: postgresql</code></pre> <p>The fraud, inventory, and payment steps all passed. The failure happened in <code>OrderService.saveOrderToDatabase</code>, specifically in <code>PostgresOrderRepository.save</code>, with the exception type, message, and stack trace right there. Without tracing, this would have been a 500 error with no context. With tracing, the root cause is immediately visible.</p>"},{"location":"blog/tracing-0.21.0/#automatic-trace-propagation","title":"Automatic Trace Propagation","text":"<p>Stove injects trace headers into every outgoing interaction without any test code changes:</p> <ul> <li>HTTP requests get a <code>traceparent</code> header</li> <li>Kafka messages get trace headers</li> <li>gRPC calls get trace metadata</li> </ul> <p>This is visible in the actual test output. The HTTP request sent by Stove:</p> <pre><code>REQUEST: http://localhost:8024/api/orders\nMETHOD: POST\nHEADERS:\n  Accept: application/json\n  X-Stove-Test-Id: TheShowcase::The Complete Order Flow - Every Feature in One Test\n  traceparent: 00-475e686523af0b4ee0433f91a69a6b55-81edd5ba7e4dec42-01\n</code></pre> <p>And the WireMock request log confirming the propagation reached the downstream call:</p> <pre><code>Request received:\n127.0.0.1 - GET /inventory/macbook-pro-16\n  traceparent: [00-475e686523af0b4ee0433f91a69a6b55-e3f138ac02509a0b-01]\n</code></pre> <p>Same trace ID (<code>475e686523af0b4ee0433f91a69a6b55</code>), different span ID. The entire call chain is correlated.</p>"},{"location":"blog/tracing-0.21.0/#per-test-trace-isolation","title":"Per-Test Trace Isolation","text":"<p>A critical detail: every test gets its own trace. Stove generates a unique trace ID at the start of each test and injects it into every outgoing interaction. All spans collected during that test are correlated back to that trace ID and that test alone.</p> <p>This means traces from concurrent or sequential tests never bleed into each other. When a test fails, the execution trace shows only what happened during that specific test, not spans from a previous test that happened to use the same Kafka topic or a background job triggered by an earlier request.</p> <p>This is not something you get for free with OpenTelemetry. In production, a trace starts when a request enters the system. In testing, there's no natural entry point. Stove creates one. It manages the W3C trace context lifecycle (start, propagate, end) per test, ties it to the test identity (<code>X-Stove-Test-Id</code> header), and ensures the OTLP receiver maps incoming spans to the correct test. The result is that tracing in Stove is deterministic and test-scoped, not a sampling-based best-effort like production tracing.</p>"},{"location":"blog/tracing-0.21.0/#trace-validation-dsl","title":"Trace Validation DSL","text":"<p>Beyond automatic failure reports, you can actively assert on the execution flow using the <code>tracing { }</code> DSL. This is useful when you want to verify how your application handled a request, not just that it produced the right output:</p> <pre><code>test(\"order processing should call all expected services\") {\n  stove {\n    http {\n      postAndExpectBody&lt;OrderResponse&gt;(\"/api/orders\", request.some()) { response -&gt;\n        response.status shouldBe 201\n      }\n    }\n\n    tracing {\n      // Verify which operations happened\n      shouldContainSpan(\"OrderService.createOrder\")\n      shouldContainSpan(\"OrderService.checkFraudViaGrpc\")\n      shouldContainSpan(\"OrderService.checkInventoryViaRest\")\n      shouldContainSpan(\"PostgresOrderRepository.save\")\n\n      // Verify no operations failed\n      shouldNotHaveFailedSpans()\n\n      // Performance assertions\n      executionTimeShouldBeLessThan(500.milliseconds)\n\n      // Attribute assertions\n      shouldHaveSpanWithAttribute(\"db.system\", \"postgresql\")\n\n      // Debugging helpers\n      println(renderTree())    // Print the hierarchical tree\n      println(renderSummary()) // Print compact summary\n    }\n  }\n}\n</code></pre> <p>The DSL supports:</p> <ul> <li>Span assertions: <code>shouldContainSpan()</code>, <code>shouldNotContainSpan()</code>, <code>shouldContainSpanMatching()</code></li> <li>Failure assertions: <code>shouldNotHaveFailedSpans()</code>, <code>shouldHaveFailedSpan()</code></li> <li>Performance assertions: <code>executionTimeShouldBeLessThan()</code>, <code>spanCountShouldBeAtLeast()</code></li> <li>Attribute assertions: <code>shouldHaveSpanWithAttribute()</code>, <code>shouldHaveSpanWithAttributeContaining()</code></li> <li>Query methods: <code>findSpanByName()</code>, <code>getFailedSpans()</code>, <code>getTotalDuration()</code></li> <li>Async support: <code>waitForSpans(expectedCount, timeoutMs)</code> for async flows</li> </ul>"},{"location":"blog/tracing-0.21.0/#how-it-works","title":"How It Works","text":"<pre><code>sequenceDiagram\n    participant Test as Stove Test\n    participant App as Application\n    participant OTel as OTel Agent\n    participant Receiver as OTLP Receiver\n    participant Report as Report Builder\n\n    Test-&gt;&gt;App: HTTP POST with traceparent\n    OTel-&gt;&gt;OTel: Instrument libraries\n    App-&gt;&gt;App: Process request\n    OTel-&gt;&gt;Receiver: Export spans via OTLP gRPC\n    Receiver-&gt;&gt;Receiver: Correlate spans by trace ID\n\n    alt Test passes\n        Test-&gt;&gt;Test: Traces available via DSL\n    else Test fails\n        Report-&gt;&gt;Receiver: Query spans for this test\n        Report-&gt;&gt;Report: Build report + trace tree\n        Report-&gt;&gt;Test: Display combined report\n    end</code></pre> <p>The architecture:</p> <ol> <li>OpenTelemetry Java Agent attaches to your application process (configured via Gradle) and instruments 100+ libraries without code changes</li> <li>Stove starts an OTLP gRPC receiver on a dynamically assigned port that collects spans exported by the agent</li> <li>W3C <code>traceparent</code> headers are injected into every HTTP, Kafka, and gRPC interaction, correlating all spans back to the originating test</li> <li>On test failure, the report builder queries the collected spans, builds a hierarchical tree, and renders it alongside the execution report</li> <li>Ports are dynamically assigned so parallel test runs on CI don't conflict</li> </ol> <p>Worth noting: the OTel agent does add some startup overhead to the test JVM (a few seconds). For most e2e test suites that spin up Testcontainers, this is negligible relative to container startup time. If it matters, tracing can be toggled off with <code>enabled = false</code> in the Gradle config.</p>"},{"location":"blog/tracing-0.21.0/#practical-advice","title":"Practical Advice","text":"<ol> <li>Enable tracing by default. The overhead is minimal compared to container startup, and the diagnostic value on failure is significant.</li> <li>Use <code>tracing { }</code> sparingly. The automatic failure reports cover most debugging needs. Reserve the DSL for cases where you want to assert on the execution flow itself, for example verifying that a cache was hit instead of the database.</li> <li>Start with <code>shouldNotHaveFailedSpans()</code>. The simplest assertion that catches unexpected errors anywhere in the call chain.</li> <li>Filter noisy instrumentations. Some libraries generate a lot of spans. Tune with <code>disabledInstrumentations</code>:</li> </ol> <pre><code>stoveTracing {\n  serviceName = \"my-service\"\n  disabledInstrumentations = listOf(\"jdbc\", \"hibernate\", \"spring-scheduling\")\n}\n</code></pre>"},{"location":"blog/tracing-0.21.0/#getting-started","title":"Getting Started","text":"<p>Add the dependencies:</p> <pre><code>dependencies {\n  testImplementation(platform(\"com.trendyol:stove-bom:0.21.0\"))\n\n  testImplementation(\"com.trendyol:stove\")\n  testImplementation(\"com.trendyol:stove-spring\")       // or stove-ktor, stove-micronaut\n  testImplementation(\"com.trendyol:stove-tracing\")\n  testImplementation(\"com.trendyol:stove-extensions-kotest\") // or stove-extensions-junit\n  // Add components as needed: stove-postgres, stove-kafka, stove-http, etc.\n}\n</code></pre> <p>Enable tracing in two steps:</p> <pre><code>// build.gradle.kts\nimport com.trendyol.stove.gradle.stoveTracing\n\nstoveTracing {\n  serviceName = \"my-service\"\n}\n\n// Stove config\ntracing {\n  enableSpanReceiver()\n}\n</code></pre> <p>For a complete working example, see the spring-showcase recipe. It demonstrates all Stove features together (HTTP, gRPC, Kafka, PostgreSQL, WireMock, db-scheduler, and tracing) in a realistic Spring Boot application.</p> <p>Links:</p> <ul> <li>Stove on GitHub</li> <li>Tracing documentation</li> <li>Spring Showcase recipe</li> <li>Full 0.21.0 release notes</li> <li>Getting started guide</li> </ul>"},{"location":"release-notes/0.15.0/","title":"0.15.0","text":""},{"location":"release-notes/0.15.0/#from-014x-to-015x","title":"From 0.14.x to 0.15.x","text":""},{"location":"release-notes/0.15.0/#breaking-changes","title":"Breaking Changes","text":"<p>The most notable breaking change is ser/de operations. The framework was only relying on Jackson for serialization and deserialization. Now, it provides a way to use other serialization libraries. <code>StoveSerde&lt;TIn, TOut&gt;</code> is the new interface that you can implement to provide your own serialization and deserialization logic.</p> <p><code>StoveSerde</code> also provides the access to the other serializers that <code>com-trendyol:stove-testing-e2e</code> package has:</p> <ul> <li>Jackson</li> <li>Gson</li> <li>Kotlinx</li> </ul> <p>Also look at ser/de section: Serialization and Deserialization</p>"},{"location":"release-notes/0.15.0/#spring-kafka-com-trendyolstove-spring-testing-e2e-kafka","title":"Spring Kafka (com-trendyol:stove-spring-testing-e2e-kafka)","text":"<p>The <code>TestSystemKafkaInterceptor</code> now depends on <code>StoveSerde</code> to provide the serialization and deserialization logic instead of <code>ObjectMapper</code>.</p> <p>You can of course use your default Jackson implementation by providing the <code>ObjectMapperConfig.default()</code> to the <code>StoveSerde.jackson.anyByteArraySerde</code> function.</p> <pre><code>class TestSystemInitializer : BaseApplicationContextInitializer({\n  bean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;(isPrimary = true)\n  bean { StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfig.default()) } // or any other serde that is &lt;Any, ByteArray&gt;\n})\n</code></pre>"},{"location":"release-notes/0.15.0/#standalone-kafka","title":"Standalone Kafka","text":"<pre><code>kafka {\n  KafkaSystemOptions(\n    serde = StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfig.default) // or any other serde that is &lt;Any, ByteArray&gt;\n    //...\n  )\n}\n</code></pre>"},{"location":"release-notes/0.15.0/#couchbase","title":"Couchbase","text":"<pre><code>couchbase {\n  CouchbaseSystemOptions(\n    clusterSerDe = JacksonJsonSerializer(CouchbaseConfiguration.objectMapper), // here you can provide your own serde\n    //...\n  )\n}\n</code></pre>"},{"location":"release-notes/0.15.0/#http","title":"Http","text":"<pre><code> httpClient {\n  HttpClientSystemOptions(\n    baseUrl = \"http://localhost:8001\",\n    contentConverter = JacksonConverter(ObjectMapperConfig.default)\n  )\n}\n</code></pre>"},{"location":"release-notes/0.15.0/#wiremock","title":"Wiremock","text":"<pre><code>wiremock {\n  WireMockSystemOptions(\n    port = 9090,\n    serde = StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfiguration.default)\n  )\n</code></pre>"},{"location":"release-notes/0.15.0/#elasticsearch","title":"Elasticsearch","text":"<pre><code>elasticsearch {\n  ElasticsearchSystemOptions(\n    jsonpMapper = JacksonJsonpMapper(StoveSerde.jackson.default), // or any JsonpMapper\n  )\n}\n</code></pre>"},{"location":"release-notes/0.15.0/#mongodb","title":"Mongodb","text":"<pre><code>mongodb {\n  MongoDbSystemOptions(\n    serde = StoveSerde.jackson.default // or any other serde that you implement\n  )\n}\n</code></pre> <p>The default serde is: <pre><code>  val serde: StoveSerde&lt;Any, String&gt; = StoveSerde.jackson.anyJsonStringSerde(\n    StoveSerde.jackson.byConfiguring {\n      disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n      enable(MapperFeature.DEFAULT_VIEW_INCLUSION)\n      addModule(ObjectIdModule())\n      addModule(KotlinModule.Builder().build())\n    }\n  ),\n</code></pre></p>"},{"location":"release-notes/0.19.0/","title":"0.19.0","text":"<p>Release Date: December 2025</p> <p>This release introduces gRPC support, WebSocket testing, and provided instances for external infrastructure:</p> <ul> <li>gRPC System: New component for testing gRPC APIs (grpc-kotlin, Wire)</li> <li>WebSocket Testing: Added to HTTP system for real-time communication testing</li> <li>Partial Mocking: WireMock now supports <code>mockPostContaining</code>, <code>mockPutContaining</code>, <code>mockPatchContaining</code></li> <li>Embedded Kafka: Run Kafka tests without Docker using <code>useEmbeddedKafka = true</code></li> <li>Provided Instances: PostgreSQL, MSSQL, MongoDB, Couchbase, Elasticsearch, Redis, and Kafka support connecting to external infrastructure</li> <li>Pause/Unpause: PostgreSQL, MSSQL, MongoDB, Couchbase, Elasticsearch, Redis, and Kafka support container pause/unpause for resilience testing</li> <li>Response Headers: WireMock mocks now support custom response headers</li> </ul>"},{"location":"release-notes/0.19.0/#new-features","title":"New Features","text":""},{"location":"release-notes/0.19.0/#grpc-support","title":"gRPC Support","text":"<p>Stove now supports testing gRPC APIs with a fluent DSL. The new <code>grpc</code> system works with multiple gRPC providers including grpc-kotlin, Wire, and standard gRPC stubs.</p> <pre><code>// Using typed channels (grpc-kotlin, Wire stubs)\ngrpc {\n    channel&lt;GreeterServiceStub&gt; {\n        val response = sayHello(HelloRequest(name = \"World\"))\n        response.message shouldBe \"Hello, World!\"\n    }\n}\n\n// Using Wire clients\ngrpc {\n    wireClient&lt;GreeterServiceClient&gt; {\n        val response = SayHello().execute(HelloRequest(name = \"World\"))\n        response.message shouldBe \"Hello, World!\"\n    }\n}\n</code></pre> <p>All streaming types work naturally with Kotlin coroutines:</p> <pre><code>grpc {\n    channel&lt;StreamServiceStub&gt; {\n        // Server streaming\n        serverStream(request).collect { response -&gt;\n            // assertions on each response\n        }\n\n        // Client streaming\n        val response = clientStream(flow { emit(request1); emit(request2) })\n\n        // Bidirectional streaming\n        bidiStream(requestFlow).collect { response -&gt;\n            // assertions\n        }\n    }\n}\n</code></pre> <p>Add the dependency:</p> <pre><code>testImplementation(\"com.trendyol:stove-testing-e2e-grpc:$version\")\n</code></pre>"},{"location":"release-notes/0.19.0/#websocket-testing","title":"WebSocket Testing","text":"<p>The HTTP system now supports WebSocket connections for testing real-time communication:</p> <pre><code>http {\n    webSocket(\"/chat\") { session -&gt;\n        session.send(\"Hello!\")\n        val response = session.receiveText()\n        response shouldBe \"Echo: Hello!\"\n    }\n}\n\n// With authentication\nhttp {\n    webSocket(\n        uri = \"/secure-chat\",\n        headers = mapOf(\"X-Custom-Header\" to \"value\"),\n        token = \"jwt-token\".some()\n    ) { session -&gt;\n        session.send(\"Authenticated message\")\n    }\n}\n\n// Collect multiple messages\nhttp {\n    webSocketExpect(\"/notifications\") { session -&gt;\n        val messages = session.collectTexts(count = 3)\n        messages.size shouldBe 3\n    }\n}\n</code></pre> <p>Available methods: - <code>webSocket</code> - Establish connection and interact - <code>webSocketExpect</code> - Assertion-focused testing - <code>webSocketRaw</code> - Direct access to underlying Ktor session</p>"},{"location":"release-notes/0.19.0/#partial-mocking-for-wiremock","title":"Partial Mocking for WireMock","text":"<p>New partial matching methods allow mocking requests by matching only specific fields in the request body:</p> <pre><code>wiremock {\n    // Match requests containing specific fields (ignores extra fields)\n    mockPostContaining(\n        url = \"/api/orders\",\n        requestContaining = mapOf(\n            \"productId\" to 123,\n            \"order.customer.id\" to \"cust-456\"  // Dot notation for nested fields\n        ),\n        statusCode = 201,\n        responseBody = OrderResponse(id = \"order-1\").some()\n    )\n}\n</code></pre> <p>Features: - AND logic: All specified fields must match - Dot notation: Access nested fields like <code>\"order.customer.id\"</code> - Partial objects: Nested objects match if they contain at least the specified fields - Methods: <code>mockPostContaining</code>, <code>mockPutContaining</code>, <code>mockPatchContaining</code></p>"},{"location":"release-notes/0.19.0/#embedded-kafka-mode","title":"Embedded Kafka Mode","text":"<p>Run Kafka tests without Docker containers using embedded Kafka:</p> <pre><code>kafka {\n    KafkaSystemOptions(\n        useEmbeddedKafka = true,  // No container needed\n        configureExposedConfiguration = { cfg -&gt;\n            listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n        }\n    )\n}\n</code></pre> <p>This is ideal for: - Self-contained integration tests - Faster test startup - Environments without Docker access</p>"},{"location":"release-notes/0.19.0/#improvements","title":"Improvements","text":""},{"location":"release-notes/0.19.0/#provided-instances-testcontainer-less-mode","title":"Provided Instances (Testcontainer-less Mode)","text":"<p>The following components now support connecting to externally managed infrastructure using the <code>provided()</code> companion function:</p> Component Provided Instance Support PostgreSQL \u2705 MSSQL \u2705 MongoDB \u2705 Couchbase \u2705 Elasticsearch \u2705 Redis \u2705 Kafka \u2705 <p>PostgreSQL example:</p> <pre><code>postgresql {\n    PostgresqlOptions.provided(\n        host = \"external-db.example.com\",\n        port = 5432,\n        databaseName = \"testdb\",\n        username = \"user\",\n        password = \"pass\",\n        runMigrations = true,\n        cleanup = { client -&gt; client.execute(\"TRUNCATE users\") },\n        configureExposedConfiguration = { cfg -&gt;\n            listOf(\"spring.datasource.url=${cfg.jdbcUrl}\")\n        }\n    )\n}\n</code></pre> <p>Kafka example:</p> <pre><code>kafka {\n    KafkaSystemOptions.provided(\n        bootstrapServers = \"kafka.example.com:9092\",\n        runMigrations = true,\n        cleanup = { admin -&gt; admin.deleteTopics(listOf(\"orders\")) },\n        configureExposedConfiguration = { cfg -&gt;\n            listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n        }\n    )\n}\n</code></pre> <p>This is useful for: - CI/CD pipelines with shared infrastructure - Reducing startup time by reusing existing instances - Lower memory/CPU usage by avoiding container overhead</p>"},{"location":"release-notes/0.19.0/#pauseunpause-containers","title":"Pause/Unpause Containers","text":"<p>PostgreSQL, MSSQL, MongoDB, Couchbase, Elasticsearch, Redis, and Kafka now support pausing and unpausing containers for testing resilience scenarios:</p> <pre><code>postgresql {\n    // Pause to simulate network issues\n    pause()\n\n    // Your application should handle the connection failure\n    http { get&lt;Response&gt;(\"/health\") { it.status shouldBe 503 } }\n\n    // Unpause to restore connectivity\n    unpause()\n}\n</code></pre>"},{"location":"release-notes/0.19.0/#response-headers-in-wiremock","title":"Response Headers in WireMock","text":"<p>WireMock now supports custom response headers:</p> <pre><code>wiremock {\n    mockGet(\n        url = \"/api/users/123\",\n        statusCode = 200,\n        responseBody = user.some(),\n        responseHeaders = mapOf(\n            \"X-Request-Id\" to \"req-123\",\n            \"X-Rate-Limit-Remaining\" to \"99\"\n        )\n    )\n}\n</code></pre>"},{"location":"release-notes/0.19.0/#documentation-improvements","title":"Documentation Improvements","text":"<ul> <li>Comprehensive documentation for all components</li> <li>Updated examples matching actual API signatures</li> <li>Added component feature matrix showing migration, cleanup, and provided instance support</li> <li>FAQ section with common questions and answers</li> </ul>"},{"location":"release-notes/0.19.0/#dependency-updates","title":"Dependency Updates","text":"<ul> <li>Kotlin 2.0.x</li> <li>Kotest 6.0.0.Mx</li> <li>Koin 4.x</li> <li>Arrow 2.x</li> <li>Testcontainers 2.x</li> <li>Ktor 3.x</li> <li>Various other dependency updates for security and compatibility</li> </ul>"},{"location":"release-notes/0.19.0/#migration-guide","title":"Migration Guide","text":""},{"location":"release-notes/0.19.0/#from-018x","title":"From 0.18.x","text":"<p>This release is backward compatible. New features are opt-in:</p> Feature How to Enable gRPC testing Add <code>stove-testing-e2e-grpc</code> dependency WebSocket testing Use <code>http { webSocket(\"/path\") { ... } }</code> Embedded Kafka Set <code>useEmbeddedKafka = true</code> in <code>KafkaSystemOptions</code> Provided instances Use <code>SystemOptions.provided(...)</code> instead of <code>SystemOptions(...)</code> Pause/Unpause Call <code>system.pause()</code> and <code>system.unpause()</code> on container-based systems Partial WireMock mocking Use <code>mockPostContaining</code>, <code>mockPutContaining</code>, <code>mockPatchContaining</code> Response headers Pass <code>responseHeaders = mapOf(...)</code> to WireMock mock methods"},{"location":"release-notes/0.19.0/#breaking-changes","title":"Breaking Changes","text":"<p>None in this release.</p>"},{"location":"release-notes/0.19.0/#full-changelog","title":"Full Changelog","text":"<p>See the GitHub Releases page for the complete list of commits and contributors.</p>"},{"location":"release-notes/0.19.0/#contributors","title":"Contributors","text":"<p>Thanks to all contributors who made this release possible!</p>"},{"location":"release-notes/0.19.0/#getting-started","title":"Getting Started","text":"<pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-testing-e2e:0.19.0\")\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:0.19.0\")  // or ktor, micronaut\n    // Add component-specific dependencies as needed\n    testImplementation(\"com.trendyol:stove-testing-e2e-rdbms-postgres:0.19.0\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-kafka:0.19.0\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-grpc:0.19.0\")  // NEW\n}\n</code></pre> <p>For snapshot versions, add the snapshot repository:</p> <pre><code>repositories {\n    maven(\"https://central.sonatype.com/repository/maven-snapshots\")\n}\n</code></pre>"},{"location":"release-notes/0.20.0/","title":"0.20.0","text":"<p>Release Date: January 2026</p> <p>This release introduces simplified module names, a new BOM, and a comprehensive test reporting system:</p> <ul> <li>Simplified Module Names: All modules renamed to remove <code>testing-e2e</code> suffix for cleaner artifact names</li> <li>New BOM (Bill of Materials): Centralized version management via <code>stove-bom</code></li> <li>Package Structure Simplification: Package names simplified from <code>com.trendyol.stove.testing.e2e.*</code> to <code>com.trendyol.stove.*</code></li> <li>Test Reporting System: Comprehensive reporting that tracks all actions and assertions during test execution</li> <li>Spring Boot 4.x Support: Full support for Spring Boot 4.x and Spring Kafka 4.x</li> <li>Unified Spring Modules: Single modules that work across Spring Boot 2.x, 3.x, and 4.x</li> <li>New Bean Registration DSL: <code>stoveSpring4xRegistrar</code> for Spring Boot 4.x (since <code>BeanDefinitionDsl</code> is deprecated)</li> <li>Runtime Version Checks: Clear error messages when Spring Boot/Kafka is missing from classpath</li> <li>Ktor DI Flexibility: Support for Koin, Ktor-DI, or custom resolvers</li> <li>Generic Type Resolution: <code>using&lt;List&lt;T&gt;&gt;</code> now works correctly with full generic type preservation</li> </ul>"},{"location":"release-notes/0.20.0/#new-features","title":"New Features","text":""},{"location":"release-notes/0.20.0/#test-reporting-system","title":"Test Reporting System","text":"<p>Stove now includes a built-in reporting system that captures everything that happens during your tests. When a test fails, you get a detailed report showing exactly what happened, making debugging much easier.</p> <p>Key capabilities:</p> <ul> <li>Automatic tracking of all system interactions (HTTP, Kafka, database, WireMock, gRPC)</li> <li>Test failure enrichment with detailed execution reports embedded in test output</li> <li>System snapshots showing internal state (Kafka messages, WireMock stubs) at the time of failure</li> <li>Multiple renderers - human-readable console output or machine-readable JSON</li> <li>Framework integration with both Kotest and JUnit</li> <li>Stack trace preservation - original stack traces are preserved in test failures</li> </ul>"},{"location":"release-notes/0.20.0/#quick-start-kotest","title":"Quick Start - Kotest","text":"<p>Add the extension dependency (optional but recommended):</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-extensions-kotest\")\n}\n</code></pre> <p>Then configure:</p> <pre><code>import com.trendyol.stove.extensions.kotest.StoveKotestExtension\nimport com.trendyol.stove.system.Stove\n\nclass TestConfig : AbstractProjectConfig() {\n    override val extensions: List&lt;Extension&gt; = listOf(StoveKotestExtension())\n\n    override suspend fun beforeProject() {\n        Stove()\n            .with { /* your configuration */ }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        Stove.stop()\n    }\n}\n</code></pre>"},{"location":"release-notes/0.20.0/#quick-start-junit","title":"Quick Start - JUnit","text":"<p>Add the extension dependency (optional but recommended):</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-extensions-junit\")\n}\n</code></pre> <p>Then configure:</p> <pre><code>import com.trendyol.stove.extensions.junit.StoveJUnitExtension\nimport org.junit.jupiter.api.extension.ExtendWith\n\n@ExtendWith(StoveJUnitExtension::class)\nclass MyE2ETest {\n    // your tests\n}\n</code></pre> <p>The JUnit extension works with both JUnit 5 and 6 since they share the Jupiter API.</p>"},{"location":"release-notes/0.20.0/#configuration","title":"Configuration","text":"<pre><code>Stove {\n    reporting {\n        enabled()           // Enable reporting (default: true)\n        dumpOnFailure()     // Dump report when tests fail (default: true)\n        failureRenderer(PrettyConsoleRenderer)  // Set the renderer\n    }\n}\n</code></pre>"},{"location":"release-notes/0.20.0/#example-output","title":"Example Output","text":"<p>When a test fails, you'll see output like:</p> <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                           STOVE TEST EXECUTION REPORT                        \u2551\n\u2551 Test: should save the product                                                \u2551\n\u2551 Status: FAILED                                                               \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 14:47:38.215 \u2713 PASSED [HTTP] POST /api/products                              \u2551\n\u2551     Input: {\"id\":1234,\"name\":\"Test Product\"}                                 \u2551\n\u2551                                                                              \u2551\n\u2551 14:47:38.341 \u2717 FAILED [Kafka] shouldBePublished&lt;ProductCreatedEvent&gt;         \u2551\n\u2551     Expected: Message matching condition within 5s                           \u2551\n\u2551     Actual: No matching message found                                        \u2551\n\u2551     Error: GOT A TIMEOUT: While expecting the publish of 'ProductCreatedEvent'\u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 SYSTEM SNAPSHOTS                                                             \u2551\n\u2551 \u250c\u2500 KAFKA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2551\n\u2551   Consumed: 0                                                                \u2551\n\u2551   Produced: 1                                                                \u2551\n\u2551   State Details:                                                             \u2551\n\u2551     produced: 1 item(s)                                                      \u2551\n\u2551       [0] topic: product-events, value: {\"id\":1234,\"name\":\"Test Product\"}    \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre>"},{"location":"release-notes/0.20.0/#available-renderers","title":"Available Renderers","text":"<ul> <li>PrettyConsoleRenderer (default) - Colorized, box-drawing output for terminals</li> <li>JsonReportRenderer - Machine-readable JSON for CI/CD integration</li> </ul> <p>See the Reporting documentation for full details.</p>"},{"location":"release-notes/0.20.0/#spring-boot-4x-support","title":"Spring Boot 4.x Support","text":"<p>Stove now fully supports Spring Boot 4.x and Spring Kafka 4.x. The existing <code>stove-spring</code> and <code>stove-spring-kafka</code> modules work with all Spring Boot versions (2.x, 3.x, and 4.x).</p> <p>Dependencies remain the same:</p> <pre><code>testImplementation(\"com.trendyol:stove-spring:0.20.0\")\ntestImplementation(\"com.trendyol:stove-spring-kafka:0.20.0\")\n</code></pre>"},{"location":"release-notes/0.20.0/#new-bean-registration-dsl-for-spring-boot-4x","title":"New Bean Registration DSL for Spring Boot 4.x","text":"<p>Spring Boot 4.x deprecates <code>BeanDefinitionDsl</code> (<code>beans { }</code> DSL). Stove provides new extension functions for cleaner bean registration:</p> <p>Spring Boot 2.x / 3.x - use <code>addTestDependencies</code>:</p> <pre><code>import com.trendyol.stove.addTestDependencies\n\nspringBoot(\n    runner = { params -&gt;\n        runApplication&lt;MyApp&gt;(args = params) {\n            addTestDependencies {\n                bean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;()\n                bean&lt;MyService&gt; { MyServiceImpl() }\n            }\n        }\n    }\n)\n</code></pre> <p>Spring Boot 4.x - use <code>addTestDependencies4x</code>:</p> <pre><code>import com.trendyol.stove.addTestDependencies4x\n\nspringBoot(\n    runner = { params -&gt;\n        runApplication&lt;MyApp&gt;(args = params) {\n            addTestDependencies4x {\n                registerBean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;(primary = true)\n                registerBean&lt;MyService&gt; { MyServiceImpl() }\n            }\n        }\n    }\n)\n</code></pre> <p>Alternative: Using <code>addInitializers</code> directly:</p> <pre><code>// Spring Boot 2.x / 3.x\naddInitializers(stoveSpringRegistrar { bean&lt;MyService&gt;() })\n\n// Spring Boot 4.x\naddInitializers(stoveSpring4xRegistrar { registerBean&lt;MyService&gt;() })\n</code></pre> <p>Key differences for 4.x: - Use <code>registerBean&lt;T&gt;()</code> instead of <code>bean&lt;T&gt;()</code> - Use <code>registerBean&lt;T&gt;(primary = true)</code> for primary beans - No <code>ref()</code> function - use constructor injection instead</p>"},{"location":"release-notes/0.20.0/#ktor-di-flexibility","title":"Ktor DI Flexibility","text":"<p>Stove's Ktor module now supports multiple dependency injection systems. Previously, Koin was required. Now you can use:</p> <ol> <li>Koin (existing support)</li> <li>Ktor-DI (new built-in support)</li> <li>Custom resolver (any DI framework)</li> </ol> <p>Both Koin and Ktor-DI are now <code>compileOnly</code> dependencies - you bring your preferred DI system.</p> <p>Using Koin:</p> <pre><code>dependencies {\n    testImplementation(\"io.insert-koin:koin-ktor:$koinVersion\")\n}\n\n// In your test setup\nbridge() // Auto-detects Koin\n</code></pre> <p>Using Ktor-DI:</p> <pre><code>dependencies {\n    testImplementation(\"io.ktor:ktor-server-di:$ktorVersion\")\n}\n\n// In your test setup\nbridge() // Auto-detects Ktor-DI\n</code></pre> <p>Using a Custom Resolver:</p> <p>For any other DI framework (Kodein, Dagger, manual, etc.):</p> <pre><code>bridge { application, type -&gt;\n    // Your custom resolution logic - type is KType preserving generics\n    myDiContainer.resolve(type)\n}\n</code></pre>"},{"location":"release-notes/0.20.0/#generic-type-resolution-in-bridge-system","title":"Generic Type Resolution in Bridge System","text":"<p>The <code>using&lt;T&gt;</code> function now properly preserves generic type information, allowing you to resolve types like <code>List&lt;PaymentService&gt;</code>:</p> <pre><code>// Register multiple implementations\nprovide&lt;List&lt;PaymentService&gt;&gt; {\n    listOf(StripePaymentService(), PayPalPaymentService())\n}\n\n// Resolve with full generic type preserved\nstove {\n    using&lt;List&lt;PaymentService&gt;&gt; {\n        forEach { service -&gt; service.pay(order) }\n    }\n}\n</code></pre> <p>This works by using <code>KType</code> instead of <code>KClass</code> internally, which preserves generic type parameters that would otherwise be lost due to JVM type erasure.</p> <p>For custom BridgeSystem implementations: Override <code>getByType(type: KType)</code> to support generic types. The default implementation falls back to <code>get(klass: KClass)</code>.</p>"},{"location":"release-notes/0.20.0/#ktor-test-dependency-registration","title":"Ktor Test Dependency Registration","text":"<p>Unlike Spring Boot's unified <code>addTestDependencies</code>, Ktor test dependency registration differs by DI framework:</p> <p>Koin:</p> <pre><code>// In your app - accept test modules\nfun run(args: Array&lt;String&gt;, testModules: List&lt;Module&gt; = emptyList()): Application {\n    return embeddedServer(Netty, port = args.getPort()) {\n        install(Koin) { modules(appModule, *testModules.toTypedArray()) }\n    }.start(wait = false).application\n}\n\n// In tests - pass test modules with overrides\nktor(runner = { params -&gt;\n    MyApp.run(params, testModules = listOf(\n        module {\n            single&lt;TimeProvider&gt;(override = true) { FixedTimeProvider() }\n        }\n    ))\n})\n</code></pre> <p>Ktor-DI:</p> <pre><code>// In your app - accept test dependencies\nfun run(args: Array&lt;String&gt;, testDeps: (DependencyRegistrar.() -&gt; Unit)? = null): Application {\n    return embeddedServer(Netty, port = args.getPort()) {\n        install(DI) {\n            dependencies {\n                provide&lt;MyService&gt; { MyServiceImpl() }\n                testDeps?.invoke(this)  // Later provides override earlier ones\n            }\n        }\n    }.start(wait = false).application\n}\n\n// In tests - pass test overrides\nktor(runner = { params -&gt;\n    MyApp.run(params) {\n        provide&lt;TimeProvider&gt; { FixedTimeProvider() }\n    }\n})\n</code></pre>"},{"location":"release-notes/0.20.0/#runtime-version-checks","title":"Runtime Version Checks","text":"<p>When Spring Boot, Spring Kafka, or Ktor DI is missing from the classpath, Stove now provides clear error messages:</p> <pre><code>\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  Spring Boot Not Found on Classpath!\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  stove-spring requires Spring Boot to be on your classpath.\n  Spring Boot is declared as a 'compileOnly' dependency, so you must add it\n  to your project.\n\n  Add one of the following to your build.gradle.kts:\n\n  For Spring Boot 2.x:\n    testImplementation(\"org.springframework.boot:spring-boot-starter:2.7.x\")\n\n  For Spring Boot 3.x:\n    testImplementation(\"org.springframework.boot:spring-boot-starter:3.x.x\")\n\n  For Spring Boot 4.x:\n    testImplementation(\"org.springframework.boot:spring-boot-starter:4.x.x\")\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n</code></pre>"},{"location":"release-notes/0.20.0/#migration-guide","title":"Migration Guide","text":""},{"location":"release-notes/0.20.0/#from-019x-to-0200","title":"From 0.19.x to 0.20.0","text":"<p>This is a breaking change release. Follow these steps to migrate:</p>"},{"location":"release-notes/0.20.0/#1-update-module-names-required","title":"1. Update Module Names (Required)","text":"<p>See the Breaking Changes - Module and Package Renaming section above for detailed migration steps and regex patterns.</p> <p>Quick Summary: - Update all artifact names in build files - Replace <code>stove-testing-e2e</code> \u2192 <code>stove</code> - Replace <code>stove-*-testing-e2e</code> \u2192 <code>stove-*</code> - Update all package imports from <code>com.trendyol.stove.testing.e2e.*</code> \u2192 <code>com.trendyol.stove.*</code></p>"},{"location":"release-notes/0.20.0/#2-test-framework-extensions-optional","title":"2. Test Framework Extensions (Optional)","text":"<p>Test framework extensions are now in separate modules. They're optional but recommended for better failure reporting. Add the one that matches your test framework:</p> <pre><code>dependencies {\n    // For Kotest\n    testImplementation(\"com.trendyol:stove-extensions-kotest\")\n\n    // OR for JUnit 5/6\n    testImplementation(\"com.trendyol:stove-extensions-junit\")\n}\n</code></pre> <p>Update your imports:</p> <pre><code>// Kotest\nimport com.trendyol.stove.extensions.kotest.StoveKotestExtension\n\n// JUnit\nimport com.trendyol.stove.extensions.junit.StoveJUnitExtension\n</code></pre>"},{"location":"release-notes/0.20.0/#3-use-the-new-bom-recommended","title":"3. Use the New BOM (Recommended)","text":"<p>The new BOM simplifies version management:</p> <pre><code>dependencies {\n    testImplementation(platform(\"com.trendyol:stove-bom:0.20.0\"))\n\n    // No versions needed - managed by BOM\n    testImplementation(\"com.trendyol:stove\")\n    testImplementation(\"com.trendyol:stove-spring\")\n    testImplementation(\"com.trendyol:stove-kafka\")\n}\n</code></pre>"},{"location":"release-notes/0.20.0/#from-019x-other-changes","title":"From 0.19.x (Other Changes)","text":""},{"location":"release-notes/0.20.0/#test-extensions-for-better-reporting","title":"Test Extensions for Better Reporting","text":"<p>The reporting extensions are optional but make debugging much easier. Add the one for your test framework:</p> <p>Kotest: <pre><code>// Add dependency: testImplementation(\"com.trendyol:stove-extensions-kotest\")\nclass TestConfig : AbstractProjectConfig() {\n    override val extensions = listOf(StoveKotestExtension())\n}\n</code></pre></p> <p>JUnit: <pre><code>@ExtendWith(StoveJUnitExtension::class)\nclass MyE2ETest { }\n</code></pre></p>"},{"location":"release-notes/0.20.0/#for-spring-boot-2x-and-3x-users","title":"For Spring Boot 2.x and 3.x Users","text":"<p>If using <code>BaseApplicationContextInitializer</code>: Migrate to <code>addTestDependencies</code> (see Breaking Changes below).</p> <p>If using <code>beans { }</code> directly: Your existing code continues to work. Optionally, use the new cleaner API:</p> <pre><code>// Old way (still works)\naddInitializers(beans { bean&lt;MyService&gt;() })\n\n// New way (recommended)\naddTestDependencies { bean&lt;MyService&gt;() }\n</code></pre>"},{"location":"release-notes/0.20.0/#for-spring-boot-4x-users-new","title":"For Spring Boot 4.x Users (New!)","text":"<p>Spring Boot 4.x is newly supported in this release. Use <code>addTestDependencies4x</code>:</p> <pre><code>import com.trendyol.stove.addTestDependencies4x\n\nspringBoot(\n    runner = { params -&gt;\n        runApplication&lt;MyApp&gt;(args = params) {\n            addTestDependencies4x {\n                registerBean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;(primary = true)\n                registerBean&lt;MyService&gt; { MyServiceImpl() }\n            }\n        }\n    }\n)\n</code></pre> <p>Note: The <code>beans { }</code> DSL from Spring is deprecated in 4.x, which is why Stove provides <code>addTestDependencies4x</code> with <code>registerBean&lt;T&gt;()</code>.</p>"},{"location":"release-notes/0.20.0/#breaking-changes","title":"Breaking Changes","text":""},{"location":"release-notes/0.20.0/#module-and-package-renaming","title":"Module and Package Renaming","text":"<p>\u26a0\ufe0f BREAKING: All Stove modules have been renamed to simplify artifact names and package structure. This is a breaking change that requires updates to your build files and source code.</p>"},{"location":"release-notes/0.20.0/#module-name-changes","title":"Module Name Changes","text":"Old Artifact Name New Artifact Name <code>stove-testing-e2e</code> <code>stove</code> <code>stove-testing-e2e-kafka</code> <code>stove-kafka</code> <code>stove-testing-e2e-http</code> <code>stove-http</code> <code>stove-testing-e2e-couchbase</code> <code>stove-couchbase</code> <code>stove-testing-e2e-elasticsearch</code> <code>stove-elasticsearch</code> <code>stove-testing-e2e-grpc</code> <code>stove-grpc</code> <code>stove-testing-e2e-mongodb</code> <code>stove-mongodb</code> <code>stove-testing-e2e-redis</code> <code>stove-redis</code> <code>stove-testing-e2e-wiremock</code> <code>stove-wiremock</code> <code>stove-testing-e2e-rdbms-postgres</code> <code>stove-postgres</code> <code>stove-testing-e2e-rdbms-mssql</code> <code>stove-mssql</code> <code>stove-spring-testing-e2e</code> <code>stove-spring</code> <code>stove-spring-testing-e2e-kafka</code> <code>stove-spring-kafka</code> <code>stove-ktor-testing-e2e</code> <code>stove-ktor</code> <code>stove-micronaut-testing-e2e</code> <code>stove-micronaut</code>"},{"location":"release-notes/0.20.0/#package-name-changes","title":"Package Name Changes","text":"<p>All packages have been simplified: - <code>com.trendyol.stove.testing.e2e.*</code> \u2192 <code>com.trendyol.stove.*</code> - <code>com.trendyol.stove.testing.e2e.rdbms.postgres</code> \u2192 <code>com.trendyol.stove.postgres</code> - <code>com.trendyol.stove.testing.e2e.rdbms.mssql</code> \u2192 <code>com.trendyol.stove.mssql</code> - <code>com.trendyol.stove.testing.e2e.standalone.kafka</code> \u2192 <code>com.trendyol.stove.kafka</code></p>"},{"location":"release-notes/0.20.0/#migration-guide_1","title":"Migration Guide","text":"<p>Step 1: Update Build Files (Gradle/Maven)</p> <p>Recommended: Use the new BOM for version management:</p> <pre><code>// build.gradle.kts\ndependencies {\n    // Import BOM\n    testImplementation(platform(\"com.trendyol:stove-bom:$version\"))\n\n    // Core and framework (no version needed - managed by BOM)\n    testImplementation(\"com.trendyol:stove\")\n    testImplementation(\"com.trendyol:stove-spring\")  // or stove-ktor, stove-micronaut\n\n    // Components (no version needed)\n    testImplementation(\"com.trendyol:stove-kafka\")\n    testImplementation(\"com.trendyol:stove-postgres\")\n    // ... other components\n}\n</code></pre> <p>Or without BOM (specify versions explicitly):</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove:$version\")\n    testImplementation(\"com.trendyol:stove-spring:$version\")\n    testImplementation(\"com.trendyol:stove-kafka:$version\")\n    testImplementation(\"com.trendyol:stove-postgres:$version\")\n}\n</code></pre> <p>Step 2: Update Package Imports in Source Code</p> <p>All import statements need to be updated. Use the regex patterns below for automated migration.</p> <p>Step 3: Automated Migration with Regex</p> <p>Use these regex patterns in your IDE's find-and-replace (with regex enabled):</p> <p>For Build Files (Gradle/Maven):</p> <ol> <li> <p>Replace artifact names in dependencies: <pre><code>Find:    com\\.trendyol:stove-testing-e2e(?!-)\nReplace: com.trendyol:stove\n</code></pre></p> </li> <li> <p>Replace component artifacts: <pre><code>Find:    com\\.trendyol:stove-testing-e2e-([a-z-]+)\nReplace: com.trendyol:stove-$1\n</code></pre></p> </li> <li> <p>Replace RDBMS artifacts: <pre><code>Find:    com\\.trendyol:stove-testing-e2e-rdbms-(postgres|mssql)\nReplace: com.trendyol:stove-$1\n</code></pre></p> </li> <li> <p>Replace starter artifacts: <pre><code>Find:    com\\.trendyol:stove-(spring|ktor|micronaut)-testing-e2e(-kafka)?\nReplace: com.trendyol:stove-$1$2\n</code></pre></p> </li> </ol> <p>For Source Code (Kotlin/Java):</p> <ol> <li> <p>Replace package imports: <pre><code>Find:    import com\\.trendyol\\.stove\\.testing\\.e2e\\.(.*)\nReplace: import com.trendyol.stove.$1\n</code></pre></p> </li> <li> <p>Replace fully qualified names: <pre><code>Find:    com\\.trendyol\\.stove\\.testing\\.e2e\\.rdbms\\.(postgres|mssql)\nReplace: com.trendyol.stove.$1\n</code></pre></p> </li> <li> <p>Replace standalone.kafka: <pre><code>Find:    com\\.trendyol\\.stove\\.testing\\.e2e\\.standalone\\.kafka\nReplace: com.trendyol.stove.kafka\n</code></pre></p> </li> <li> <p>Replace remaining testing.e2e references: <pre><code>Find:    com\\.trendyol\\.stove\\.testing\\.e2e\\.([a-z.]+)\nReplace: com.trendyol.stove.$1\n</code></pre></p> </li> </ol> <p>Step 4: Manual Verification</p> <p>After automated replacement, verify:</p> <ol> <li>Build files compile - Run <code>./gradlew build</code> or <code>mvn compile</code></li> <li>Imports resolve - Check that all imports are valid</li> <li>Tests compile - Run <code>./gradlew compileTestKotlin</code> or <code>mvn test-compile</code></li> <li>Tests pass - Run your test suite</li> </ol> <p>Example Migration</p> <p>Before (0.19.0): <pre><code>// build.gradle.kts\ndependencies {\n    testImplementation(\"com.trendyol:stove-testing-e2e:0.19.0\")\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:0.19.0\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-kafka:0.19.0\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-rdbms-postgres:0.19.0\")\n}\n\n// Test code\nimport com.trendyol.stove.testing.e2e.system.TestSystem\nimport com.trendyol.stove.testing.e2e.kafka.kafka\nimport com.trendyol.stove.testing.e2e.rdbms.postgres.postgresql\n</code></pre></p> <p>After (0.20.0): <pre><code>// build.gradle.kts\ndependencies {\n    testImplementation(platform(\"com.trendyol:stove-bom:0.20.0\"))\n    testImplementation(\"com.trendyol:stove\")\n    testImplementation(\"com.trendyol:stove-spring\")\n    testImplementation(\"com.trendyol:stove-kafka\")\n    testImplementation(\"com.trendyol:stove-postgres\")\n}\n\n// Test code\nimport com.trendyol.stove.system.TestSystem\nimport com.trendyol.stove.kafka.kafka\nimport com.trendyol.stove.postgres.postgresql\n</code></pre></p> <p>Migration Checklist</p> <ul> <li>[ ] Update all <code>build.gradle.kts</code> / <code>build.gradle</code> / <code>pom.xml</code> files</li> <li>[ ] Replace all import statements in test source code</li> <li>[ ] Replace all fully qualified package references</li> <li>[ ] Update any documentation or scripts referencing old artifact names</li> <li>[ ] Verify build compiles successfully</li> <li>[ ] Run test suite to ensure everything works</li> </ul> <p>Need Help?</p> <p>If you encounter issues during migration: 1. Check the Migration Guide section below 2. Review the Getting Started guide for updated examples 3. Open an issue on GitHub</p>"},{"location":"release-notes/0.20.0/#baseapplicationcontextinitializer-removed","title":"<code>BaseApplicationContextInitializer</code> Removed","text":"<p><code>BaseApplicationContextInitializer</code> has been removed. Migrate to <code>addTestDependencies</code>:</p> <p>Before (0.19.0):</p> <pre><code>class TestSystemInitializer : BaseApplicationContextInitializer({\n    bean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;()\n    bean&lt;MyService&gt; { MyServiceImpl() }\n})\n\n// Usage\nrunApplication&lt;MyApp&gt;(args = params) {\n    addInitializers(TestSystemInitializer())\n}\n</code></pre> <p>After (0.20.0):</p> <pre><code>import com.trendyol.stove.addTestDependencies\n\nrunApplication&lt;MyApp&gt;(args = params) {\n    addTestDependencies {\n        bean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;()\n        bean&lt;MyService&gt; { MyServiceImpl() }\n    }\n}\n</code></pre> <p>This is simpler - no need to create a separate class.</p>"},{"location":"release-notes/0.20.0/#httpsystem-getresponse-renamed-to-getresponsebodiless","title":"HttpSystem: <code>getResponse</code> renamed to <code>getResponseBodiless</code>","text":"<p>The <code>getResponse</code> method in <code>HttpSystem</code> has been renamed to <code>getResponseBodiless</code> to better reflect its purpose - it returns a response without parsing the body.</p> <p>Before: <pre><code>http {\n    getResponse(\"/api/endpoint\") { response -&gt;\n        response.status shouldBe 200\n    }\n}\n</code></pre></p> <p>After: <pre><code>http {\n    getResponseBodiless(\"/api/endpoint\") { response -&gt;\n        response.status shouldBe 200\n    }\n}\n</code></pre></p>"},{"location":"release-notes/0.20.0/#notes","title":"Notes","text":""},{"location":"release-notes/0.20.0/#bridgesystem-api-enhancement","title":"BridgeSystem API Enhancement","text":"<p>The <code>BridgeSystem</code> abstract class now has a new method <code>getByType(type: KType)</code> which is used by <code>resolve()</code> to support generic types. If you have a custom <code>BridgeSystem</code> implementation:</p> <ul> <li>No action required if you only use simple types - the default implementation falls back to <code>get(klass: KClass)</code></li> <li>Override <code>getByType(type: KType)</code> if you want to support generic types like <code>List&lt;T&gt;</code>, <code>Map&lt;K,V&gt;</code>, etc.</li> </ul> <pre><code>// Example for custom bridge\noverride fun &lt;D : Any&gt; getByType(type: KType): D {\n    // Use type.classifier for KClass\n    // Use type.arguments for generic parameters\n    return myDiFramework.resolve(type)\n}\n</code></pre>"},{"location":"release-notes/0.20.0/#dead-letter-topic-naming-convention-spring-kafka","title":"Dead Letter Topic Naming Convention (Spring Kafka)","text":"<p>Be aware that Spring Kafka changed the default DLT (Dead Letter Topic) naming convention between versions:</p> Spring Kafka Version DLT Suffix Example 2.x <code>.DLT</code> <code>my-topic.DLT</code> 3.x, 4.x <code>-dlt</code> <code>my-topic-dlt</code> <p>This is not a Stove change, but something to be aware of when writing Kafka tests across different Spring Kafka versions.</p>"},{"location":"release-notes/0.20.0/#optional-disable-reporting","title":"Optional: Disable Reporting","text":"<p>If you don't want the new reporting feature (not recommended), you can disable it:</p> <pre><code>TestSystem {\n    reportingEnabled(false)\n}\n</code></pre>"},{"location":"release-notes/0.20.0/#dependency-updates","title":"Dependency Updates","text":"<ul> <li>Spring Boot 4.x support (4.0.0+)</li> <li>Spring Kafka 4.x support (4.0.0+)</li> <li>Continued support for Spring Boot 2.7.x and 3.x</li> <li>Continued support for Spring Kafka 2.9.x and 3.x</li> </ul>"},{"location":"release-notes/0.20.0/#full-changelog","title":"Full Changelog","text":"<p>See the GitHub Releases page for the complete list of commits and contributors.</p>"},{"location":"release-notes/0.20.0/#contributors","title":"Contributors","text":"<p>Thanks to all contributors who made this release possible!</p>"},{"location":"release-notes/0.20.0/#getting-started","title":"Getting Started","text":"<pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove:0.20.0\")\n    testImplementation(\"com.trendyol:stove-spring:0.20.0\")\n    // Add component-specific dependencies as needed\n    testImplementation(\"com.trendyol:stove-spring-kafka:0.20.0\")\n}\n</code></pre> <p>For snapshot versions, add the snapshot repository:</p> <pre><code>repositories {\n    maven(\"https://central.sonatype.com/repository/maven-snapshots\")\n}\n</code></pre>"},{"location":"release-notes/0.21.0/","title":"0.21.0","text":"<p>Released: February 2026</p> <p>This release introduces:</p> <ul> <li>Tracing: See the full execution trace of your application when a test fails: every controller, database query, Kafka message, and HTTP call with timing and failure points</li> <li>gRPC Mocking: Mock external gRPC services in your tests with a type-safe DSL</li> <li>MySQL Support: New <code>stove-mysql</code> module for testing against MySQL databases</li> <li>WireMock Test Scoping: WireMock snapshots are now scoped to the current test for cleaner failure reports</li> <li>Dynamic Port Allocation: WireMock now defaults to <code>port = 0</code> and gRPC Mock supports it, no more port conflicts in CI</li> <li>Migration Type Aliases: <code>PostgresqlMigration</code>, <code>MongodbMigration</code>, etc. instead of verbose <code>DatabaseMigration&lt;XyzContext&gt;</code></li> <li>Elasticsearch 9 Support: Adapted to work with Elasticsearch 9.x</li> <li>Spring Showcase Recipe: A comprehensive example project demonstrating all Stove features together</li> </ul>"},{"location":"release-notes/0.21.0/#new-features","title":"New Features","text":""},{"location":"release-notes/0.21.0/#tracing","title":"Tracing","text":"<p>When a test fails, you no longer have to guess what happened inside your application. Stove captures the entire call chain: every controller method, database query, Kafka message, and HTTP call, and displays it as a trace tree in the failure report:</p> <pre><code>\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nEXECUTION TRACE (Call Chain)\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\u2713 POST (377ms)\n  \u2713 POST /api/product/create (361ms)\n    \u2713 ProductController.create (141ms)\n      \u2713 ProductCreator.create (0ms)\n      \u2713 KafkaProducer.send (137ms)\n        \u2713 orders.created publish (81ms)\n          \u2717 orders.created process (82ms)  \u2190 FAILURE POINT\n</code></pre> <p>Setup takes two steps:</p> <ol> <li>Enable in your Stove config:</li> </ol> <pre><code>Stove()\n    .with {\n        tracing {\n            enableSpanReceiver()\n        }\n    }\n</code></pre> <ol> <li>Attach the OpenTelemetry agent in your build. Copy <code>StoveTracingConfiguration.kt</code> to your project's <code>buildSrc/src/main/kotlin/</code> directory, then add to your <code>build.gradle.kts</code>:</li> </ol> <pre><code>import com.trendyol.stove.gradle.stoveTracing\n\nstoveTracing {\n    serviceName = \"my-service\"\n}\n</code></pre> <p>Gradle Plugin available since 0.21.2</p> <p>Starting with 0.21.2, a standalone Gradle plugin is available that eliminates the need to copy this file. See the 0.21.2 release notes for details.</p> <p>Everything else is automatic. Trace headers are injected into HTTP, Kafka, and gRPC calls, spans are collected and correlated, and failure reports are enriched with the trace tree.</p> <p>A validation DSL is also available for asserting on the execution flow:</p> <pre><code>tracing {\n    shouldContainSpan(\"OrderService.processOrder\")\n    shouldNotHaveFailedSpans()\n    executionTimeShouldBeLessThan(500.milliseconds)\n}\n</code></pre> <p>See the Tracing documentation for full details.</p>"},{"location":"release-notes/0.21.0/#grpc-mocking","title":"gRPC Mocking","text":"<p>New <code>stove-grpc-mock</code> module for mocking external gRPC services in your tests. This lets you test gRPC client code without running the actual upstream services.</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-grpc-mock:$stoveVersion\")\n}\n</code></pre> <p>Configure in your Stove setup:</p> <pre><code>grpcMock {\n    GrpcMockSystemOptions(port = 0) // Dynamic port allocation\n}\n</code></pre> <p>Stub responses with a type-safe DSL:</p> <pre><code>grpcMock {\n    mockUnary(\n        FraudDetectionServiceGrpc.getCheckFraudMethod(),\n        response = FraudCheckResponse.newBuilder()\n            .setIsFraud(false)\n            .setScore(0.1)\n            .build()\n    )\n}\n</code></pre> <p>Supports unary, server streaming, and conditional matching. See the gRPC Mocking documentation for full details.</p>"},{"location":"release-notes/0.21.0/#mysql-support","title":"MySQL Support","text":"<p>New <code>stove-mysql</code> module with the same familiar DSL as PostgreSQL and MSSQL:</p> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-mysql:$stoveVersion\")\n}\n</code></pre> <pre><code>Stove()\n    .with {\n        mysql {\n            MysqlOptions(\n                databaseName = \"mydb\",\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"spring.datasource.url=${cfg.jdbcUrl}\",\n                        \"spring.datasource.username=${cfg.username}\",\n                        \"spring.datasource.password=${cfg.password}\"\n                    )\n                }\n            )\n        }\n    }\n</code></pre> <p>Supports migrations, <code>shouldQuery</code>, <code>shouldExecute</code>, and all the database operations you'd expect. See the MySQL documentation for details.</p>"},{"location":"release-notes/0.21.0/#wiremock-test-scoping","title":"WireMock Test Scoping","text":"<p>WireMock snapshots in failure reports are now scoped to the current test. Previously, all registered stubs and requests across the entire test suite would appear in the snapshot. Now you only see stubs and requests relevant to the test that failed, making failure reports much easier to read.</p>"},{"location":"release-notes/0.21.0/#dynamic-port-allocation","title":"Dynamic Port Allocation","text":"<p>Both WireMock and gRPC Mock now support dynamic port allocation with <code>port = 0</code>, which prevents port conflicts when running tests in parallel on CI.</p> <p>WireMock now defaults to <code>port = 0</code>. You no longer need to pick a port:</p> <pre><code>wiremock {\n    WireMockSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n            listOf(\"external-apis.inventory.url=${cfg.baseUrl}\")\n        }\n    )\n}\n</code></pre> <p>gRPC Mock also supports <code>port = 0</code>:</p> <pre><code>grpcMock {\n    GrpcMockSystemOptions(port = 0)\n}\n</code></pre> <p>In both cases, the actual port is exposed via <code>configureExposedConfiguration</code> so your application receives the correct URL.</p>"},{"location":"release-notes/0.21.0/#spring-showcase-recipe","title":"Spring Showcase Recipe","text":"<p>A new comprehensive recipe at <code>recipes/kotlin-recipes/spring-showcase/</code> demonstrates all Stove features working together in a realistic Spring Boot application:</p> <ul> <li>HTTP endpoints with PostgreSQL</li> <li>Kafka producers and consumers</li> <li>gRPC server and client with mocked upstream</li> <li>WireMock for external HTTP APIs</li> <li>Tracing</li> <li>Database migrations</li> <li>db-scheduler integration</li> </ul> <p>This is the best starting point for understanding how Stove fits into a real project.</p>"},{"location":"release-notes/0.21.0/#migration-type-aliases","title":"Migration Type Aliases","text":"<p>Each module that supports migrations now provides a convenient type alias, so you no longer need to remember <code>DatabaseMigration&lt;PostgresSqlMigrationContext&gt;</code> and similar verbose signatures:</p> <pre><code>// Before\nclass CreateUsersTable : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; { ... }\n\n// After\nclass CreateUsersTable : PostgresqlMigration { ... }\n</code></pre> <p>Available aliases:</p> Module Type Alias stove-postgres <code>PostgresqlMigration</code> stove-mysql <code>MySqlMigration</code> stove-mssql <code>MsSqlMigration</code> stove-mongodb <code>MongodbMigration</code> stove-couchbase <code>CouchbaseMigration</code> stove-elasticsearch <code>ElasticsearchMigration</code> stove-redis <code>RedisMigration</code> stove-kafka <code>KafkaMigration</code> <p>The generic <code>DatabaseMigration&lt;T&gt;</code> interface remains fully supported. The aliases are purely additive.</p>"},{"location":"release-notes/0.21.0/#improvements","title":"Improvements","text":""},{"location":"release-notes/0.21.0/#elasticsearch-9-support","title":"Elasticsearch 9 Support","text":"<p><code>stove-elasticsearch</code> now works with Elasticsearch 9.x (specifically 9.3.0). The module adapts to the updated client API automatically.</p>"},{"location":"release-notes/0.21.0/#improved-failure-reports","title":"Improved Failure Reports","text":"<ul> <li>Exception details (type, message, stack trace) are now extracted from OpenTelemetry spans and displayed in trace trees</li> <li>Console renderer output is cleaner and better formatted</li> <li>Kafka report entries now include all relevant state</li> </ul>"},{"location":"release-notes/0.21.0/#tracing-configuration-cache-compatibility","title":"Tracing Configuration Cache Compatibility","text":"<p>The Stove Tracing Gradle plugin and the <code>stoveTracing</code> buildSrc helper are both fully compatible with Gradle configuration cache, so builds with <code>--configuration-cache</code> work correctly.</p>"},{"location":"release-notes/0.21.0/#non-ascii-test-id-support","title":"Non-ASCII Test ID Support","text":"<p>Trace context test IDs now handle non-ASCII characters (e.g., Japanese, Korean) correctly by normalizing to ASCII with hash suffixes for uniqueness. This ensures consistent behavior when test names use non-Latin scripts.</p>"},{"location":"release-notes/0.21.0/#bridgesystem-suspended","title":"BridgeSystem Suspended","text":"<p><code>BridgeSystem</code> methods are now <code>suspend</code> functions, allowing proper coroutine support in bridge implementations.</p>"},{"location":"release-notes/0.21.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>HTTP streaming: Fixed a flow collection issue that could cause streaming responses to hang</li> <li>Kafka tests: Fixed flaky test behavior in Kafka system tests</li> <li>Tracing configuration cache: Fixed serialization issues when using Gradle configuration cache with the Stove Tracing plugin</li> <li>ASCII character handling: Fixed edge cases in test ID sanitization for non-ASCII characters</li> </ul>"},{"location":"release-notes/0.21.0/#dependency-updates","title":"Dependency Updates","text":"<ul> <li>Elasticsearch 9.3.0</li> <li>Kafka (Confluent) 8.1.1</li> <li>Confluent Platform Kafka 8.0.3</li> <li>gRPC Java 1.79.0</li> <li>Protobuf 4.33.5</li> <li>OpenTelemetry 1.59.0</li> <li>Kotlin (latest patch)</li> <li>Ktor 3.4.0</li> <li>Flyway 12.x</li> <li>HikariCP 7.x</li> <li>Various Spring, Quarkus, and Micronaut updates</li> </ul>"},{"location":"release-notes/0.21.0/#migration-guide","title":"Migration Guide","text":""},{"location":"release-notes/0.21.0/#from-020x-to-0210","title":"From 0.20.x to 0.21.0","text":"<p>This is a non-breaking release. All existing APIs remain compatible.</p>"},{"location":"release-notes/0.21.0/#new-features-to-opt-into","title":"New Features to Opt Into","text":"<p>Tracing: Add <code>stove-tracing</code> to your dependencies and follow the setup guide.</p> <p>gRPC Mocking: Add <code>stove-grpc-mock</code> to your dependencies if you need to mock external gRPC services. See the gRPC Mocking documentation.</p> <p>MySQL: Add <code>stove-mysql</code> if you're testing against MySQL. See the MySQL documentation.</p>"},{"location":"release-notes/0.21.0/#test-framework-extensions","title":"Test Framework Extensions","text":"<p><code>StoveKotestExtension</code> (<code>stove-extensions-kotest</code>) and <code>StoveJUnitExtension</code> (<code>stove-extensions-junit</code>) are separate packages that must be on your classpath. Kotest requires 6.1.3 or later; JUnit requires Jupiter 6.x if possible.</p> <p>In Kotest 6.x, <code>AbstractProjectConfig</code> is no longer auto-scanned. Add a <code>kotest.properties</code> file in your test resources (e.g. <code>src/test-e2e/resources/kotest.properties</code>):</p> <pre><code>kotest.framework.config.fqn=com.myapp.e2e.TestConfig\n</code></pre> <p>Set the value to the fully qualified name of your <code>AbstractProjectConfig</code> class. See the Getting Started guide for full details.</p>"},{"location":"release-notes/0.21.0/#recommended-updates","title":"Recommended Updates","text":"<ul> <li>If using Elasticsearch, verify compatibility with Elasticsearch 9.x</li> <li>If using the Stove Tracing plugin or <code>stoveTracing</code>, no changes needed. Configuration cache compatibility is automatic</li> <li>Consider switching <code>GrpcMockSystemOptions</code> to <code>port = 0</code> for CI-friendly dynamic port allocation</li> </ul>"},{"location":"release-notes/0.21.0/#getting-started","title":"Getting Started","text":"<pre><code>dependencies {\n    testImplementation(platform(\"com.trendyol:stove-bom:0.21.0\"))\n\n    testImplementation(\"com.trendyol:stove\")\n    testImplementation(\"com.trendyol:stove-spring\")\n    testImplementation(\"com.trendyol:stove-tracing\")\n    testImplementation(\"com.trendyol:stove-extensions-kotest\")\n    // Add components as needed\n}\n</code></pre> <p>For snapshot versions:</p> <pre><code>repositories {\n    maven(\"https://central.sonatype.com/repository/maven-snapshots\")\n}\n</code></pre>"},{"location":"release-notes/0.21.2/","title":"0.21.2","text":"<p>Released: February 2026</p> <p>This release introduces the Stove Tracing Gradle Plugin, a standalone plugin that replaces the copy-paste buildSrc approach for configuring OpenTelemetry tracing in your tests.</p>"},{"location":"release-notes/0.21.2/#new-features","title":"New Features","text":""},{"location":"release-notes/0.21.2/#stove-tracing-gradle-plugin","title":"Stove Tracing Gradle Plugin","text":"<p>The tracing build configuration is now available as a proper Gradle plugin, published to both the Gradle Plugin Portal and Maven Central.</p> <pre><code>plugins {\n    id(\"com.trendyol.stove.tracing\") version \"0.21.2\"\n}\n\nstoveTracing {\n    serviceName.set(\"my-service\")\n}\n</code></pre> <p>The plugin handles everything: downloading the OpenTelemetry Java Agent, configuring JVM arguments, attaching the agent to your test tasks, and dynamically assigning ports so parallel test runs don't conflict.</p> <p>Why a plugin?</p> <ul> <li>No need to copy <code>StoveTracingConfiguration.kt</code> into your <code>buildSrc</code></li> <li>Version updates come through normal dependency management</li> <li>Consistent <code>stoveTracing { }</code> DSL with Gradle's <code>Property&lt;T&gt;</code> conventions</li> <li>Published alongside all other Stove artifacts</li> </ul> <p>Availability:</p> Channel Coordinates Gradle Plugin Portal <code>id(\"com.trendyol.stove.tracing\")</code> Maven Central <code>com.trendyol:stove-tracing-gradle-plugin</code> Maven Central Snapshots <code>com.trendyol:stove-tracing-gradle-plugin</code> (snapshot versions) <p>For snapshot versions, add the Maven Central snapshot repository to your <code>pluginManagement</code>:</p> <pre><code>// settings.gradle.kts\npluginManagement {\n    repositories {\n        gradlePluginPortal()\n        mavenCentral()\n        maven(\"https://central.sonatype.com/repository/maven-snapshots\")\n    }\n}\n</code></pre> <p>See the Tracing documentation for full configuration options.</p>"},{"location":"release-notes/0.21.2/#breaking-changes","title":"Breaking Changes","text":""},{"location":"release-notes/0.21.2/#configurestovetracing-renamed-to-stovetracing","title":"<code>configureStoveTracing</code> renamed to <code>stoveTracing</code>","text":"<p>The buildSrc copy-paste function has been renamed from <code>configureStoveTracing</code> to <code>stoveTracing</code> for consistency with the plugin DSL. If you are using the buildSrc approach, update your build scripts:</p> <pre><code>// Before\nimport com.trendyol.stove.gradle.configureStoveTracing\n\nconfigureStoveTracing {\n    serviceName = \"my-service\"\n}\n\n// After\nimport com.trendyol.stove.gradle.stoveTracing\n\nstoveTracing {\n    serviceName = \"my-service\"\n}\n</code></pre> <p>If you are migrating to the plugin, the DSL name is the same (<code>stoveTracing { }</code>), but properties use Gradle's <code>Property&lt;T&gt;</code> API:</p> <pre><code>// buildSrc style\nstoveTracing {\n    serviceName = \"my-service\"\n    testTaskNames = listOf(\"integrationTest\")\n}\n\n// Plugin style\nstoveTracing {\n    serviceName.set(\"my-service\")\n    testTaskNames.set(listOf(\"integrationTest\"))\n}\n</code></pre>"},{"location":"release-notes/0.21.2/#migration-guide","title":"Migration Guide","text":""},{"location":"release-notes/0.21.2/#from-021x-to-0212","title":"From 0.21.x to 0.21.2","text":""},{"location":"release-notes/0.21.2/#migrating-to-the-gradle-plugin-recommended","title":"Migrating to the Gradle plugin (recommended)","text":"<ol> <li>Remove <code>StoveTracingConfiguration.kt</code> from your <code>buildSrc/src/main/kotlin/</code> if you copied it</li> <li>Apply the plugin in your <code>build.gradle.kts</code>:</li> </ol> <pre><code>plugins {\n    id(\"com.trendyol.stove.tracing\") version \"0.21.2\"\n}\n\nstoveTracing {\n    serviceName.set(\"my-service\")\n}\n</code></pre>"},{"location":"release-notes/0.21.2/#staying-with-buildsrc","title":"Staying with buildSrc","text":"<p>If you prefer to keep the buildSrc approach, rename the function call:</p> <pre><code>// configureStoveTracing { ... }  -&gt;  stoveTracing { ... }\n</code></pre> <p>No other changes are required.</p>"}]}