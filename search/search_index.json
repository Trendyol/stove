{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"e2e Testing \u00b6 Testing a Spring application needs a small tuning to work with stove-testing. You can use testing approach/libraries without using the entire framework. Stove or this testing approach looks at the Spring application as a black box and just runs it as you run an application with java application.jar command from the terminal.","title":"e2e Testing"},{"location":"#e2e-testing","text":"Testing a Spring application needs a small tuning to work with stove-testing. You can use testing approach/libraries without using the entire framework. Stove or this testing approach looks at the Spring application as a black box and just runs it as you run an application with java application.jar command from the terminal.","title":"e2e Testing"},{"location":"0001-getting-started/","text":"Getting Started \u00b6 Prerequisites \u00b6 JDK 16+ Kotlin 1.8 Gradle 7.6 Kotlin Dsl (If you have maven that is also possible to implement but we advise to use Gradle build system, things are much simpler) Warning Documentation assumes that your project using gradle build system Dependencies: Since these dependencies are test dependencies scope all of them with test. Here in gradle it can be with testImplementation . $version=\"0.0.7-SNAPSHOT\" // always check the newest version, this might be outdated testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-http:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-kafka:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-couchbase:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-wiremock:$version\") Spring-Boot 2.7.7 (all spring boot stack should be) Couchbase Java Client ( implementation(\"com.couchbase.client:java-client:3.4.1\") ) Couchbase Client Metrics Micrometer ( implementation(\"com.couchbase.client:metrics-micrometer:0.4.1\") ) kotlinx stack 1.6.4 implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.6.4\")","title":"Getting Started"},{"location":"0001-getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"0001-getting-started/#prerequisites","text":"JDK 16+ Kotlin 1.8 Gradle 7.6 Kotlin Dsl (If you have maven that is also possible to implement but we advise to use Gradle build system, things are much simpler) Warning Documentation assumes that your project using gradle build system Dependencies: Since these dependencies are test dependencies scope all of them with test. Here in gradle it can be with testImplementation . $version=\"0.0.7-SNAPSHOT\" // always check the newest version, this might be outdated testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-http:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-kafka:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-couchbase:$version\") testImplementation(\"com.trendyol:stove-spring-testing-e2e-wiremock:$version\") Spring-Boot 2.7.7 (all spring boot stack should be) Couchbase Java Client ( implementation(\"com.couchbase.client:java-client:3.4.1\") ) Couchbase Client Metrics Micrometer ( implementation(\"com.couchbase.client:metrics-micrometer:0.4.1\") ) kotlinx stack 1.6.4 implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.6.4\")","title":"Prerequisites"},{"location":"0002-tuning-app/","text":"Tuning the application entry point and folder structure \u00b6 In a Spring application you usually have an entry point. Let's dive into to the details of the startup. @SpringBootApplication class QCInternationalServiceApplication // Empty application class for Spring dependency scan /** * Entry point for the jvm application */ fun main ( args : Array < String > ) { run ( args ) } /** * This is the point where spring application gets run. */ fun run ( args : Array < String > , init : SpringApplication .() -> Unit = {}, ): ConfigurableApplicationContext = runApplication < QCInternationalServiceApplication > ( * args , init = init ) run(args, init) method is the important point for the testing configuration. init allows us to override any dependency from the testing side that is being time related or configuration related. Spring itself opens this configuration higher order function to the outside. Secondly, it is up you to run e2e tests with your CI depending on the branch. But, we would like to give some advice for the folder/module structure. As you can see, unit tests, e2e tests, and integration tests are seperated from each other. So, you can run them separately.","title":"Tuning the application entry point and folder structure"},{"location":"0002-tuning-app/#tuning-the-application-entry-point-and-folder-structure","text":"In a Spring application you usually have an entry point. Let's dive into to the details of the startup. @SpringBootApplication class QCInternationalServiceApplication // Empty application class for Spring dependency scan /** * Entry point for the jvm application */ fun main ( args : Array < String > ) { run ( args ) } /** * This is the point where spring application gets run. */ fun run ( args : Array < String > , init : SpringApplication .() -> Unit = {}, ): ConfigurableApplicationContext = runApplication < QCInternationalServiceApplication > ( * args , init = init ) run(args, init) method is the important point for the testing configuration. init allows us to override any dependency from the testing side that is being time related or configuration related. Spring itself opens this configuration higher order function to the outside. Secondly, it is up you to run e2e tests with your CI depending on the branch. But, we would like to give some advice for the folder/module structure. As you can see, unit tests, e2e tests, and integration tests are seperated from each other. So, you can run them separately.","title":"Tuning the application entry point and folder structure"},{"location":"0003-dependencies/","text":"Figuring out the dependencies \u00b6 Your project might likely have dependencies for Couchbase, Kafka, and external http services. In the application context we will spin up instances of Couchbase and Kafka but not the external http services because you don't manage them, instead we will mock them using Wiremock . Docker Dependencies \u00b6 Info You can skip this step if your registry has already the docker images Docker dependencies are already hosted on trendyol registry, you need to be logged in to YOUR_REGISTRY in your local docker to be able to pull the dependencies when the e2e tests run. docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest Note Please make sure that you tag/upload the docker images as cross build to support developers that use ARM and AMD microprocessors. In the example above, as you can see uses buildx to create/tag cross-platform docker images and pushes them directly to the registry.","title":"Figuring out the dependencies"},{"location":"0003-dependencies/#figuring-out-the-dependencies","text":"Your project might likely have dependencies for Couchbase, Kafka, and external http services. In the application context we will spin up instances of Couchbase and Kafka but not the external http services because you don't manage them, instead we will mock them using Wiremock .","title":"Figuring out the dependencies"},{"location":"0003-dependencies/#docker-dependencies","text":"Info You can skip this step if your registry has already the docker images Docker dependencies are already hosted on trendyol registry, you need to be logged in to YOUR_REGISTRY in your local docker to be able to pull the dependencies when the e2e tests run. docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest Note Please make sure that you tag/upload the docker images as cross build to support developers that use ARM and AMD microprocessors. In the example above, as you can see uses buildx to create/tag cross-platform docker images and pushes them directly to the registry.","title":"Docker Dependencies"},{"location":"0004-referencing-stove/","text":"Referencing Stove libraries in your project \u00b6 After you figure out the physical dependencies you can add the library dependencies of Stove. If you want to use Couchbase you should add Stove Couchbase e2e test dependency: val version = \"0.0.6-SNAPSHOT\" // Check before setting it, there might be newer version testImplementation ( \"com.trendyol:stove-spring-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-http: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-kafka: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-couchbase: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-wiremock: $ version \" )","title":"Referencing Stove libraries in your project"},{"location":"0004-referencing-stove/#referencing-stove-libraries-in-your-project","text":"After you figure out the physical dependencies you can add the library dependencies of Stove. If you want to use Couchbase you should add Stove Couchbase e2e test dependency: val version = \"0.0.6-SNAPSHOT\" // Check before setting it, there might be newer version testImplementation ( \"com.trendyol:stove-spring-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-http: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-kafka: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-couchbase: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-wiremock: $ version \" )","title":"Referencing Stove libraries in your project"},{"location":"0005-configuring-the-framework/","text":"Configuring the framework \u00b6 After you've added the dependencies from Stove, it is time to construct he config that runs the physical dependencies. Warning We assume that you're using Kotest test framework, the following configuration is applicable for Kotest but, it should be available in any test framework. Create a TestSystemConfig.kt class \u00b6 Here you can see an example TestSystemConfig that is located under test-e2e module. It implements AbstractProjectConfig from Kotest framework that allows us to spin up the dependencies we need. As a side note, they are pluggable extensions, so if you don't want to add the dependency just comment the invocation out. But, be careful, you won't be able to use it in testing since you didn't enable the dependency. class TestSystemConfig : AbstractProjectConfig () { override suspend fun beforeProject () { TestSystem ( baseUrl = \"http://localhost:8001\" ) . withDefaultHttp () . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" ) // You can set spring configuration key // at this stage couchbase is available } . withKafka { cfg -> listOf ( \"kafka.bootstrapServers= ${ cfg . boostrapServers } \" ) // You can set spring configuration key // at this stage kafka is available } . withWireMock ( port = 9090 ) . systemUnderTest ( runner = { parameters -> stove . spring . example . run ( parameters ) { it . addTestSystemDependencies () } }, withParameters = listOf ( \"server.port=8001\" , \"logging.level.root=warn\" , \"logging.level.org.springframework.web=warn\" , \"spring.profiles.active=default\" , \"kafka.heartbeatInSeconds=2\" ) ) . run () } override fun extensions (): List < Extension > { val listener = object : AfterTestListener { override suspend fun afterTest ( testCase : TestCase , result : TestResult , ) { TestSystem . instance . wiremock (). validate () } } return listOf ( listener ) } override suspend fun afterProject () { TestSystem . instance . close () } } Here you can see that there are configuration callbacks for the dependencies. For example: . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" , \"couchbase.username= ${ cfg . username } \" , \"couchbase.password= ${ cfg . password } \" ) } Note The Couchbase configuration name in the application.yml is couchbase.hosts , this might differ for your project. Stove exposes the generated configuration by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. So, your application will start with the physical dependencies that are spun-up by the framework. Configuring systemUnderTest \u00b6 We may know the concept of service under test from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called systemUnderTest Every TestSystem must have a system under test , and configure it. In here we're configuring a Spring application under test . systemUnderTest configures how to run the application. runner parameter is the entrance point for the Spring application that we have configured at step 1 Note server.port=8001 is a Spring config, TestSystem's baseUrl needs to match with it, since Http requests are made against the baseUrl that is defined. withDefaultHttp creates a WebClient and uses the baseUrl that is passed.","title":"Configuring the framework"},{"location":"0005-configuring-the-framework/#configuring-the-framework","text":"After you've added the dependencies from Stove, it is time to construct he config that runs the physical dependencies. Warning We assume that you're using Kotest test framework, the following configuration is applicable for Kotest but, it should be available in any test framework.","title":"Configuring the framework"},{"location":"0005-configuring-the-framework/#create-a-testsystemconfigkt-class","text":"Here you can see an example TestSystemConfig that is located under test-e2e module. It implements AbstractProjectConfig from Kotest framework that allows us to spin up the dependencies we need. As a side note, they are pluggable extensions, so if you don't want to add the dependency just comment the invocation out. But, be careful, you won't be able to use it in testing since you didn't enable the dependency. class TestSystemConfig : AbstractProjectConfig () { override suspend fun beforeProject () { TestSystem ( baseUrl = \"http://localhost:8001\" ) . withDefaultHttp () . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" ) // You can set spring configuration key // at this stage couchbase is available } . withKafka { cfg -> listOf ( \"kafka.bootstrapServers= ${ cfg . boostrapServers } \" ) // You can set spring configuration key // at this stage kafka is available } . withWireMock ( port = 9090 ) . systemUnderTest ( runner = { parameters -> stove . spring . example . run ( parameters ) { it . addTestSystemDependencies () } }, withParameters = listOf ( \"server.port=8001\" , \"logging.level.root=warn\" , \"logging.level.org.springframework.web=warn\" , \"spring.profiles.active=default\" , \"kafka.heartbeatInSeconds=2\" ) ) . run () } override fun extensions (): List < Extension > { val listener = object : AfterTestListener { override suspend fun afterTest ( testCase : TestCase , result : TestResult , ) { TestSystem . instance . wiremock (). validate () } } return listOf ( listener ) } override suspend fun afterProject () { TestSystem . instance . close () } } Here you can see that there are configuration callbacks for the dependencies. For example: . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" , \"couchbase.username= ${ cfg . username } \" , \"couchbase.password= ${ cfg . password } \" ) } Note The Couchbase configuration name in the application.yml is couchbase.hosts , this might differ for your project. Stove exposes the generated configuration by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. So, your application will start with the physical dependencies that are spun-up by the framework.","title":"Create a TestSystemConfig.kt class"},{"location":"0005-configuring-the-framework/#configuring-systemundertest","text":"We may know the concept of service under test from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called systemUnderTest Every TestSystem must have a system under test , and configure it. In here we're configuring a Spring application under test . systemUnderTest configures how to run the application. runner parameter is the entrance point for the Spring application that we have configured at step 1 Note server.port=8001 is a Spring config, TestSystem's baseUrl needs to match with it, since Http requests are made against the baseUrl that is defined. withDefaultHttp creates a WebClient and uses the baseUrl that is passed.","title":"Configuring systemUnderTest"},{"location":"0006-writing-tests/","text":"Writing Tests \u00b6 Here is an example test: Validates http://localhost:$port/hello/index returns the expected text A dependent service with \"/example-url\" returns 200 status Couchbase up and running because we can query system:keyspaces TestSystem . instance . defaultHttp (). get < String > ( \"/hello/index\" ) { actual -> actual shouldContain \"Hi from Stove framework\" println ( actual ) } . then (). wiremock (). mockGet ( \"/example-url\" , responseBody = None , statusCode = 200 ) . then (). couchbase (). shouldQuery < Any > ( \"SELECT * FROM system:keyspaces\" ) { actual -> println ( actual ) } . then (). kafka () . shouldBePublished < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . shouldBeSuccessfullyConsumed < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . then (). couchbase (). save ( collection = \"Backlogs\" , id = \"id-of-backlog\" , instance = Backlog ( \"id-of-backlog\" )) . then (). defaultHttp (). postAndExpectBodilessResponse ( \"/backlog/reserve\" ) { actual -> actual . status . shouldBe ( 200 ) } . then (). kafka (). shouldBeConsumedOnCondition < ProductCreated > { actual -> actual . aggregateId == expectedId } Note FunSpec , shouldContain infix methods are coming from Kotest Replacing dependencies for better testability \u00b6 When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is advancing the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented. For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation. class BackgroundCommandBusImpl // is the class for delayed operations We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write: class NoDelayBackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher : BackgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage : BackgroundMessageEnvelopeStorage , lockProvider : CouchbaseLockProvider , ) : BackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage , lockProvider ) { override suspend fun < TNotification : BackgroundNotification > publish ( notification : TNotification , options : BackgroundOptions , ) { super . publish ( notification , options . withDelay ( 0 )) } override suspend fun < TCommand : BackgroundCommand > send ( command : TCommand , options : BackgroundOptions , ) { super . send ( command , options . withDelay ( 0 )) } } Now, it is time to tell to e2eTest system to use NoDelay implementation. That brings us to initializers. Writing a TestInitializer \u00b6 The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective. e2e Testing has dependencies: ObjectMapper , you can either provide the ObjectMapper you have already in here we get existing bean by ref(\"objectMapper\") TestSystemConsumerInterceptor is for being able to check consumed messages StoveSpringKafkaProducer to the able to publish messages to Kafka, so messages can route to the listeners in the application you're testing. class TestInitializer : BaseApplicationContextInitializer ({ bean < TestSystemConsumerInterceptor > ( isPrimary = true ) bean < StoveSpringKafkaProducer > ( isPrimary = true ) bean < ObjectMapper > { ref ( \"objectMapper\" ) } // \"objectMapper\" bean name should be in your spring context otherwise it will fail, if not you can provide an instance here. // Be sure that, Couchbase, Kafka and other systems share the same serialization strategy. bean < NoDelayBackgroundCommandBusImpl > ( isPrimary = true ) // Optional dependency to alter delayed implementation with 0-wait. }) fun SpringApplication . addTestDependencies () { this . addInitializers ( TestInitializer ()) } addTestDependencies is an extension that helps us to register our dependencies in the application. . systemUnderTest ( runner = { parameters -> com . trendyol . qc . internationalservice . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) )","title":"Writing Tests"},{"location":"0006-writing-tests/#writing-tests","text":"Here is an example test: Validates http://localhost:$port/hello/index returns the expected text A dependent service with \"/example-url\" returns 200 status Couchbase up and running because we can query system:keyspaces TestSystem . instance . defaultHttp (). get < String > ( \"/hello/index\" ) { actual -> actual shouldContain \"Hi from Stove framework\" println ( actual ) } . then (). wiremock (). mockGet ( \"/example-url\" , responseBody = None , statusCode = 200 ) . then (). couchbase (). shouldQuery < Any > ( \"SELECT * FROM system:keyspaces\" ) { actual -> println ( actual ) } . then (). kafka () . shouldBePublished < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . shouldBeSuccessfullyConsumed < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . then (). couchbase (). save ( collection = \"Backlogs\" , id = \"id-of-backlog\" , instance = Backlog ( \"id-of-backlog\" )) . then (). defaultHttp (). postAndExpectBodilessResponse ( \"/backlog/reserve\" ) { actual -> actual . status . shouldBe ( 200 ) } . then (). kafka (). shouldBeConsumedOnCondition < ProductCreated > { actual -> actual . aggregateId == expectedId } Note FunSpec , shouldContain infix methods are coming from Kotest","title":"Writing Tests"},{"location":"0006-writing-tests/#replacing-dependencies-for-better-testability","text":"When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is advancing the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented. For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation. class BackgroundCommandBusImpl // is the class for delayed operations We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write: class NoDelayBackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher : BackgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage : BackgroundMessageEnvelopeStorage , lockProvider : CouchbaseLockProvider , ) : BackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage , lockProvider ) { override suspend fun < TNotification : BackgroundNotification > publish ( notification : TNotification , options : BackgroundOptions , ) { super . publish ( notification , options . withDelay ( 0 )) } override suspend fun < TCommand : BackgroundCommand > send ( command : TCommand , options : BackgroundOptions , ) { super . send ( command , options . withDelay ( 0 )) } } Now, it is time to tell to e2eTest system to use NoDelay implementation. That brings us to initializers.","title":"Replacing dependencies for better testability"},{"location":"0006-writing-tests/#writing-a-testinitializer","text":"The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective. e2e Testing has dependencies: ObjectMapper , you can either provide the ObjectMapper you have already in here we get existing bean by ref(\"objectMapper\") TestSystemConsumerInterceptor is for being able to check consumed messages StoveSpringKafkaProducer to the able to publish messages to Kafka, so messages can route to the listeners in the application you're testing. class TestInitializer : BaseApplicationContextInitializer ({ bean < TestSystemConsumerInterceptor > ( isPrimary = true ) bean < StoveSpringKafkaProducer > ( isPrimary = true ) bean < ObjectMapper > { ref ( \"objectMapper\" ) } // \"objectMapper\" bean name should be in your spring context otherwise it will fail, if not you can provide an instance here. // Be sure that, Couchbase, Kafka and other systems share the same serialization strategy. bean < NoDelayBackgroundCommandBusImpl > ( isPrimary = true ) // Optional dependency to alter delayed implementation with 0-wait. }) fun SpringApplication . addTestDependencies () { this . addInitializers ( TestInitializer ()) } addTestDependencies is an extension that helps us to register our dependencies in the application. . systemUnderTest ( runner = { parameters -> com . trendyol . qc . internationalservice . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) )","title":"Writing a TestInitializer"},{"location":"0007-dependency-tuning/","text":"Tuning the dependency configurations for better testing performance \u00b6 Kafka \u00b6 There might be a potential improvement on the configuration for better testing results that can improve the testing performance. If you have the following configurations: AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" You better make them configurable, so from the e2e testing context we can change them to improve testing performance. As an example: TestSystem () . withDefaultHttp () . withCouchbase ( \"International\" ) . withKafka () . withWireMock ( 9090 ) . withSchedulerSystem () . systemUnderTest ( runner = { parameters -> com . trendyol . qc . internationalservice . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) ). run ()","title":"Tuning the dependency configurations for better testing performance"},{"location":"0007-dependency-tuning/#tuning-the-dependency-configurations-for-better-testing-performance","text":"","title":"Tuning the dependency configurations for better testing performance"},{"location":"0007-dependency-tuning/#kafka","text":"There might be a potential improvement on the configuration for better testing results that can improve the testing performance. If you have the following configurations: AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" You better make them configurable, so from the e2e testing context we can change them to improve testing performance. As an example: TestSystem () . withDefaultHttp () . withCouchbase ( \"International\" ) . withKafka () . withWireMock ( 9090 ) . withSchedulerSystem () . systemUnderTest ( runner = { parameters -> com . trendyol . qc . internationalservice . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) ). run ()","title":"Kafka"},{"location":"0008-extras/","text":"Extras \u00b6 Writing your own TestSystem \u00b6 You can write your own system to plug to the testing suite. As an example: fun TestSystem . withSchedulerSystem (): TestSystem { getOrRegister ( SchedulerSystem ( this )) return this } fun TestSystem . scheduler (): SchedulerSystem = getOrNone < SchedulerSystem > (). getOrElse { throw SystemNotRegisteredException ( SchedulerSystem :: class ) } class SchedulerSystem ( override val testSystem : TestSystem ) : AfterRunAware < ApplicationContext > , PluggedSystem { private lateinit var scheduler : WaitingRoomScheduler private lateinit var backgroundCommandBus : BackgroundCommandBusImpl fun advance (): SchedulerSystem { scheduler . publishValidProducts () return this } fun advanceBackgroundCommandBus (): SchedulerSystem { backgroundCommandBus . dispatchTimeoutNotifications () return this } override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () } override fun close () {} } Later you can use it in testing; . then (). scheduler (). advance () Accessing an application dependency with a system \u00b6 As you can see, in the example above, if a system implements AfterRunAware<ApplicationContext> then, afterRun method becomes available, in here we have access to applications dependency container to resolve any bean we need to use. override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () }","title":"Extras"},{"location":"0008-extras/#extras","text":"","title":"Extras"},{"location":"0008-extras/#writing-your-own-testsystem","text":"You can write your own system to plug to the testing suite. As an example: fun TestSystem . withSchedulerSystem (): TestSystem { getOrRegister ( SchedulerSystem ( this )) return this } fun TestSystem . scheduler (): SchedulerSystem = getOrNone < SchedulerSystem > (). getOrElse { throw SystemNotRegisteredException ( SchedulerSystem :: class ) } class SchedulerSystem ( override val testSystem : TestSystem ) : AfterRunAware < ApplicationContext > , PluggedSystem { private lateinit var scheduler : WaitingRoomScheduler private lateinit var backgroundCommandBus : BackgroundCommandBusImpl fun advance (): SchedulerSystem { scheduler . publishValidProducts () return this } fun advanceBackgroundCommandBus (): SchedulerSystem { backgroundCommandBus . dispatchTimeoutNotifications () return this } override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () } override fun close () {} } Later you can use it in testing; . then (). scheduler (). advance ()","title":"Writing your own TestSystem"},{"location":"0008-extras/#accessing-an-application-dependency-with-a-system","text":"As you can see, in the example above, if a system implements AfterRunAware<ApplicationContext> then, afterRun method becomes available, in here we have access to applications dependency container to resolve any bean we need to use. override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () }","title":"Accessing an application dependency with a system"}]}