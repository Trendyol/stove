{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Stove? \u00b6 Stove is an end-to-end testing framework that spins up physical dependencies and your application all together. So you have a control over dependencies via code, not with the yaml files. Your e2e testing does not need to know anything about the infra. It is pluggable . Having said that, the only dependency is docker since Stove is using testcontainers underlying. You can use JUnit and Kotest for running the tests. You can run all the tests on your CI, too. But that needs DinD( docker-in-docker) integration. How to build the source code? \u00b6 JDK 16+ Docker for running the tests (please use the latest version) ./gradlew build # that will build and run the tests Where to start? \u00b6 Address your dependencies that application under test (in other words your API/Microservice/Application) uses. Your application needs some physical dependencies to be able to run properly on any environment. If Stove has those implementations you may proceed using it. These dependencies: Couchbase Kafka for now. How to get? \u00b6 The framework still under development and is getting matured. In general it is working well and in use at Trendyol. Since it should be located under your testing context it is risk-free to apply and use, give it a try! The current version is going with strategy of SNAPSHOT hence you can get the library from the snapshot repository. Overview of the snapshot versions of Stove $version = please check the current version Gradle Maven You need to enable snapshot repository settings first to get it. Navigate to the file that you define your repositories. repositories { mavenCentral () // you probably have already maven { // code to be added url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Now, navigate to your dependencies section, and add the dependencies according to your testing needs. dependencies { testImplementation ( \"com.trendyol:stove-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-testing-e2e-http: $ version \" ) // to enable http client against your application testImplementation ( \"com.trendyol:stove-testing-e2e-couchbase: $ version \" ) // if you have couchbase dependency testImplementation ( \"com.trendyol:stove-testing-e2e-wiremock: $ version \" ) // if you want to mock external services } You need to enable snapshot repository settings in ~/.m2/settings.xml or settings.xml file in your project folder. Modifying pom.xml also works. Either way, make sure that these xml block is located in one of the places. If you can't manage please look at this StackOverflow answer. <profiles> <profile> <id> allow-snapshots </id> <activation> <activeByDefault> true </activeByDefault> </activation> <repositories> <repository> <id> snapshots-repo </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <releases><enabled> false </enabled></releases> <snapshots><enabled> true </enabled></snapshots> </repository> </repositories> </profile> </profiles> Now you can add dependencies. <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-couchbase </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-http </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-wiremock </artifactId> <version> ${stove-version} </version> </dependency> Testing Approaches \u00b6 You can start looking at the ways of testing an application with Stove. These are explained in detail under the corresponding sections. 1. Attaching with framework (recommended) \u00b6 2. Dockerized \u00b6","title":"What is Stove?"},{"location":"#what-is-stove","text":"Stove is an end-to-end testing framework that spins up physical dependencies and your application all together. So you have a control over dependencies via code, not with the yaml files. Your e2e testing does not need to know anything about the infra. It is pluggable . Having said that, the only dependency is docker since Stove is using testcontainers underlying. You can use JUnit and Kotest for running the tests. You can run all the tests on your CI, too. But that needs DinD( docker-in-docker) integration.","title":"What is Stove?"},{"location":"#how-to-build-the-source-code","text":"JDK 16+ Docker for running the tests (please use the latest version) ./gradlew build # that will build and run the tests","title":"How to build the source code?"},{"location":"#where-to-start","text":"Address your dependencies that application under test (in other words your API/Microservice/Application) uses. Your application needs some physical dependencies to be able to run properly on any environment. If Stove has those implementations you may proceed using it. These dependencies: Couchbase Kafka for now.","title":"Where to start?"},{"location":"#how-to-get","text":"The framework still under development and is getting matured. In general it is working well and in use at Trendyol. Since it should be located under your testing context it is risk-free to apply and use, give it a try! The current version is going with strategy of SNAPSHOT hence you can get the library from the snapshot repository. Overview of the snapshot versions of Stove $version = please check the current version Gradle Maven You need to enable snapshot repository settings first to get it. Navigate to the file that you define your repositories. repositories { mavenCentral () // you probably have already maven { // code to be added url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Now, navigate to your dependencies section, and add the dependencies according to your testing needs. dependencies { testImplementation ( \"com.trendyol:stove-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-testing-e2e-http: $ version \" ) // to enable http client against your application testImplementation ( \"com.trendyol:stove-testing-e2e-couchbase: $ version \" ) // if you have couchbase dependency testImplementation ( \"com.trendyol:stove-testing-e2e-wiremock: $ version \" ) // if you want to mock external services } You need to enable snapshot repository settings in ~/.m2/settings.xml or settings.xml file in your project folder. Modifying pom.xml also works. Either way, make sure that these xml block is located in one of the places. If you can't manage please look at this StackOverflow answer. <profiles> <profile> <id> allow-snapshots </id> <activation> <activeByDefault> true </activeByDefault> </activation> <repositories> <repository> <id> snapshots-repo </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <releases><enabled> false </enabled></releases> <snapshots><enabled> true </enabled></snapshots> </repository> </repositories> </profile> </profiles> Now you can add dependencies. <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-couchbase </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-http </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-wiremock </artifactId> <version> ${stove-version} </version> </dependency>","title":"How to get?"},{"location":"#testing-approaches","text":"You can start looking at the ways of testing an application with Stove. These are explained in detail under the corresponding sections.","title":"Testing Approaches"},{"location":"#1-attaching-with-framework-recommended","text":"","title":"1. Attaching with framework (recommended)"},{"location":"#2-dockerized","text":"","title":"2. Dockerized"},{"location":"abstractions/","text":"Abstractions \u00b6 There are abstractions that every component needs to implement when it joins to the framework. For example, Couchbase implements DatabaseSystem , it is an interface that defines the database operations for the e2e testings. Every physical database dependency or Pluggable Test System for a database needs to implement that interface.","title":"Abstractions"},{"location":"abstractions/#abstractions","text":"There are abstractions that every component needs to implement when it joins to the framework. For example, Couchbase implements DatabaseSystem , it is an interface that defines the database operations for the e2e testings. Every physical database dependency or Pluggable Test System for a database needs to implement that interface.","title":"Abstractions"},{"location":"abstractions/database/","text":"","title":"Database"},{"location":"abstractions/http/","text":"","title":"Http"},{"location":"abstractions/httpmock/","text":"","title":"Httpmock"},{"location":"abstractions/messaging/","text":"","title":"Messaging"},{"location":"abstractions/serialization/","text":"","title":"Serialization"},{"location":"abstractions/system/","text":"","title":"System"},{"location":"testing-approaches/","text":"Testing Approaches \u00b6 There are two ways of testing. If you are using a framework in your application for example, you may attach Stove to your application, so that you can debug and look with a magnifying glass to your code base. This is especially helpful when one wants to see how code works when the physical dependencies are present. Because, unit and integration tests stay short for the deeper insights when it comes to the behaviour of the system on production. Figuring out the dependencies \u00b6 Your project might likely have dependencies for Couchbase, Kafka, and external http services. In the application context we will spin up instances of Couchbase and Kafka but not the external http services because you don't manage them, instead we will mock them using Wiremock . Docker Dependencies \u00b6 Info You can skip this step if your registry has already the docker images Docker dependencies are already hosted on trendyol registry, you need to be logged in to YOUR_REGISTRY in your local docker to be able to pull the dependencies when the e2e tests run. docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest Note Please make sure that you tag/upload the docker images as cross build to support developers that use ARM and AMD microprocessors. In the example above, as you can see uses buildx to create/tag cross-platform docker images and pushes them directly to the registry. Choose your testing strategy \u00b6 I will attach my application to Stove E2e testing framework (recommended) I will use docker image of my application","title":"Testing Approaches"},{"location":"testing-approaches/#testing-approaches","text":"There are two ways of testing. If you are using a framework in your application for example, you may attach Stove to your application, so that you can debug and look with a magnifying glass to your code base. This is especially helpful when one wants to see how code works when the physical dependencies are present. Because, unit and integration tests stay short for the deeper insights when it comes to the behaviour of the system on production.","title":"Testing Approaches"},{"location":"testing-approaches/#figuring-out-the-dependencies","text":"Your project might likely have dependencies for Couchbase, Kafka, and external http services. In the application context we will spin up instances of Couchbase and Kafka but not the external http services because you don't manage them, instead we will mock them using Wiremock .","title":"Figuring out the dependencies"},{"location":"testing-approaches/#docker-dependencies","text":"Info You can skip this step if your registry has already the docker images Docker dependencies are already hosted on trendyol registry, you need to be logged in to YOUR_REGISTRY in your local docker to be able to pull the dependencies when the e2e tests run. docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest Note Please make sure that you tag/upload the docker images as cross build to support developers that use ARM and AMD microprocessors. In the example above, as you can see uses buildx to create/tag cross-platform docker images and pushes them directly to the registry.","title":"Docker Dependencies"},{"location":"testing-approaches/#choose-your-testing-strategy","text":"I will attach my application to Stove E2e testing framework (recommended) I will use docker image of my application","title":"Choose your testing strategy"},{"location":"testing-approaches/attaching-with-framework/","text":"Attaching with framework \u00b6 There are entry point for every application, usually a main method that is invoked, and starts the application lifecycle. If you are publishing your application/api/microservice as a docker image, docker run ... basically runs your application highly likely with a jvm/java command. In this approach, we're using the main function of your application in the test context to run the application as full-blown as if it is invoked from outside. Stove calls your application's main function like you would call java yourApplicationName.jar to run the application from the test context. So the runner is JUnit or Kotest. For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter . We will discuss this later. When to use this approach? \u00b6 This approach has lots of benefits besides of providing a debug ability while e2e testing. With this approach, you can: Debug the application code Replace the implementations of the interfaces. Useful for time-bounded implementation, such as schedulers, background workers, and time. Having more control over Kafka messages, you would have control over publishing and consuming, with dockerized approach you would only have consuming. Being able to use and expose application's dependency container. This is useful if you want to write your own system. Say, if you have a dependency that Stove didn't implement yet, you can go ahead and implement it yourself by using the abstractions . We will discuss it later. High level diagram:","title":"Attaching with framework"},{"location":"testing-approaches/attaching-with-framework/#attaching-with-framework","text":"There are entry point for every application, usually a main method that is invoked, and starts the application lifecycle. If you are publishing your application/api/microservice as a docker image, docker run ... basically runs your application highly likely with a jvm/java command. In this approach, we're using the main function of your application in the test context to run the application as full-blown as if it is invoked from outside. Stove calls your application's main function like you would call java yourApplicationName.jar to run the application from the test context. So the runner is JUnit or Kotest. For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter . We will discuss this later.","title":"Attaching with framework"},{"location":"testing-approaches/attaching-with-framework/#when-to-use-this-approach","text":"This approach has lots of benefits besides of providing a debug ability while e2e testing. With this approach, you can: Debug the application code Replace the implementations of the interfaces. Useful for time-bounded implementation, such as schedulers, background workers, and time. Having more control over Kafka messages, you would have control over publishing and consuming, with dockerized approach you would only have consuming. Being able to use and expose application's dependency container. This is useful if you want to write your own system. Say, if you have a dependency that Stove didn't implement yet, you can go ahead and implement it yourself by using the abstractions . We will discuss it later. High level diagram:","title":"When to use this approach?"},{"location":"testing-approaches/attaching-with-framework/ktor-application/","text":"Ktor Application \u00b6 Ktor applications tend to have an entry point. This is usually a main function that starts application with the given configuration and the collection of args . Here you can jump immediately to the example application.","title":"Ktor Application"},{"location":"testing-approaches/attaching-with-framework/ktor-application/#ktor-application","text":"Ktor applications tend to have an entry point. This is usually a main function that starts application with the given configuration and the collection of args . Here you can jump immediately to the example application.","title":"Ktor Application"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/","text":"Testing a Spring Boot Application \u00b6 Spring-Boot applications tend to have an entry point. This is usually a main function that starts application with the given configuration. Here you can jump immediately to the example application","title":"Testing a Spring Boot Application"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/#testing-a-spring-boot-application","text":"Spring-Boot applications tend to have an entry point. This is usually a main function that starts application with the given configuration. Here you can jump immediately to the example application","title":"Testing a Spring Boot Application"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0001-tuning-app/","text":"Tuning the application's entry point \u00b6 In a Spring application you usually have an entry point. If we assume that you application has a standard main function, here how we will change it: Before After @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { runApplication < ExampleApplication > ( * args ) } @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { run ( args ) } fun run ( args : Array < String > , init : SpringApplication .() -> Unit = {}, ): ConfigurableApplicationContext { return runApplication < ExampleApplication > ( * args , init = init ) } As you can see from before-after sections, we have divided the application main function into two parts. run(args, init) method is the important point for the testing configuration. init allows us to override any dependency from the testing side that is being time related or configuration related. Spring itself opens this configuration higher order function to the outside.","title":"Tuning the application's entry point"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0001-tuning-app/#tuning-the-applications-entry-point","text":"In a Spring application you usually have an entry point. If we assume that you application has a standard main function, here how we will change it: Before After @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { runApplication < ExampleApplication > ( * args ) } @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { run ( args ) } fun run ( args : Array < String > , init : SpringApplication .() -> Unit = {}, ): ConfigurableApplicationContext { return runApplication < ExampleApplication > ( * args , init = init ) } As you can see from before-after sections, we have divided the application main function into two parts. run(args, init) method is the important point for the testing configuration. init allows us to override any dependency from the testing side that is being time related or configuration related. Spring itself opens this configuration higher order function to the outside.","title":"Tuning the application's entry point"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0003-referencing-stove/","text":"Referencing Stove libraries in your project \u00b6 After you figure out the physical dependencies you can add the library dependencies of Stove. If you want to use Couchbase you should add Stove Couchbase e2e test dependency: val version = \"0.0.6-SNAPSHOT\" // Check before setting it, there might be newer version testImplementation ( \"com.trendyol:stove-spring-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-http: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-kafka: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-couchbase: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-wiremock: $ version \" )","title":"Referencing Stove libraries in your project"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0003-referencing-stove/#referencing-stove-libraries-in-your-project","text":"After you figure out the physical dependencies you can add the library dependencies of Stove. If you want to use Couchbase you should add Stove Couchbase e2e test dependency: val version = \"0.0.6-SNAPSHOT\" // Check before setting it, there might be newer version testImplementation ( \"com.trendyol:stove-spring-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-http: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-kafka: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-couchbase: $ version \" ) testImplementation ( \"com.trendyol:stove-spring-testing-e2e-wiremock: $ version \" )","title":"Referencing Stove libraries in your project"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0004-configuring-the-framework/","text":"Configuring the framework \u00b6 After you've added the dependencies from Stove, it is time to construct he config that runs the physical dependencies. Warning We assume that you're using Kotest test framework, the following configuration is applicable for Kotest but, it should be available in any test framework. Create a TestSystemConfig.kt class \u00b6 Here you can see an example TestSystemConfig that is located under test-e2e module. It implements AbstractProjectConfig from Kotest framework that allows us to spin up the dependencies we need. As a side note, they are pluggable extensions, so if you don't want to add the dependency just comment the invocation out. But, be careful, you won't be able to use it in testing since you didn't enable the dependency. class TestSystemConfig : AbstractProjectConfig () { override suspend fun beforeProject () { TestSystem ( baseUrl = \"http://localhost:8001\" ) . withDefaultHttp () . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" ) // You can set spring configuration key // at this stage couchbase is available } . withKafka { cfg -> listOf ( \"kafka.bootstrapServers= ${ cfg . boostrapServers } \" ) // You can set spring configuration key // at this stage kafka is available } . withWireMock ( port = 9090 ) . systemUnderTest ( runner = { parameters -> stove . spring . example . run ( parameters ) { it . addTestSystemDependencies () } }, withParameters = listOf ( \"server.port=8001\" , \"logging.level.root=warn\" , \"logging.level.org.springframework.web=warn\" , \"spring.profiles.active=default\" , \"kafka.heartbeatInSeconds=2\" ) ) . run () } override fun extensions (): List < Extension > { val listener = object : AfterTestListener { override suspend fun afterTest ( testCase : TestCase , result : TestResult , ) { TestSystem . instance . wiremock (). validate () } } return listOf ( listener ) } override suspend fun afterProject () { TestSystem . instance . close () } } Here you can see that there are configuration callbacks for the dependencies. For example: . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" , \"couchbase.username= ${ cfg . username } \" , \"couchbase.password= ${ cfg . password } \" ) } Note The Couchbase configuration name in the application.yml is couchbase.hosts , this might differ for your project. Stove exposes the generated configuration by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. So, your application will start with the physical dependencies that are spun-up by the framework. Configuring systemUnderTest \u00b6 We may know the concept of service under test from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called systemUnderTest Every TestSystem must have a system under test , and configure it. In here we're configuring a Spring application under test . systemUnderTest configures how to run the application. runner parameter is the entrance point for the Spring application that we have configured at step 1 Note server.port=8001 is a Spring config, TestSystem's baseUrl needs to match with it, since Http requests are made against the baseUrl that is defined. withDefaultHttp creates a WebClient and uses the baseUrl that is passed.","title":"Configuring the framework"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0004-configuring-the-framework/#configuring-the-framework","text":"After you've added the dependencies from Stove, it is time to construct he config that runs the physical dependencies. Warning We assume that you're using Kotest test framework, the following configuration is applicable for Kotest but, it should be available in any test framework.","title":"Configuring the framework"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0004-configuring-the-framework/#create-a-testsystemconfigkt-class","text":"Here you can see an example TestSystemConfig that is located under test-e2e module. It implements AbstractProjectConfig from Kotest framework that allows us to spin up the dependencies we need. As a side note, they are pluggable extensions, so if you don't want to add the dependency just comment the invocation out. But, be careful, you won't be able to use it in testing since you didn't enable the dependency. class TestSystemConfig : AbstractProjectConfig () { override suspend fun beforeProject () { TestSystem ( baseUrl = \"http://localhost:8001\" ) . withDefaultHttp () . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" ) // You can set spring configuration key // at this stage couchbase is available } . withKafka { cfg -> listOf ( \"kafka.bootstrapServers= ${ cfg . boostrapServers } \" ) // You can set spring configuration key // at this stage kafka is available } . withWireMock ( port = 9090 ) . systemUnderTest ( runner = { parameters -> stove . spring . example . run ( parameters ) { it . addTestSystemDependencies () } }, withParameters = listOf ( \"server.port=8001\" , \"logging.level.root=warn\" , \"logging.level.org.springframework.web=warn\" , \"spring.profiles.active=default\" , \"kafka.heartbeatInSeconds=2\" ) ) . run () } override fun extensions (): List < Extension > { val listener = object : AfterTestListener { override suspend fun afterTest ( testCase : TestCase , result : TestResult , ) { TestSystem . instance . wiremock (). validate () } } return listOf ( listener ) } override suspend fun afterProject () { TestSystem . instance . close () } } Here you can see that there are configuration callbacks for the dependencies. For example: . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" , \"couchbase.username= ${ cfg . username } \" , \"couchbase.password= ${ cfg . password } \" ) } Note The Couchbase configuration name in the application.yml is couchbase.hosts , this might differ for your project. Stove exposes the generated configuration by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. So, your application will start with the physical dependencies that are spun-up by the framework.","title":"Create a TestSystemConfig.kt class"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0004-configuring-the-framework/#configuring-systemundertest","text":"We may know the concept of service under test from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called systemUnderTest Every TestSystem must have a system under test , and configure it. In here we're configuring a Spring application under test . systemUnderTest configures how to run the application. runner parameter is the entrance point for the Spring application that we have configured at step 1 Note server.port=8001 is a Spring config, TestSystem's baseUrl needs to match with it, since Http requests are made against the baseUrl that is defined. withDefaultHttp creates a WebClient and uses the baseUrl that is passed.","title":"Configuring systemUnderTest"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0005-writing-tests/","text":"Writing Tests \u00b6 Here is an example test: Validates http://localhost:$port/hello/index returns the expected text A dependent service with \"/example-url\" returns 200 status Couchbase up and running because we can query system:keyspaces TestSystem . instance . defaultHttp (). get < String > ( \"/hello/index\" ) { actual -> actual shouldContain \"Hi from Stove framework\" println ( actual ) } . then (). wiremock (). mockGet ( \"/example-url\" , responseBody = None , statusCode = 200 ) . then (). couchbase (). shouldQuery < Any > ( \"SELECT * FROM system:keyspaces\" ) { actual -> println ( actual ) } . then (). kafka () . shouldBePublished < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . shouldBeSuccessfullyConsumed < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . then (). couchbase (). save ( collection = \"Backlogs\" , id = \"id-of-backlog\" , instance = Backlog ( \"id-of-backlog\" )) . then (). defaultHttp (). postAndExpectBodilessResponse ( \"/backlog/reserve\" ) { actual -> actual . status . shouldBe ( 200 ) } . then (). kafka (). shouldBeConsumedOnCondition < ProductCreated > { actual -> actual . aggregateId == expectedId } Note FunSpec , shouldContain infix methods are coming from Kotest Replacing dependencies for better testability \u00b6 When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is advancing the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented. For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation. class BackgroundCommandBusImpl // is the class for delayed operations We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write: class NoDelayBackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher : BackgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage : BackgroundMessageEnvelopeStorage , lockProvider : CouchbaseLockProvider , ) : BackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage , lockProvider ) { override suspend fun < TNotification : BackgroundNotification > publish ( notification : TNotification , options : BackgroundOptions , ) { super . publish ( notification , options . withDelay ( 0 )) } override suspend fun < TCommand : BackgroundCommand > send ( command : TCommand , options : BackgroundOptions , ) { super . send ( command , options . withDelay ( 0 )) } } Now, it is time to tell to e2eTest system to use NoDelay implementation. That brings us to initializers. Writing a TestInitializer \u00b6 The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective. e2e Testing has dependencies: ObjectMapper , you can either provide the ObjectMapper you have already in here we get existing bean by ref(\"objectMapper\") TestSystemConsumerInterceptor is for being able to check consumed messages StoveSpringKafkaProducer to the able to publish messages to Kafka, so messages can route to the listeners in the application you're testing. class TestInitializer : BaseApplicationContextInitializer ({ bean < TestSystemConsumerInterceptor > ( isPrimary = true ) bean < StoveSpringKafkaProducer > ( isPrimary = true ) bean < ObjectMapper > { ref ( \"objectMapper\" ) } // \"objectMapper\" bean name should be in your spring context otherwise it will fail, if not you can provide an instance here. // Be sure that, Couchbase, Kafka and other systems share the same serialization strategy. bean < NoDelayBackgroundCommandBusImpl > ( isPrimary = true ) // Optional dependency to alter delayed implementation with 0-wait. }) fun SpringApplication . addTestDependencies () { this . addInitializers ( TestInitializer ()) } addTestDependencies is an extension that helps us to register our dependencies in the application. . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) )","title":"Writing Tests"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0005-writing-tests/#writing-tests","text":"Here is an example test: Validates http://localhost:$port/hello/index returns the expected text A dependent service with \"/example-url\" returns 200 status Couchbase up and running because we can query system:keyspaces TestSystem . instance . defaultHttp (). get < String > ( \"/hello/index\" ) { actual -> actual shouldContain \"Hi from Stove framework\" println ( actual ) } . then (). wiremock (). mockGet ( \"/example-url\" , responseBody = None , statusCode = 200 ) . then (). couchbase (). shouldQuery < Any > ( \"SELECT * FROM system:keyspaces\" ) { actual -> println ( actual ) } . then (). kafka () . shouldBePublished < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . shouldBeSuccessfullyConsumed < ExampleMessage > { actual -> actual . aggregateId shouldBe 123 } . then (). couchbase (). save ( collection = \"Backlogs\" , id = \"id-of-backlog\" , instance = Backlog ( \"id-of-backlog\" )) . then (). defaultHttp (). postAndExpectBodilessResponse ( \"/backlog/reserve\" ) { actual -> actual . status . shouldBe ( 200 ) } . then (). kafka (). shouldBeConsumedOnCondition < ProductCreated > { actual -> actual . aggregateId == expectedId } Note FunSpec , shouldContain infix methods are coming from Kotest","title":"Writing Tests"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0005-writing-tests/#replacing-dependencies-for-better-testability","text":"When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is advancing the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented. For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation. class BackgroundCommandBusImpl // is the class for delayed operations We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write: class NoDelayBackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher : BackgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage : BackgroundMessageEnvelopeStorage , lockProvider : CouchbaseLockProvider , ) : BackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage , lockProvider ) { override suspend fun < TNotification : BackgroundNotification > publish ( notification : TNotification , options : BackgroundOptions , ) { super . publish ( notification , options . withDelay ( 0 )) } override suspend fun < TCommand : BackgroundCommand > send ( command : TCommand , options : BackgroundOptions , ) { super . send ( command , options . withDelay ( 0 )) } } Now, it is time to tell to e2eTest system to use NoDelay implementation. That brings us to initializers.","title":"Replacing dependencies for better testability"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0005-writing-tests/#writing-a-testinitializer","text":"The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective. e2e Testing has dependencies: ObjectMapper , you can either provide the ObjectMapper you have already in here we get existing bean by ref(\"objectMapper\") TestSystemConsumerInterceptor is for being able to check consumed messages StoveSpringKafkaProducer to the able to publish messages to Kafka, so messages can route to the listeners in the application you're testing. class TestInitializer : BaseApplicationContextInitializer ({ bean < TestSystemConsumerInterceptor > ( isPrimary = true ) bean < StoveSpringKafkaProducer > ( isPrimary = true ) bean < ObjectMapper > { ref ( \"objectMapper\" ) } // \"objectMapper\" bean name should be in your spring context otherwise it will fail, if not you can provide an instance here. // Be sure that, Couchbase, Kafka and other systems share the same serialization strategy. bean < NoDelayBackgroundCommandBusImpl > ( isPrimary = true ) // Optional dependency to alter delayed implementation with 0-wait. }) fun SpringApplication . addTestDependencies () { this . addInitializers ( TestInitializer ()) } addTestDependencies is an extension that helps us to register our dependencies in the application. . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) )","title":"Writing a TestInitializer"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0006-dependency-tuning/","text":"Tuning the dependency configurations for better testing performance \u00b6 Kafka \u00b6 There might be a potential improvement on the configuration for better testing results that can improve the testing performance. If you have the following configurations: AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" You better make them configurable, so from the e2e testing context we can change them to improve testing performance. As an example: TestSystem () . withDefaultHttp () . withCouchbase ( \"International\" ) . withKafka () . withWireMock ( 9090 ) . withSchedulerSystem () . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) ). run ()","title":"Tuning the dependency configurations for better testing performance"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0006-dependency-tuning/#tuning-the-dependency-configurations-for-better-testing-performance","text":"","title":"Tuning the dependency configurations for better testing performance"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0006-dependency-tuning/#kafka","text":"There might be a potential improvement on the configuration for better testing results that can improve the testing performance. If you have the following configurations: AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" You better make them configurable, so from the e2e testing context we can change them to improve testing performance. As an example: TestSystem () . withDefaultHttp () . withCouchbase ( \"International\" ) . withKafka () . withWireMock ( 9090 ) . withSchedulerSystem () . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) ). run ()","title":"Kafka"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0007-extras/","text":"Extras \u00b6 Writing your own TestSystem \u00b6 You can write your own system to plug to the testing suite. As an example: fun TestSystem . withSchedulerSystem (): TestSystem { getOrRegister ( SchedulerSystem ( this )) return this } fun TestSystem . scheduler (): SchedulerSystem = getOrNone < SchedulerSystem > (). getOrElse { throw SystemNotRegisteredException ( SchedulerSystem :: class ) } class SchedulerSystem ( override val testSystem : TestSystem ) : AfterRunAware < ApplicationContext > , PluggedSystem { private lateinit var scheduler : WaitingRoomScheduler private lateinit var backgroundCommandBus : BackgroundCommandBusImpl fun advance (): SchedulerSystem { scheduler . publishValidProducts () return this } fun advanceBackgroundCommandBus (): SchedulerSystem { backgroundCommandBus . dispatchTimeoutNotifications () return this } override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () } override fun close () {} } Later you can use it in testing; . then (). scheduler (). advance () Accessing an application dependency with a system \u00b6 As you can see, in the example above, if a system implements AfterRunAware<ApplicationContext> then, afterRun method becomes available, in here we have access to applications dependency container to resolve any bean we need to use. override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () }","title":"Extras"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0007-extras/#extras","text":"","title":"Extras"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0007-extras/#writing-your-own-testsystem","text":"You can write your own system to plug to the testing suite. As an example: fun TestSystem . withSchedulerSystem (): TestSystem { getOrRegister ( SchedulerSystem ( this )) return this } fun TestSystem . scheduler (): SchedulerSystem = getOrNone < SchedulerSystem > (). getOrElse { throw SystemNotRegisteredException ( SchedulerSystem :: class ) } class SchedulerSystem ( override val testSystem : TestSystem ) : AfterRunAware < ApplicationContext > , PluggedSystem { private lateinit var scheduler : WaitingRoomScheduler private lateinit var backgroundCommandBus : BackgroundCommandBusImpl fun advance (): SchedulerSystem { scheduler . publishValidProducts () return this } fun advanceBackgroundCommandBus (): SchedulerSystem { backgroundCommandBus . dispatchTimeoutNotifications () return this } override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () } override fun close () {} } Later you can use it in testing; . then (). scheduler (). advance ()","title":"Writing your own TestSystem"},{"location":"testing-approaches/attaching-with-framework/spring-boot-application/0007-extras/#accessing-an-application-dependency-with-a-system","text":"As you can see, in the example above, if a system implements AfterRunAware<ApplicationContext> then, afterRun method becomes available, in here we have access to applications dependency container to resolve any bean we need to use. override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () }","title":"Accessing an application dependency with a system"},{"location":"testing-approaches/dockerized/","text":"Dockerized Testing \u00b6 In this approach, your application does not have any part that is exposed to Stove, and Stove will not attach to application. You could provide a docker image of your application, Stove will spin up the application and its dependencies. This is on the roadmap, and not implemented yet.","title":"Dockerized Testing"},{"location":"testing-approaches/dockerized/#dockerized-testing","text":"In this approach, your application does not have any part that is exposed to Stove, and Stove will not attach to application. You could provide a docker image of your application, Stove will spin up the application and its dependencies. This is on the roadmap, and not implemented yet.","title":"Dockerized Testing"}]}