{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Stove? \u00b6 Stove is an end-to-end testing framework that spins up physical dependencies and your application all together. So you have a control over dependencies via Kotlin code. Your tests will be infra agnostic, but component aware, so they can use easily necessary physical components with Stove provided APIs. All the infra is pluggable , and can be added easily. You can also create your own infra needs by using the abstractions that Stove provides. Having said that, the only dependency is docker since Stove is using testcontainers underlying. You can use JUnit and Kotest for running the tests. You can run all the tests on your CI, too. But that needs DinD( docker-in-docker) integration. How to build the source code? \u00b6 JDK 16+ Docker for running the tests (please use the latest version) ./gradlew build # that will build and run the tests How to get? \u00b6 The framework still under development and is getting matured. In general it is working well and in use at Trendyol. Since it should be located under your testing context it is risk-free to apply and use, give it a try! The current version is going with strategy of SNAPSHOT hence you can get the library from the snapshot repository. Overview of the snapshot versions of Stove $version = please check the current version Gradle Maven You need to enable snapshot repository settings first to get it. Navigate to the file that you define your repositories. repositories { mavenCentral () // you probably have already maven { // code to be added url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Now, navigate to your dependencies section, and add the dependencies according to your testing needs. dependencies { testImplementation ( \"com.trendyol:stove-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-testing-e2e-http: $ version \" ) // to enable http client against your application testImplementation ( \"com.trendyol:stove-testing-e2e-couchbase: $ version \" ) // if you have couchbase dependency testImplementation ( \"com.trendyol:stove-testing-e2e-wiremock: $ version \" ) // if you want to mock external services } You need to enable snapshot repository settings in ~/.m2/settings.xml or settings.xml file in your project folder. Modifying pom.xml also works. Either way, make sure that these xml block is located in one of the places. If you can't manage please look at this StackOverflow answer. <profiles> <profile> <id> allow-snapshots </id> <activation> <activeByDefault> true </activeByDefault> </activation> <repositories> <repository> <id> snapshots-repo </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <releases><enabled> false </enabled></releases> <snapshots><enabled> true </enabled></snapshots> </repository> </repositories> </profile> </profiles> Now you can add dependencies. <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-couchbase </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-http </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-wiremock </artifactId> <version> ${stove-version} </version> </dependency> How To Write Tests? \u00b6 You can start looking at the ways of testing an application with Stove. These are explained in detail under the corresponding sections. 1. Attaching with the application (recommended) \u00b6 2. Dockerized \u00b6","title":"What is Stove?"},{"location":"#what-is-stove","text":"Stove is an end-to-end testing framework that spins up physical dependencies and your application all together. So you have a control over dependencies via Kotlin code. Your tests will be infra agnostic, but component aware, so they can use easily necessary physical components with Stove provided APIs. All the infra is pluggable , and can be added easily. You can also create your own infra needs by using the abstractions that Stove provides. Having said that, the only dependency is docker since Stove is using testcontainers underlying. You can use JUnit and Kotest for running the tests. You can run all the tests on your CI, too. But that needs DinD( docker-in-docker) integration.","title":"What is Stove?"},{"location":"#how-to-build-the-source-code","text":"JDK 16+ Docker for running the tests (please use the latest version) ./gradlew build # that will build and run the tests","title":"How to build the source code?"},{"location":"#how-to-get","text":"The framework still under development and is getting matured. In general it is working well and in use at Trendyol. Since it should be located under your testing context it is risk-free to apply and use, give it a try! The current version is going with strategy of SNAPSHOT hence you can get the library from the snapshot repository. Overview of the snapshot versions of Stove $version = please check the current version Gradle Maven You need to enable snapshot repository settings first to get it. Navigate to the file that you define your repositories. repositories { mavenCentral () // you probably have already maven { // code to be added url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } Now, navigate to your dependencies section, and add the dependencies according to your testing needs. dependencies { testImplementation ( \"com.trendyol:stove-testing-e2e: $ version \" ) testImplementation ( \"com.trendyol:stove-testing-e2e-http: $ version \" ) // to enable http client against your application testImplementation ( \"com.trendyol:stove-testing-e2e-couchbase: $ version \" ) // if you have couchbase dependency testImplementation ( \"com.trendyol:stove-testing-e2e-wiremock: $ version \" ) // if you want to mock external services } You need to enable snapshot repository settings in ~/.m2/settings.xml or settings.xml file in your project folder. Modifying pom.xml also works. Either way, make sure that these xml block is located in one of the places. If you can't manage please look at this StackOverflow answer. <profiles> <profile> <id> allow-snapshots </id> <activation> <activeByDefault> true </activeByDefault> </activation> <repositories> <repository> <id> snapshots-repo </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <releases><enabled> false </enabled></releases> <snapshots><enabled> true </enabled></snapshots> </repository> </repositories> </profile> </profiles> Now you can add dependencies. <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-couchbase </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-http </artifactId> <version> ${stove-version} </version> </dependency> <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-testing-e2e-wiremock </artifactId> <version> ${stove-version} </version> </dependency>","title":"How to get?"},{"location":"#how-to-write-tests","text":"You can start looking at the ways of testing an application with Stove. These are explained in detail under the corresponding sections.","title":"How To Write Tests?"},{"location":"#1-attaching-with-the-application-recommended","text":"","title":"1. Attaching with the application (recommended)"},{"location":"#2-dockerized","text":"","title":"2. Dockerized"},{"location":"abstractions/","text":"Abstractions \u00b6 There are abstractions that every component needs to implement when it joins to the framework. For example, Couchbase implements DatabaseSystem , it is an interface that defines the database operations for the e2e testings. Every physical database dependency or Pluggable Test System for a database needs to implement that interface.","title":"Abstractions"},{"location":"abstractions/#abstractions","text":"There are abstractions that every component needs to implement when it joins to the framework. For example, Couchbase implements DatabaseSystem , it is an interface that defines the database operations for the e2e testings. Every physical database dependency or Pluggable Test System for a database needs to implement that interface.","title":"Abstractions"},{"location":"abstractions/database/","text":"","title":"Database"},{"location":"abstractions/http/","text":"","title":"Http"},{"location":"abstractions/httpmock/","text":"","title":"Httpmock"},{"location":"abstractions/messaging/","text":"","title":"Messaging"},{"location":"abstractions/serialization/","text":"","title":"Serialization"},{"location":"abstractions/system/","text":"","title":"System"},{"location":"how-to-write-tests/","text":"How To Write Tests? \u00b6 There are two ways of testing. If you are using a framework in your application for example, you may attach Stove to your application, so that you can debug and look with a magnifying glass to your code base. This is especially helpful when one wants to see how code works when the physical dependencies are present. Because, unit and integration tests stay short for the deeper insights when it comes to the behaviour of the system on production. Figuring out the dependencies \u00b6 Your project might likely have dependencies for Couchbase, Kafka, and external http services. In the application context we will spin up instances of Couchbase and Kafka but not the external http services because you don't manage them, instead we will mock them using Wiremock . Docker Dependencies \u00b6 Info You can skip this step if your registry has already the docker images Docker dependencies are already hosted on trendyol registry, you need to be logged in to YOUR_REGISTRY in your local docker to be able to pull the dependencies when the e2e tests run. docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest Note Please make sure that you tag/upload the docker images as cross build to support developers that use ARM and AMD microprocessors. In the example above, as you can see uses buildx to create/tag cross-platform docker images and pushes them directly to the registry. Choose your testing strategy \u00b6 I will attach my application to Stove E2e testing framework (recommended) I will use docker image of my application","title":"How To Write Tests?"},{"location":"how-to-write-tests/#how-to-write-tests","text":"There are two ways of testing. If you are using a framework in your application for example, you may attach Stove to your application, so that you can debug and look with a magnifying glass to your code base. This is especially helpful when one wants to see how code works when the physical dependencies are present. Because, unit and integration tests stay short for the deeper insights when it comes to the behaviour of the system on production.","title":"How To Write Tests?"},{"location":"how-to-write-tests/#figuring-out-the-dependencies","text":"Your project might likely have dependencies for Couchbase, Kafka, and external http services. In the application context we will spin up instances of Couchbase and Kafka but not the external http services because you don't manage them, instead we will mock them using Wiremock .","title":"Figuring out the dependencies"},{"location":"how-to-write-tests/#docker-dependencies","text":"Info You can skip this step if your registry has already the docker images Docker dependencies are already hosted on trendyol registry, you need to be logged in to YOUR_REGISTRY in your local docker to be able to pull the dependencies when the e2e tests run. docker buildx imagetools create confluentinc/cp-kafka:latest --tag YOUR_REGISTRY/confluentinc/cp-kafka:latest docker buildx imagetools create couchbase/server:latest --tag YOUR_REGISTRY/couchbase/server:latest Note Please make sure that you tag/upload the docker images as cross build to support developers that use ARM and AMD microprocessors. In the example above, as you can see uses buildx to create/tag cross-platform docker images and pushes them directly to the registry.","title":"Docker Dependencies"},{"location":"how-to-write-tests/#choose-your-testing-strategy","text":"I will attach my application to Stove E2e testing framework (recommended) I will use docker image of my application","title":"Choose your testing strategy"},{"location":"how-to-write-tests/Application-Aware/","text":"Application Aware Testing \u00b6 There are entry point for every application, usually a main method that is invoked, and starts the application lifecycle. If you are publishing your application/api/microservice as a docker image, docker run ... basically runs your application highly likely with a jvm/java command. In this approach, we're using the main function of your application in the test context to run the application as full-blown as if it is invoked from outside. Stove calls your application's main function like you would call java yourApplicationName.jar to run the application from the test context. So the runner is JUnit or Kotest. For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter . We will discuss this later. When to use this approach? \u00b6 This approach has lots of benefits besides of providing a debug ability while e2e testing. With this approach, you can: Debug the application code Replace the implementations of the interfaces. Useful for time-bounded implementation, such as schedulers, background workers, and time. Having more control over Kafka messages, you would have control over publishing and consuming, with dockerized approach you would only have consuming. Being able to use and expose application's dependency container. This is useful if you want to write your own system. Say, if you have a dependency that Stove didn't implement yet, you can go ahead and implement it yourself by using the abstractions . We will discuss it later. High level diagram:","title":"Application Aware Testing"},{"location":"how-to-write-tests/Application-Aware/#application-aware-testing","text":"There are entry point for every application, usually a main method that is invoked, and starts the application lifecycle. If you are publishing your application/api/microservice as a docker image, docker run ... basically runs your application highly likely with a jvm/java command. In this approach, we're using the main function of your application in the test context to run the application as full-blown as if it is invoked from outside. Stove calls your application's main function like you would call java yourApplicationName.jar to run the application from the test context. So the runner is JUnit or Kotest. For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter . We will discuss this later.","title":"Application Aware Testing"},{"location":"how-to-write-tests/Application-Aware/#when-to-use-this-approach","text":"This approach has lots of benefits besides of providing a debug ability while e2e testing. With this approach, you can: Debug the application code Replace the implementations of the interfaces. Useful for time-bounded implementation, such as schedulers, background workers, and time. Having more control over Kafka messages, you would have control over publishing and consuming, with dockerized approach you would only have consuming. Being able to use and expose application's dependency container. This is useful if you want to write your own system. Say, if you have a dependency that Stove didn't implement yet, you can go ahead and implement it yourself by using the abstractions . We will discuss it later. High level diagram:","title":"When to use this approach?"},{"location":"how-to-write-tests/Application-Aware/Ktor/","text":"Testing a Ktor Application \u00b6 Ktor applications tend to have an entry point. This is usually a main function that starts application with the given configuration and the collection of args . Here you can jump immediately to the example application.","title":"Testing a Ktor Application"},{"location":"how-to-write-tests/Application-Aware/Ktor/#testing-a-ktor-application","text":"Ktor applications tend to have an entry point. This is usually a main function that starts application with the given configuration and the collection of args . Here you can jump immediately to the example application.","title":"Testing a Ktor Application"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/","text":"Testing a Spring Boot Application \u00b6 Spring-Boot applications tend to have an entry point. This is usually a main function that starts application with the given configuration. Here you can jump immediately to the example application. You need to add the Stove-Spring dependency to be able to write e2e tests for the Spring application. $version = please check the current version Gradle Maven dependencies { testImplementation ( \"com.trendyol:stove-spring-testing-e2e: $ version \" ) } <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-spring-testing-e2e </artifactId> <version> ${stove-version} </version> </dependency> Do not forget to add the other dependencies and configure your maven repository settings first.","title":"Testing a Spring Boot Application"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/#testing-a-spring-boot-application","text":"Spring-Boot applications tend to have an entry point. This is usually a main function that starts application with the given configuration. Here you can jump immediately to the example application. You need to add the Stove-Spring dependency to be able to write e2e tests for the Spring application. $version = please check the current version Gradle Maven dependencies { testImplementation ( \"com.trendyol:stove-spring-testing-e2e: $ version \" ) } <dependency> <groupId> com.trendyol </groupId> <artifactId> stove-spring-testing-e2e </artifactId> <version> ${stove-version} </version> </dependency> Do not forget to add the other dependencies and configure your maven repository settings first.","title":"Testing a Spring Boot Application"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0001-tuning-app/","text":"Tuning the application's entry point \u00b6 In a Spring application you usually have an entry point. If we assume that your application has a standard main function, here how we will change it: Before After @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { runApplication < ExampleApplication > ( * args ) } @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { run ( args ) } fun run ( args : Array < String > , init : SpringApplication .() -> Unit = {}, ): ConfigurableApplicationContext { return runApplication < ExampleApplication > ( * args , init = init ) } As you can see from before-after sections, we have divided the application main function into two parts. run(args, init) method is the important point for the testing configuration. init allows us to override any dependency from the testing side that is being time related or configuration related. Spring itself opens this configuration higher order function to the outside.","title":"Tuning the application's entry point"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0001-tuning-app/#tuning-the-applications-entry-point","text":"In a Spring application you usually have an entry point. If we assume that your application has a standard main function, here how we will change it: Before After @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { runApplication < ExampleApplication > ( * args ) } @SpringBootApplication class ExampleApplication fun main ( args : Array < String > ) { run ( args ) } fun run ( args : Array < String > , init : SpringApplication .() -> Unit = {}, ): ConfigurableApplicationContext { return runApplication < ExampleApplication > ( * args , init = init ) } As you can see from before-after sections, we have divided the application main function into two parts. run(args, init) method is the important point for the testing configuration. init allows us to override any dependency from the testing side that is being time related or configuration related. Spring itself opens this configuration higher order function to the outside.","title":"Tuning the application's entry point"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0002-initial-configuration/","text":"Initial Configuration \u00b6 After you've added the dependencies, and configured the application's main function, it is time to run your application for the first time from the test-context with Stove. Note At this stage you can create a new e2e testing module, or use your existing test module in your project. Setting up Stove for the Runner \u00b6 Kotest JUnit It implements AbstractProjectConfig from Kotest framework that allows us to spin up Stove per run. This is project wide operation and executes only one time , as the name implies beforeProject . class TestSystemConfig : AbstractProjectConfig () { override suspend fun beforeProject () { TestSystem ( baseUrl = \"http://localhost:8001\" ) . withHttpClient () . systemUnderTest ( runner = { parameters -> /* * As you remember, we have divided application's main * function into two parts, main and run. * We use `run` invocation here. * */ stove . spring . example . run ( parameters ) }, withParameters = listOf ( \"server.port=8001\" , \"logging.level.root=warn\" , \"logging.level.org.springframework.web=warn\" , \"spring.profiles.active=default\" ) ) . run () } override suspend fun afterProject () { TestSystem . instance . close () } } // TODO Configuring systemUnderTest \u00b6 We may know the concept of service under test from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called systemUnderTest Every TestSystem must have a system under test , and configure it. In here we're configuring a Spring application under test . systemUnderTest configures how to run the application. runner parameter is the entrance point for the Spring application that we have configured at step 1 Note server.port=8001 is a Spring config, TestSystem's baseUrl needs to match with it, since Http requests are made against the baseUrl that is defined. withDefaultHttp creates a WebClient and uses the baseUrl that is passed.","title":"Initial Configuration"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0002-initial-configuration/#initial-configuration","text":"After you've added the dependencies, and configured the application's main function, it is time to run your application for the first time from the test-context with Stove. Note At this stage you can create a new e2e testing module, or use your existing test module in your project.","title":"Initial Configuration"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0002-initial-configuration/#setting-up-stove-for-the-runner","text":"Kotest JUnit It implements AbstractProjectConfig from Kotest framework that allows us to spin up Stove per run. This is project wide operation and executes only one time , as the name implies beforeProject . class TestSystemConfig : AbstractProjectConfig () { override suspend fun beforeProject () { TestSystem ( baseUrl = \"http://localhost:8001\" ) . withHttpClient () . systemUnderTest ( runner = { parameters -> /* * As you remember, we have divided application's main * function into two parts, main and run. * We use `run` invocation here. * */ stove . spring . example . run ( parameters ) }, withParameters = listOf ( \"server.port=8001\" , \"logging.level.root=warn\" , \"logging.level.org.springframework.web=warn\" , \"spring.profiles.active=default\" ) ) . run () } override suspend fun afterProject () { TestSystem . instance . close () } } // TODO","title":"Setting up Stove for the Runner"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0002-initial-configuration/#configuring-systemundertest","text":"We may know the concept of service under test from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called systemUnderTest Every TestSystem must have a system under test , and configure it. In here we're configuring a Spring application under test . systemUnderTest configures how to run the application. runner parameter is the entrance point for the Spring application that we have configured at step 1 Note server.port=8001 is a Spring config, TestSystem's baseUrl needs to match with it, since Http requests are made against the baseUrl that is defined. withDefaultHttp creates a WebClient and uses the baseUrl that is passed.","title":"Configuring systemUnderTest"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0003-writing-tests/","text":"Writing Tests \u00b6 Here is an example test that validates http://localhost:$port/hello/index returns the expected text Kotest JUnit class ExampleTest : FuncSpec ({ test ( \"should return hi\" ){ TestSystem . instance . http (). get < String > ( \"/hello/index\" ) { actual -> actual shouldContain \"Hi from Stove framework\" } } }) class ExampleTest { @Test fun `should return hi` () { TestSystem . instance . http (). get < String > ( \"/hello/index\" ) { actual -> assertTrue ( actual . contains ( \"Hi from Stove framework\" )) } } }) That's it! You have up-and-running API, can be tested with Stove.","title":"Writing Tests"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/0003-writing-tests/#writing-tests","text":"Here is an example test that validates http://localhost:$port/hello/index returns the expected text Kotest JUnit class ExampleTest : FuncSpec ({ test ( \"should return hi\" ){ TestSystem . instance . http (). get < String > ( \"/hello/index\" ) { actual -> actual shouldContain \"Hi from Stove framework\" } } }) class ExampleTest { @Test fun `should return hi` () { TestSystem . instance . http (). get < String > ( \"/hello/index\" ) { actual -> assertTrue ( actual . contains ( \"Hi from Stove framework\" )) } } }) That's it! You have up-and-running API, can be tested with Stove.","title":"Writing Tests"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/advanced/0001-Replacing%20Dependencies%20for%20Better%20Testability/","text":"Replacing Dependencies For Better Testability \u00b6 When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is advancing the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented. For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation. class BackgroundCommandBusImpl // is the class for delayed operations We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write: class NoDelayBackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher : BackgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage : BackgroundMessageEnvelopeStorage , lockProvider : CouchbaseLockProvider , ) : BackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage , lockProvider ) { override suspend fun < TNotification : BackgroundNotification > publish ( notification : TNotification , options : BackgroundOptions , ) { super . publish ( notification , options . withDelay ( 0 )) } override suspend fun < TCommand : BackgroundCommand > send ( command : TCommand , options : BackgroundOptions , ) { super . send ( command , options . withDelay ( 0 )) } } Now, it is time to tell to e2eTest system to use NoDelay implementation. That brings us to initializers.","title":"Replacing Dependencies For Better Testability"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/advanced/0001-Replacing%20Dependencies%20for%20Better%20Testability/#replacing-dependencies-for-better-testability","text":"When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is advancing the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented. For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation. class BackgroundCommandBusImpl // is the class for delayed operations We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write: class NoDelayBackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher : BackgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage : BackgroundMessageEnvelopeStorage , lockProvider : CouchbaseLockProvider , ) : BackgroundCommandBusImpl ( backgroundMessageEnvelopeDispatcher , backgroundMessageEnvelopeStorage , lockProvider ) { override suspend fun < TNotification : BackgroundNotification > publish ( notification : TNotification , options : BackgroundOptions , ) { super . publish ( notification , options . withDelay ( 0 )) } override suspend fun < TCommand : BackgroundCommand > send ( command : TCommand , options : BackgroundOptions , ) { super . send ( command , options . withDelay ( 0 )) } } Now, it is time to tell to e2eTest system to use NoDelay implementation. That brings us to initializers.","title":"Replacing Dependencies For Better Testability"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/advanced/0002-writing-your-own-test-system/","text":"Writing Your Own TestSystem \u00b6 fun TestSystem . withSchedulerSystem (): TestSystem { getOrRegister ( SchedulerSystem ( this )) return this } fun TestSystem . scheduler (): SchedulerSystem = getOrNone < SchedulerSystem > (). getOrElse { throw SystemNotRegisteredException ( SchedulerSystem :: class ) } class SchedulerSystem ( override val testSystem : TestSystem ) : AfterRunAware < ApplicationContext > , PluggedSystem { private lateinit var scheduler : WaitingRoomScheduler private lateinit var backgroundCommandBus : BackgroundCommandBusImpl fun advance (): SchedulerSystem { scheduler . publishValidProducts () return this } fun advanceBackgroundCommandBus (): SchedulerSystem { backgroundCommandBus . dispatchTimeoutNotifications () return this } override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () } override fun close () {} } Later you can use it in testing; . then (). scheduler (). advance () Accessing an application dependency with a system \u00b6 As you can see, in the example above, if a system implements AfterRunAware<ApplicationContext> then, afterRun method becomes available, in here we have access to applications dependency container to resolve any bean we need to use. override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () }","title":"Writing Your Own TestSystem"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/advanced/0002-writing-your-own-test-system/#writing-your-own-testsystem","text":"fun TestSystem . withSchedulerSystem (): TestSystem { getOrRegister ( SchedulerSystem ( this )) return this } fun TestSystem . scheduler (): SchedulerSystem = getOrNone < SchedulerSystem > (). getOrElse { throw SystemNotRegisteredException ( SchedulerSystem :: class ) } class SchedulerSystem ( override val testSystem : TestSystem ) : AfterRunAware < ApplicationContext > , PluggedSystem { private lateinit var scheduler : WaitingRoomScheduler private lateinit var backgroundCommandBus : BackgroundCommandBusImpl fun advance (): SchedulerSystem { scheduler . publishValidProducts () return this } fun advanceBackgroundCommandBus (): SchedulerSystem { backgroundCommandBus . dispatchTimeoutNotifications () return this } override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () } override fun close () {} } Later you can use it in testing; . then (). scheduler (). advance ()","title":"Writing Your Own TestSystem"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/advanced/0002-writing-your-own-test-system/#accessing-an-application-dependency-with-a-system","text":"As you can see, in the example above, if a system implements AfterRunAware<ApplicationContext> then, afterRun method becomes available, in here we have access to applications dependency container to resolve any bean we need to use. override suspend fun afterRun ( context : ApplicationContext ) { scheduler = context . getBean () backgroundCommandBus = context . getBean () }","title":"Accessing an application dependency with a system"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/advanced/0003-Writing-A-Test-Initializer/","text":"Writing a TestInitializer \u00b6 The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective. e2e Testing has dependencies: ObjectMapper , you can either provide the ObjectMapper you have already in here we get existing bean by ref(\"objectMapper\") TestSystemConsumerInterceptor is for being able to check consumed messages StoveSpringKafkaProducer to the able to publish messages to Kafka, so messages can route to the listeners in the application you're testing. class TestInitializer : BaseApplicationContextInitializer ({ bean < TestSystemConsumerInterceptor > ( isPrimary = true ) bean < StoveSpringKafkaProducer > ( isPrimary = true ) bean < ObjectMapper > { ref ( \"objectMapper\" ) } // \"objectMapper\" bean name should be in your spring context otherwise it will fail, if not you can provide an instance here. // Be sure that, Couchbase, Kafka and other systems share the same serialization strategy. bean < NoDelayBackgroundCommandBusImpl > ( isPrimary = true ) // Optional dependency to alter delayed implementation with 0-wait. }) fun SpringApplication . addTestDependencies () { this . addInitializers ( TestInitializer ()) } addTestDependencies is an extension that helps us to register our dependencies in the application. . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) )","title":"Writing a TestInitializer"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/advanced/0003-Writing-A-Test-Initializer/#writing-a-testinitializer","text":"The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective. e2e Testing has dependencies: ObjectMapper , you can either provide the ObjectMapper you have already in here we get existing bean by ref(\"objectMapper\") TestSystemConsumerInterceptor is for being able to check consumed messages StoveSpringKafkaProducer to the able to publish messages to Kafka, so messages can route to the listeners in the application you're testing. class TestInitializer : BaseApplicationContextInitializer ({ bean < TestSystemConsumerInterceptor > ( isPrimary = true ) bean < StoveSpringKafkaProducer > ( isPrimary = true ) bean < ObjectMapper > { ref ( \"objectMapper\" ) } // \"objectMapper\" bean name should be in your spring context otherwise it will fail, if not you can provide an instance here. // Be sure that, Couchbase, Kafka and other systems share the same serialization strategy. bean < NoDelayBackgroundCommandBusImpl > ( isPrimary = true ) // Optional dependency to alter delayed implementation with 0-wait. }) fun SpringApplication . addTestDependencies () { this . addInitializers ( TestInitializer ()) } addTestDependencies is an extension that helps us to register our dependencies in the application. . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) )","title":"Writing a TestInitializer"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/dependencies/couchbase/","text":"Couchbase \u00b6 Info In progress... . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" , \"couchbase.username= ${ cfg . username } \" , \"couchbase.password= ${ cfg . password } \" ) } Note The Couchbase configuration name in the application.yml is couchbase.hosts , this might differ for your project. Stove exposes the generated configuration by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. So, your application will start with the physical dependencies that are spun-up by the framework.","title":"Couchbase"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/dependencies/couchbase/#couchbase","text":"Info In progress... . withCouchbase ( bucket = \"Stove\" ) { cfg -> listOf ( \"couchbase.hosts= ${ cfg . hostsWithPort } \" , \"couchbase.username= ${ cfg . username } \" , \"couchbase.password= ${ cfg . password } \" ) } Note The Couchbase configuration name in the application.yml is couchbase.hosts , this might differ for your project. Stove exposes the generated configuration by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. So, your application will start with the physical dependencies that are spun-up by the framework.","title":"Couchbase"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/dependencies/kafka/","text":"Kafka \u00b6 Info In progress... There might be a potential improvement on the configuration for better testing results that can improve the testing performance. If you have the following configurations: AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" You better make them configurable, so from the e2e testing context we can change them to improve testing performance. As an example: TestSystem () . withDefaultHttp () . withCouchbase ( \"International\" ) . withKafka () . withWireMock ( 9090 ) . withSchedulerSystem () . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) ). run ()","title":"Kafka"},{"location":"how-to-write-tests/Application-Aware/Spring-Boot/dependencies/kafka/#kafka","text":"Info In progress... There might be a potential improvement on the configuration for better testing results that can improve the testing performance. If you have the following configurations: AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" You better make them configurable, so from the e2e testing context we can change them to improve testing performance. As an example: TestSystem () . withDefaultHttp () . withCouchbase ( \"International\" ) . withKafka () . withWireMock ( 9090 ) . withSchedulerSystem () . systemUnderTest ( runner = { parameters -> com . trendyol . exampleapp . run ( parameters ) { addTestDependencies () } }, withParameters = listOf ( \"logging.level.root=error\" , \"logging.level.org.springframework.web=error\" , \"spring.profiles.active=default\" , \"server.http2.enabled=false\" , \"kafka.heartbeatInSeconds=2\" , \"kafka.autoCreateTopics=true\" , \"kafka.offset=earliest\" ) ). run ()","title":"Kafka"},{"location":"how-to-write-tests/Dockerized/","text":"Dockerized Testing \u00b6 In this approach, your application does not have any part that is exposed to Stove, and Stove will not attach to application. You could provide a docker image of your application, Stove will spin up the application and its dependencies. This is on the roadmap, and not implemented yet.","title":"Dockerized Testing"},{"location":"how-to-write-tests/Dockerized/#dockerized-testing","text":"In this approach, your application does not have any part that is exposed to Stove, and Stove will not attach to application. You could provide a docker image of your application, Stove will spin up the application and its dependencies. This is on the roadmap, and not implemented yet.","title":"Dockerized Testing"}]}