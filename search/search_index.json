{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Stove","text":"<p>Stove is an end-to-end testing framework that spins up physical dependencies and your application all together. So you have a control over dependencies via Kotlin code.</p> <p>In the JVM world, thanks to code interoperability, you application code and test can be written with different JVM languages and can be run together. For example, you can write your application code with Java and write your tests with Kotlin, or Application code with Scala and test with Kotlin, etc. Stove uses this ability and provides a way to write your tests in Kotlin.</p> <p>Your tests will be infra agnostic, but component aware, so they can use easily necessary physical components with Stove provided APIs. All the infra is pluggable, and can be added easily. You can also create your own infra needs by using the abstractions that Stove provides. Having said that, the only dependency is <code>docker</code> since Stove is using testcontainers underlying.</p> <p>You can use JUnit and Kotest for running the tests. You can run all the tests on your CI, too. But that needs DinD(docker-in-docker) integration.</p> <p>The medium story about the motivation behind the framework: A New Approach to the API End-to-End Testing in Kotlin</p> <p>Note: Stove is not a replacement for the unit tests, it is a framework for end-to-end/component tests.</p>"},{"location":"#what-is-the-problem","title":"What is the problem?","text":"<p>In the JVM world, we have a lot of frameworks for the application code, but when it comes to integration/component/e2e testing we don't have a single framework that can be used for all the tech stacks. We have testcontainers but you still need to do lots of plumbing to make it work with your tech stack.</p> <p>The use-cases that led us develop the Stove are to increase the productivity of the developers while keeping the quality of the codebase high and coherent.</p> <p>Those use-cases are:</p> <ul> <li>Kotlin app with Spring-Boot</li> <li>Kotlin app with Ktor</li> <li>Java app with Spring-Boot</li> <li>Java app with Micronaut</li> <li>Java app with Quarkus</li> <li>Scala app with Spring-Boot</li> </ul> <p>People have different tech stacks and each time when they want to write e2e tests, they need to write a lot of boilerplate code. Alongside the physical components that are needed to be started, we need to write the code to start the application, and the code to access the beans of the application. Stove is here to solve this problem. It provides a single API to write e2e tests for all the tech stacks.</p> <p>Stove unifies the testing experience whatever you use.</p>"},{"location":"#high-level-architecture","title":"High Level Architecture","text":""},{"location":"#how-to-build-the-source-code","title":"How to build the source code?","text":"<ul> <li>JDK 17+</li> <li>Docker for running the tests (please use the latest version)</li> </ul> <pre><code>./gradlew build # that will build and run the tests\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#pre-requisites","title":"Pre-requisites","text":"<ul> <li>JDK 17+</li> <li>Docker for running the tests (please use the latest version)</li> <li>Kotlin 1.8+</li> <li>Gradle or Maven for running the tests, but Gradle is recommended.<ul> <li>Gradle is the default build tool for Stove, and it is used in the examples.</li> <li>If you are using Intellij IDEA, Kotest plugin is recommended.</li> </ul> </li> </ul> <p>The framework still under development and is getting matured. It is working well and in use at Trendyol. Besides, the Stove tests are highly likely going to be located under your testing context and the folder, so, it is risk-free to apply and use, give it a try!</p> <p><code>$version = please check the current version</code></p> <p>Versions are available at Releases</p> <p>Tip</p> <p>You can use SNAPSHOT versions for the latest features. You can add the following repository to your build file. SNAPSHOT versions released with the <code>1.0.0.{buildNumber}-SNAPSHOT</code> strategy.</p> <pre><code>repositories {\n    maven {\n        url = uri(\"https://oss.sonatype.org/content/repositories/snapshots/\")\n    }\n}\n</code></pre> <p>Every physical component that your testing needs is a separate module in Stove. You can add them according to your needs. Stove supports the following components:</p> <ul> <li>Kafka</li> <li>MongoDB</li> <li>MSSQL</li> <li>PostgreSQL</li> <li>Redis</li> <li>Elasticsearch</li> <li>Couchbase</li> <li>Wiremock</li> <li>HTTP</li> <li>Bridge</li> </ul> Gradle <pre><code>repositories {\n  mavenCentral()\n}\n\ndependencies {\n  // Application Under Test\n\n  // Spring Boot\n  testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n\n  // or\n\n  // Ktor\n  testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$version\")\n\n  // Components\n  testImplementation(\"com.trendyol:stove-testing-e2e:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-mongodb:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-mssql:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-postgresql:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-redis:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-elasticsearch:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-couchbase:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-wiremock:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n}\n</code></pre>"},{"location":"#how-to-write-tests","title":"How To Write Tests?","text":"<p>Stove uses your application entrance point to start your application alongside the physical components. The application's <code>main</code> is the entrance point for the applications in general.</p> <p>Everything starts with the <code>TestSystem</code> class. You can configure your system with the <code>with</code> function.</p> <pre><code>TestSystem()\n  .with {\n    // your configurations depending on the dependencies you need\n  }.run()\n</code></pre> <p><code>with</code> function is a lambda that you can configure your system. You can add your physical components. It is also a place to plug your custom systems that you might want to create. If you added <code>com.trendyol:stove-testing-e2e-kafka</code> package, you can use <code>kafka</code> function in the <code>with</code> block.</p> <pre><code>TestSystem()\n  .with {\n    kafka {\n      // your kafka configurations\n    }\n  }.run()\n</code></pre> <p>Note</p> <p>You can add multiple physical components in the <code>with</code> block. Think of it as a DSL for your test system and a <code>docker-compose</code> in Kotlin.</p> <p>Tip</p> <p>If you want to jump directly to the examples, you can check the examples in the repository.</p> <ul> <li> <p>Examples</p> <ul> <li>Ktor Example</li> <li>Spring Boot Example</li> <li>Spring Boot with Standalone Kafka</li> </ul> </li> <li> <p>Recipes</p> <ul> <li>Java Recipes</li> <li>Kotlin Recipes</li> <li>Scala Recipes</li> </ul> </li> </ul> <p>Stove has the concept of \"Application Aware Testing\". It means that Stove is aware of the application's entrance point and that is the only information it needs to start the application.</p> <p>Application that is being tested is a Spring Boot, Ktor, Micronaut, Quarkus, etc. and is called \"Application Under Test (AUT)\".</p> <p>The tests are agnostic to the application's framework. Right now Stove supports Spring Boot, Ktor. But it is easy to add new frameworks.</p> <p>Note</p> <p>If you want to add a new framework, you can check the <code>com.trendyol.stove.testing.e2e.system.abstractions.ApplicationUnderTest</code> interface. You can implement this interface for your framework.</p> <p>Let's create an example for a Spring-Boot application with Kafka and explain the setup flow.</p> <p>The dependencies we will need in the <code>build.gradle.kts</code> file are:</p> <pre><code> dependencies {\n  testImplementation(\"com.trendyol:stove-testing-e2e:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n  testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n}\n</code></pre> <pre><code>TestSystem()\n  .with {\n    httpClient {\n      HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8001\"\n      )\n    }\n\n    kafka {\n      KafkaSystemOptions(\n        containerOptions = KafkaContainerOptions(tag = \"latest\"),\n      ) {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.isSecure=false\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\",\n          \"kafka.heartbeatInSeconds=2\",\n          \"kafka.autoCreateTopics=true\",\n          \"kafka.offset=earliest\",\n          \"kafka.secureKafka=false\"\n        )\n      }\n    }\n\n    bridge()\n\n    springBoot( // Application Under Test\n      runner = { parameters -&gt;\n        stove.spring.standalone.example.run(parameters)\n      },\n      withParameters = listOf(\n        \"server.port=8001\",\n        \"logging.level.root=info\",\n        \"logging.level.org.springframework.web=info\",\n        \"spring.profiles.active=default\",\n      )\n    )\n  }\n  .run()\n</code></pre> <p>The typical setup for a Spring Boot application with Kafka is like this. You can see that we have a <code>httpClient</code>function that is used for the HTTP client against the application's endpoints. Then we have a <code>kafka</code> function that is used for the Kafka setup. Then we have a <code>bridge</code> function that is used for accessing the DI container of the application. Then we have a <code>springBoot</code> function that is used for the Spring Boot application setup.</p>"},{"location":"#httpclient-function","title":"<code>httpClient</code> function","text":"<p>It is used for the HTTP client against the application's endpoints. You can configure the base URL of the application. When the application is started, the base URL is used for the HTTP client.</p>"},{"location":"#kafka-function","title":"<code>kafka</code> function","text":"<p>It is used for the Kafka setup. You can configure the Kafka container options and the Kafka properties. When the application is started, the Kafka container is started and the Kafka properties are used for the application. We will investigate the Kafka setup in detail in the Kafka section. Your application code should be able to read these properties, and event app code needs to be arranged for this.</p> <p>Is my application code e2e testing friendly?</p> <p>In general, to write proper unit tests your code should be testable.  This means extracting dependencies to interfaces and using dependency injection. </p> <p>Injecting time, configuration, and other dependencies is a good practice.  This makes your classes testable and you can easily replace the implementations of the interfaces in the tests.</p> <p>Changing your configuration to be able to read from the environment variables or CLI arguments is also a good practice. Since Stove is also passing down the test configurations and the optimum setup for the tests, your application should be able to read these configurations.</p> <p>So, don't think that you're changing too much application code just for sake of the Stove tests, you're making your application code e2e test friendly.</p>"},{"location":"#bridge-function","title":"<code>bridge</code> function","text":"<p>This function is used for accessing the DI container of the application. When the application is started, the bridge is created and the DI container is accessed in the tests.</p> <p>If you want to access to the beans of the application, you can simply do:</p> <pre><code>TestSystem.validate {\n  using&lt;UserApplicationService&gt; {\n    this.getUserById(1) shouldBe User(1, \"John\", \"Doe\")\n  }\n\n  using&lt;ProductDomainService, ProductRepository&gt; { productDomainService, productRepository -&gt;\n    productDomainService.getProductById(1) shouldBe Product(1, \"Product 1\")\n    productRepository.findById(1) shouldBe Product(1, \"Product 1\")\n  }\n}\n</code></pre>"},{"location":"#springboot-function","title":"<code>springBoot</code> function","text":"<p>This function is used for the Spring Boot application setup. You can configure the runner function and the parameters of the application. When the application is started, the runner function is called with the parameters. The parameters you see in <code>runner</code> function are the parameters that are passed to the Spring Boot application when it is started. Each physical component exposes its own properties and you can use them in the application. Here:</p> <pre><code>kafka {\n  KafkaSystemOptions(\n    containerOptions = KafkaContainerOptions(tag = \"latest\"),\n  ) {\n    listOf(\n      \"kafka.bootstrapServers=${it.bootstrapServers}\",\n      \"kafka.isSecure=false\",\n      \"kafka.interceptorClasses=${it.interceptorClass}\",\n      \"kafka.heartbeatInSeconds=2\",\n      \"kafka.autoCreateTopics=true\",\n      \"kafka.offset=earliest\",\n      \"kafka.secureKafka=false\"\n    )\n  }\n}\n</code></pre> <p>The list of properties are exposed by the Kafka component and you can use them in the application. The reference <code>it</code> in this block is the physical component itself and it's exposed properties. Whenever Kafka and testing suite start, the properties are changed and passed down to the application.</p>"},{"location":"#run-function","title":"<code>run</code> function","text":"<p>Runs the entire setup. It starts the physical components and the application.</p> <p>Run the Setup Once</p> <p>You should run the setup once in your test suite. You can run it in the <code>@BeforeAll</code> function of JUnit or implement <code>AbstractProjectConfig#beforeProject</code> in Kotest. Teardown is also important to call. You can run it in the <code>@AfterAll</code> function of JUnit or implement <code>AbstractProjectConfig#afterProject</code> in Kotest. Simply calling <code>TestSystem.stop()</code> is enough to stop the setup.</p>"},{"location":"#writing-tests","title":"Writing Tests","text":"<p>After the setup is done, you can write your tests. You can use the <code>validate</code> function to write your tests.</p> <pre><code>TestSystem.validate {\n  http {\n    get&lt;String&gt;(\"/hello/index\") { actual -&gt;\n      actual shouldContain \"Hi from Stove framework\"\n    }\n  }\n\n  kafka {\n    shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt;\n      actual.productId == 1\n    }\n  }\n\n  using&lt;UserApplicationService&gt; {\n    this.getUserById(1) shouldBe User(1, \"John\", \"Doe\")\n  }\n\n  using&lt;ProductDomainService, ProductRepository&gt; { productDomainService, productRepository -&gt;\n    productDomainService.getProductById(1) shouldBe Product(1, \"Product 1\")\n    productRepository.findById(1) shouldBe Product(1, \"Product 1\")\n  }\n\n  kafka {\n    shouldBePublished&lt;ProductCreatedEvent&gt; { actual -&gt;\n      actual.productId == 1\n    }\n  }\n}\n</code></pre> <p>That's it! You have up-and-running API, can be tested with Stove. And each test is independent of each other. But they share the same instance of physical component of course, so you need to provide random data for each test. This is a good practice for the tests to be independent of each other.</p>"},{"location":"#application-aware-testing","title":"Application Aware Testing","text":"<p>Stove is aware of your application either it is SpringBoot or Ktor, and it is aware of the entrance point of your application.</p> <p>There are entry point for every application, usually a <code>main</code> method that is invoked, and starts the application lifecycle.</p> <p>If you are publishing your <code>application</code> as a docker image, <code>docker run ...</code> basically runs your application highly likely with a <code>jvm/java</code> command.</p> <p>In this approach, we're using the same <code>main</code> function of your application in the test context to run the application as full-blown as if it is invoked from outside.</p> <p>Stove calls your application's <code>main</code> function like you would call <code>java yourApplicationName.jar --param1 --param2</code> to run the application from the test context. So the runner is JUnit or Kotest.</p> <p>For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter.</p> <p>This approach has lots of benefits besides of providing a debug ability while e2e testing. You can:</p> <ul> <li>Debug the application code</li> <li>Replace the implementations of the interfaces. Useful for time-bounded implementations such as schedulers, background   workers, and time itself.   you would only have consuming.</li> <li>Use and expose application's dependency container to the test context. You can access the beans of the application   easily. Using <code>bridge</code> functionality.</li> </ul>"},{"location":"#spring-boot","title":"Spring Boot","text":"<p>You need to add the Stove-Spring dependency to be able to write e2e tests for the Spring application.</p> Gradle <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n\n    // You can add other components if you need\n}\n</code></pre>"},{"location":"#tuning-the-applications-entry-point","title":"Tuning the application's entry point","text":"<p>Let's say the application has a standard <code>main</code> function, here how we will change it:</p> BeforeAfter <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { runApplication&lt;ExampleApplication&gt;(*args) }\n</code></pre> <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { run(args) }\n\nfun run(\n     args: Array&lt;String&gt;,\n     init: SpringApplication.() -&gt; Unit = {},\n  ): ConfigurableApplicationContext {\n        return runApplication&lt;ExampleApplication&gt;(*args, init = init)\n    }\n</code></pre> <p>As you can see from <code>before-after</code> sections, we have divided the application main function into two parts.</p> <p><code>run(args, init)</code> method is the important point for the testing configuration. <code>init</code> allows us to override any dependency from the testing side that is being <code>time</code> related or <code>configuration</code> related. Spring itself opens this configuration higher order function to the outside.</p> <p>Also returning <code>ConfigurableApplicationContext</code> is important for the <code>bridge</code> functionality that we will use in the tests.</p> <p>Tip</p> <p>Here you can jump immediately to the Spring example application.</p>"},{"location":"#initial-configuration","title":"Initial Configuration","text":"<p>After you've added the dependencies, and configured the application's <code>main</code> function, it is time to run your application for the first time from the test-context with Stove.</p>"},{"location":"#setting-up-stove-for-the-runner","title":"Setting up Stove for the Runner","text":"KotestJUnit <p>It implements <code>AbstractProjectConfig</code> from Kotest framework that allows us to spin up Stove per run. This is project wide operation and executes only one time, as the name implies <code>beforeProject</code>.</p> <pre><code>class Stove : AbstractProjectConfig() {    \n    override suspend fun beforeProject(): Unit = \n        TestSystem()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions (\n                        baseUrl = \"http://localhost:8001\"\n                    )\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n\n    override suspend fun afterProject(): Unit = TestSystem.stop()\n}\n</code></pre> <pre><code>class TestSystemConfig {\n\n    @BeforeAll\n    fun beforeProject() = runBlocking {\n         TestSystem()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions (\n                        baseUrl = \"http://localhost:8001\"\n                    )\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n    }\n\n    @AfterAll\n    fun afterProject() = runBlocking {\n        TestSystem.stop()\n    }\n}\n</code></pre> <p>In the section of <code>springBoot</code> function, we have configured the application's entry point, and the parameters that are passed to the application. <code>stove.spring.example.run(parameters)</code> is the entrance point of the application.</p> <p>Like the concept of <code>service under test</code> from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called <code>Application Under Test</code></p> <p>In here we're configuring the Spring Boot application as application under test.</p> <p>Note</p> <p><code>server.port=8001</code> is a Spring config, TestSystem's <code>baseUrl</code> needs to match with it, since Http requests are made  against the <code>baseUrl</code> that is defined. <code>withDefaultHttp</code> creates a WebClient and uses the <code>baseUrl</code> that is passed.</p>"},{"location":"#writing-tests_1","title":"Writing Tests","text":"<p>Here is an example test that validates <code>http://localhost:$port/hello/index</code> returns the expected text</p> KotestJUnit <pre><code>class ExampleTest: FunSpec({\n\n    test(\"should return hi\"){\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n})\n</code></pre> <pre><code>class ExampleTest {\n\n    @Test\n    fun `should return hi`() {\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n    }\n})\n</code></pre> <p>That's it! You have up-and-running API, can be tested with Stove.</p> <p>Tip</p> <p>DSL scopes can appear more than once while writing the tests.  You can access to any DSL assertion scope such as http, kafka, using, etc. as many times as you need.</p> <p>Example:</p> <pre><code>TestSystem.validate {\n    http {\n        get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n            actual shouldContain \"Hi from Stove framework\" \n        }\n    }\n\n    kafka {\n        shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt; \n            actual.productId == 1\n        }\n    }\n\n    kafka {\n        shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt; \n            actual.productId == 1\n        }\n    }\n\n    http {\n        get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n            actual shouldContain \"Hi from Stove framework\" \n        }\n    }\n\n    using&lt;UserApplicationService&gt; {\n        this.getUserById(1) shouldBe\n    }\n</code></pre>"},{"location":"#ktor","title":"Ktor","text":"Gradle <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$version\")\n\n    // You can add other components if you need\n}\n</code></pre>"},{"location":"#example-setup","title":"Example Setup","text":"<pre><code>TestSystem()\n  .with {\n    // You can add other components if you need\n    // We removed for simplicity\n\n    ktor(\n      withParameters = listOf(\n        \"port=8080\"\n      ),\n      runner = { parameters -&gt;\n        stove.ktor.example.run(parameters) {\n          addTestSystemDependencies()\n        }\n      }\n    )\n  }.run()\n</code></pre> <p>After you've added <code>stove-ktor-testing-e2e</code> dependency, and configured the application's <code>main</code> function for Stove to enter, it is time to run your application for the first time from the test-context with Stove.</p>"},{"location":"#tuning-the-applications-entry-point_1","title":"Tuning the application's entry point","text":"<p>Let's say the application has a standard <code>main</code> function, here how we will change it:</p> BeforeAfter <pre><code>fun main() {\n  embeddedServer(Netty, port = 8080) {\n      routing {\n          get(\"/\") {\n              call.respondText(\"Hello, world!\")\n          }\n      }\n   }.start(wait = true)\n}\n</code></pre> <pre><code>object ExampleApp {\n  @JvmStatic\n  fun main(args: Array&lt;String&gt;) {\n     run(args)\n  }\n\n fun run(args: Array&lt;String&gt;, \n        wait: Boolean = true, \n        configure: org.koin.core.module.Module = module { }\n    ): Application {\n     val config = loadConfiguration&lt;Env&gt;(args)\n     return startKtorApplication(config, wait) {\n         appModule(config, configure)\n     }\n  }\n}\n</code></pre> <p>As you can see from <code>before-after</code> sections, we have divided the application main function into two parts. <code>run(args, wait, configure)</code> method is the important point for the testing configuration. <code>configure</code> allows us to override any dependency from the testing side that is being <code>time</code> related or <code>configuration</code> related.</p> <p>Note</p> <p>There are helper methods here for example loadConfiguration  that is used to load the configuration from the environment variables or CLI arguments. And as you can see there is an <code>Env</code> data class to cast the configuration.  Stove itself does not provide them, but of course we have already used them in our examples, you can find them in the examples.</p> <p>Tip</p> <p>Here you can jump immediately to the Ktor example application.</p>"},{"location":"#advanced","title":"Advanced","text":""},{"location":"#global-variables","title":"Global Variables","text":""},{"location":"#default_registry","title":"DEFAULT_REGISTRY","text":"<p>The default container registry is <code>docker.io</code>. You can change it by setting the <code>DEFAULT_REGISTRY</code> variable.</p> <pre><code>DEFAULT_REGISTRY = \"your.registry.com\"\n</code></pre> <p>This will effect all the components Stove wide. Or you can set it for each individual component by setting the<code>registry</code> property, example for Kafka:</p> <pre><code>KafkaSystemOptions(\n  containerOptions = KafkaContainerOptions(\n    registry = \"your.registry.com\",\n    tag = \"latest\"\n  ),\n)\n</code></pre>"},{"location":"#serializing-and-deserializing","title":"Serializing and Deserializing","text":"<p>Each component has its own serialization and deserialization mechanism. You can align Stove's serialization and deserialization mechanism with your application's serialization and deserialization mechanism.</p> <p>Stove works with multiple serializers and deserializers. The package <code>stove-testing-e2e</code> provides the following serializers and deserializers:</p> <ul> <li>Jackson</li> <li>Gson</li> <li>Kotlinx</li> </ul> <p>Stove also provides a way to add your own serializer and deserializer. You can implement the <code>StoveSerde&lt;TIn, TOut&gt;</code> interface and add your own serializer and deserializer.</p> <p><code>StoveSerde</code> also keeps the reference to the aforementioned libraries:</p> <pre><code>StoveSerde.jackson\nStoveSerde.gson\nStoveSerde.kotlinx\n</code></pre> <p>And also provides default implementations for them:</p> <pre><code>StoveSerde.jackson.anyByteArraySerde(yourObjectMapper())\nStoveSerde.gson.anyByteArraySerde(yourGson())\nStoveSerde.kotlinx.anyByteArraySerde(yourJson())\n\n// there is also string serde\nStoveSerde.jackson.anyStringSerde(yourObjectMapper())\nStoveSerde.gson.anyStringSerde(yourGson())\nStoveSerde.kotlinx.anyStringSerde(yourJson())\n</code></pre>"},{"location":"#replacing-dependencies-for-better-testability","title":"Replacing Dependencies For Better Testability","text":"<p>When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is <code>advancing</code> the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented.</p> <p>For example, imagine we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation.</p> <pre><code>class BackgroundCommandBusImpl // is the class for delayed operations\n</code></pre> <p>We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write:</p> <pre><code>class NoDelayBackgroundCommandBusImpl(\n  backgroundMessageEnvelopeDispatcher: BackgroundMessageEnvelopeDispatcher,\n  backgroundMessageEnvelopeStorage: BackgroundMessageEnvelopeStorage,\n  lockProvider: CouchbaseLockProvider,\n) : BackgroundCommandBusImpl(\n  backgroundMessageEnvelopeDispatcher,\n  backgroundMessageEnvelopeStorage,\n  lockProvider\n) {\n\n  override suspend fun &lt;TNotification : BackgroundNotification&gt; publish(\n    notification: TNotification,\n    options: BackgroundOptions,\n  ) {\n    super.publish(notification, options.withDelay(0))\n  }\n\n  override suspend fun &lt;TCommand : BackgroundCommand&gt; send(\n    command: TCommand,\n    options: BackgroundOptions,\n  ) {\n    super.send(command, options.withDelay(0))\n  }\n}\n</code></pre> <p>Now, it is time to tell to e2eTest system to use NoDelay implementation.</p> <p>That brings us to initializers.</p>"},{"location":"#writing-your-own-testsystem","title":"Writing Your Own TestSystem","text":"<p>Stove's pluggable architecture allows you to create custom systems for any component or behavior specific to your application. This is useful for:</p> <ul> <li>Capturing domain events in memory</li> <li>Integrating with schedulers (db-scheduler, Quartz, etc.)</li> <li>Controlling time in tests</li> <li>Testing domain-specific behavior</li> </ul> <p>Here's a simple example of a custom scheduler system:</p> <pre><code>fun TestSystem.withSchedulerSystem(): TestSystem {\n  getOrRegister(SchedulerSystem(this))\n  return this\n}\n\nfun TestSystem.scheduler(): SchedulerSystem = getOrNone&lt;SchedulerSystem&gt;().getOrElse {\n  throw SystemNotRegisteredException(SchedulerSystem::class)\n}\n\nclass SchedulerSystem(override val testSystem: TestSystem) : AfterRunAware&lt;ApplicationContext&gt;, PluggedSystem {\n\n  private lateinit var scheduler: WaitingRoomScheduler\n  private lateinit var backgroundCommandBus: BackgroundCommandBusImpl\n\n  fun advance(): SchedulerSystem {\n    scheduler.publishValidProducts()\n    return this\n  }\n\n  fun advanceBackgroundCommandBus(): SchedulerSystem {\n    backgroundCommandBus.dispatchTimeoutNotifications()\n    return this\n  }\n\n  override suspend fun afterRun(context: ApplicationContext) {\n    scheduler = context.getBean()\n    backgroundCommandBus = context.getBean()\n  }\n\n  override fun close() {}\n}\n</code></pre> <p>Later you can use it in testing:</p> <pre><code>validate {\n  scheduler {\n    advance()\n  }\n}\n</code></pre> <p>Comprehensive Guide</p> <p>For a complete guide on writing custom systems including examples for db-scheduler integration,  in-memory event capture, and time control systems, see Writing Custom Systems.</p>"},{"location":"#accessing-an-application-dependency-with-a-system","title":"Accessing an application dependency with a system","text":"<p>As you can see, in the example above, if a system implements <code>AfterRunAware&lt;ApplicationContext&gt;</code> then, <code>afterRun</code> method becomes available, in here we have access to applications dependency container to resolve any bean we need to use.</p> <pre><code>override suspend fun afterRun(context: ApplicationContext) {\n  scheduler = context.getBean()\n  backgroundCommandBus = context.getBean()\n}\n</code></pre>"},{"location":"#writing-a-testinitializer","title":"Writing a TestInitializer","text":"<p>The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective.</p> <pre><code>class TestInitializer : BaseApplicationContextInitializer({\n  bean&lt;YourInstanceToReplace&gt;(isPrimary = true)\n  bean&lt;NoDelayBackgroundCommandBusImpl&gt;(isPrimary = true) // Optional dependency to alter delayed implementation with 0-wait.\n})\n\nfun SpringApplication.addTestDependencies() {\n  this.addInitializers(TestInitializer())\n}\n</code></pre> <p><code>addTestDependencies</code> is an extension that helps us to register our dependencies in the application.</p> <pre><code>.springBoot(\n  runner = { parameters -&gt;\n    com.trendyol.exampleapp.run(parameters) {\n      addTestDependencies()\n    }\n  },\n  withParameters = listOf(\n    \"logging.level.root=error\",\n    \"logging.level.org.springframework.web=error\",\n    \"spring.profiles.active=default\",\n    \"server.http2.enabled=false\",\n    \"kafka.heartbeatInSeconds=2\",\n    \"kafka.autoCreateTopics=true\",\n    \"kafka.offset=earliest\"\n  )\n)\n</code></pre>"},{"location":"best-practices/","title":"Best Practices","text":"<p>This guide covers best practices for writing effective end-to-end tests with Stove.</p>"},{"location":"best-practices/#test-organization","title":"Test Organization","text":""},{"location":"best-practices/#use-dedicated-source-set-for-e2e-tests","title":"Use Dedicated Source Set for E2E Tests","text":"<p>Instead of placing e2e tests in the regular <code>src/test</code> folder, create a dedicated <code>src/test-e2e</code> source set. This provides better separation between unit/integration tests and e2e tests:</p> <pre><code>src/\n\u251c\u2500\u2500 main/kotlin/           # Application code\n\u251c\u2500\u2500 test/kotlin/           # Unit tests\n\u2514\u2500\u2500 test-e2e/kotlin/       # E2E tests with Stove\n    \u251c\u2500\u2500 config/\n    \u2502   \u2514\u2500\u2500 TestConfig.kt\n    \u251c\u2500\u2500 setup/\n    \u2502   \u2514\u2500\u2500 TestInitializer.kt\n    \u251c\u2500\u2500 features/\n    \u2502   \u251c\u2500\u2500 OrderE2ETest.kt\n    \u2502   \u251c\u2500\u2500 UserE2ETest.kt\n    \u2502   \u2514\u2500\u2500 ProductE2ETest.kt\n    \u2514\u2500\u2500 shared/\n        \u251c\u2500\u2500 TestData.kt\n        \u2514\u2500\u2500 Assertions.kt\n</code></pre>"},{"location":"best-practices/#gradle-configuration-for-test-e2e","title":"Gradle Configuration for test-e2e","text":"<p>Configure the <code>test-e2e</code> source set in your <code>build.gradle.kts</code>:</p> <pre><code>sourceSets {\n    @Suppress(\"LocalVariableName\")\n    val `test-e2e` by creating {\n        compileClasspath += sourceSets.main.get().output\n        runtimeClasspath += sourceSets.main.get().output\n    }\n\n    val testE2eImplementation by configurations.getting {\n        extendsFrom(configurations.testImplementation.get())\n    }\n    configurations[\"testE2eRuntimeOnly\"].extendsFrom(configurations.runtimeOnly.get())\n}\n\n// Register e2e test task\ntasks.register&lt;Test&gt;(\"e2eTest\") {\n    description = \"Runs e2e tests.\"\n    group = \"verification\"\n    testClassesDirs = sourceSets[\"test-e2e\"].output.classesDirs\n    classpath = sourceSets[\"test-e2e\"].runtimeClasspath\n\n    useJUnitPlatform()\n    reports {\n        junitXml.required.set(true)\n        html.required.set(true)\n    }\n}\n\n// Configure IDEA to recognize test-e2e as test sources\nidea {\n    module {\n        testSources.from(sourceSets[\"test-e2e\"].allSource.sourceDirectories)\n        testResources.from(sourceSets[\"test-e2e\"].resources.sourceDirectories)\n    }\n}\n</code></pre>"},{"location":"best-practices/#running-e2e-tests","title":"Running E2E Tests","text":"<pre><code># Run only e2e tests\n./gradlew e2eTest\n\n# Run unit tests (doesn't include e2e)\n./gradlew test\n\n# Run all tests\n./gradlew test e2eTest\n</code></pre>"},{"location":"best-practices/#benefits-of-separate-source-set","title":"Benefits of Separate Source Set","text":"Benefit Description Isolation E2E tests run independently from unit tests CI Flexibility Run unit tests quickly, e2e tests separately or in parallel Resource Management Different JVM settings for e2e tests (more memory, longer timeouts) Clear Boundaries Developers know exactly where e2e tests live <p>See Examples</p> <p>Check the recipes folder for complete working examples with this structure.</p>"},{"location":"best-practices/#single-setup-multiple-tests","title":"Single Setup, Multiple Tests","text":"<p>Configure Stove once for all tests:</p> <pre><code>// \u2705 Good: Single configuration for all tests\nclass TestConfig : AbstractProjectConfig() {\n    override suspend fun beforeProject() {\n        TestSystem()\n            .with { /* configuration */ }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        TestSystem.stop()\n    }\n}\n\n// \u274c Bad: Configuration per test class\nclass MyTest : FunSpec({\n    beforeSpec {\n        TestSystem().with { /* */ }.run()  // Don't do this!\n    }\n})\n</code></pre>"},{"location":"best-practices/#test-data-management","title":"Test Data Management","text":""},{"location":"best-practices/#use-unique-test-data","title":"Use Unique Test Data","text":"<p>Generate unique identifiers to prevent test interference:</p> <pre><code>// \u2705 Good: Unique data per test\ntest(\"should create order\") {\n    val orderId = UUID.randomUUID().toString()\n    val userId = \"user-${UUID.randomUUID()}\"\n\n    TestSystem.validate {\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(id = orderId, userId = userId).some()\n            ) { /* assertions */ }\n        }\n    }\n}\n\n// \u274c Bad: Hardcoded IDs that may conflict\ntest(\"should create order\") {\n    val orderId = \"order-123\"  // May conflict with other tests\n    // ...\n}\n</code></pre>"},{"location":"best-practices/#isolate-shared-infrastructure-resources","title":"Isolate Shared Infrastructure Resources","text":"<p>When using provided instances (shared infrastructure in CI/CD), use unique prefixes for all resources to prevent parallel test runs from interfering with each other:</p> <pre><code>object TestRunContext {\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: UUID.randomUUID().toString().take(8)\n\n    val databaseName = \"testdb_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n}\n\n// Use unique names in configuration\nTestSystem()\n    .with {\n        postgresql {\n            PostgresqlOptions.provided(\n                databaseName = TestRunContext.databaseName,\n                // ...\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n                \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\"\n            )\n        )\n    }\n</code></pre> <p>Detailed Guide</p> <p>See Provided Instances - Test Isolation for comprehensive examples for each system.</p>"},{"location":"best-practices/#use-cleanup-functions","title":"Use Cleanup Functions","text":"<p>Clean up test data to maintain isolation. The <code>cleanup</code> parameter is passed inside the options:</p> <pre><code>TestSystem()\n    .with {\n        couchbase {\n            CouchbaseSystemOptions(\n                defaultBucket = \"bucket\",\n                cleanup = { cluster -&gt;\n                    // Clean test data after tests complete\n                    cluster.query(\"DELETE FROM `bucket` WHERE type = 'test'\")\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"couchbase.hosts=${cfg.hostsWithPort}\",\n                        \"couchbase.username=${cfg.username}\",\n                        \"couchbase.password=${cfg.password}\"\n                    )\n                }\n            )\n        }\n\n        kafka {\n            KafkaSystemOptions(\n                cleanup = { admin -&gt;\n                    // Delete test topics after tests complete\n                    val testTopics = admin.listTopics().names().get()\n                        .filter { it.startsWith(\"test-\") }\n                    if (testTopics.isNotEmpty()) {\n                        admin.deleteTopics(testTopics).all().get()\n                    }\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n                        \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n                    )\n                }\n            )\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#test-data-builders","title":"Test Data Builders","text":"<p>Create reusable test data builders:</p> <pre><code>object TestData {\n    fun createUser(\n        id: String = UUID.randomUUID().toString(),\n        name: String = \"Test User\",\n        email: String = \"test-${UUID.randomUUID()}@example.com\"\n    ) = User(id = id, name = name, email = email)\n\n    fun createProduct(\n        id: String = UUID.randomUUID().toString(),\n        name: String = \"Test Product\",\n        price: Double = 99.99\n    ) = Product(id = id, name = name, price = price)\n}\n\n// Usage in tests\ntest(\"should create user\") {\n    val user = TestData.createUser(name = \"John Doe\")\n    // ...\n}\n</code></pre>"},{"location":"best-practices/#assertions","title":"Assertions","text":""},{"location":"best-practices/#be-specific-with-assertions","title":"Be Specific with Assertions","text":"<p>Test specific behaviors, not just successful responses:</p> <pre><code>// \u2705 Good: Specific assertions\nTestSystem.validate {\n    http {\n        postAndExpectBody&lt;OrderResponse&gt;(\n            uri = \"/orders\",\n            body = CreateOrderRequest(id = orderId, amount = 99.99).some()\n        ) { response -&gt;\n            response.status shouldBe 201\n            response.body().id shouldBe orderId\n            response.body().amount shouldBe 99.99\n            response.body().status shouldBe \"CREATED\"\n            response.body().createdAt shouldNotBe null\n        }\n    }\n}\n\n// \u274c Bad: Only checking status code\nTestSystem.validate {\n    http {\n        postAndExpectBodilessResponse(\"/orders\", body = order.some()) { response -&gt;\n            response.status shouldBe 201  // Not enough!\n        }\n    }\n}\n</code></pre>"},{"location":"best-practices/#verify-side-effects","title":"Verify Side Effects","text":"<p>Test the complete flow including side effects:</p> <pre><code>test(\"should process order completely\") {\n    val orderId = UUID.randomUUID().toString()\n\n    TestSystem.validate {\n        // 1. Make the request\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(id = orderId).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // 2. Verify database state\n        couchbase {\n            shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n                order.status shouldBe \"CREATED\"\n            }\n        }\n\n        // 3. Verify event was published\n        kafka {\n            shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n                actual.orderId == orderId\n            }\n        }\n\n        // 4. Verify search index updated\n        elasticsearch {\n            shouldGet&lt;Order&gt;(index = \"orders\", key = orderId) { order -&gt;\n                order.status shouldBe \"CREATED\"\n            }\n        }\n\n        // 5. Verify cache populated\n        redis {\n            client().connect().sync().get(\"order:$orderId\") shouldNotBe null\n        }\n    }\n}\n</code></pre>"},{"location":"best-practices/#performance","title":"Performance","text":""},{"location":"best-practices/#use-keepdependenciesrunning-for-development","title":"Use keepDependenciesRunning for Development","text":"<p>Speed up local development:</p> <pre><code>TestSystem {\n    keepDependenciesRunning()  // Containers stay running between test runs\n}.with {\n    // ...\n}.run()\n</code></pre> <p>Tip</p> <p>Disable <code>keepDependenciesRunning()</code> in CI/CD for clean environments.</p>"},{"location":"best-practices/#configure-appropriate-timeouts","title":"Configure Appropriate Timeouts","text":"<p>Set realistic timeouts for your environment:</p> <pre><code>// HTTP client timeout\nhttp {\n    HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8080\",\n        timeout = 30.seconds  // Adjust based on your app's response times\n    )\n}\n\n// Kafka assertion timeout\nkafka {\n    shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 20.seconds) {\n        // Allow enough time for async processing\n        actual.orderId == orderId\n    }\n}\n</code></pre>"},{"location":"best-practices/#run-tests-in-parallel-with-care","title":"Run Tests in Parallel (With Care)","text":"<p>If running tests in parallel, ensure proper isolation:</p> <pre><code>// Use unique data per test\ntest(\"test 1\") {\n    val id = UUID.randomUUID().toString()  // Unique per test\n    // ...\n}\n\ntest(\"test 2\") {\n    val id = UUID.randomUUID().toString()  // Different ID\n    // ...\n}\n</code></pre>"},{"location":"best-practices/#external-services","title":"External Services","text":""},{"location":"best-practices/#mock-external-dependencies","title":"Mock External Dependencies","text":"<p>Use WireMock for external services:</p> <pre><code>// \u2705 Good: Mock external services\nTestSystem.validate {\n    wiremock {\n        mockPost(\n            url = \"/payments/charge\",\n            statusCode = 200,\n            responseBody = PaymentResult(success = true, transactionId = \"tx-123\").some()\n        )\n    }\n\n    http {\n        postAndExpectBody&lt;OrderResponse&gt;(\n            uri = \"/orders\",\n            body = CreateOrderRequest(amount = 99.99).some()\n        ) { response -&gt;\n            response.body().paymentStatus shouldBe \"PAID\"\n        }\n    }\n}\n\n// \u274c Bad: Calling real external services in tests\n// - Tests become flaky\n// - Tests are slow\n// - May incur costs\n// - Can't test edge cases\n</code></pre>"},{"location":"best-practices/#test-error-scenarios","title":"Test Error Scenarios","text":"<p>Test how your application handles failures:</p> <pre><code>test(\"should handle payment failure gracefully\") {\n    TestSystem.validate {\n        wiremock {\n            mockPost(\n                url = \"/payments/charge\",\n                statusCode = 500,\n                responseBody = ErrorResponse(\"Payment service unavailable\").some()\n            )\n        }\n\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(amount = 99.99).some()\n            ) { response -&gt;\n                response.status shouldBe 503\n                response.body().status shouldBe \"PAYMENT_FAILED\"\n            }\n        }\n    }\n}\n\ntest(\"should retry on transient failures\") {\n    TestSystem.validate {\n        wiremock {\n            behaviourFor(\"/payments/charge\", WireMock::post) {\n                initially {\n                    aResponse().withStatus(503)\n                }\n                then {\n                    aResponse().withStatus(503)\n                }\n                then {\n                    aResponse()\n                        .withStatus(200)\n                        .withBody(it.serialize(PaymentResult(success = true)))\n                }\n            }\n        }\n\n        // Application should retry and eventually succeed\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(amount = 99.99).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"best-practices/#serialization","title":"Serialization","text":""},{"location":"best-practices/#align-serializers","title":"Align Serializers","text":"<p>Ensure Stove uses the same serialization as your application:</p> <pre><code>// If your app uses custom Jackson configuration\nval customObjectMapper = ObjectMapper().apply {\n    registerModule(JavaTimeModule())\n    disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n    setSerializationInclusion(JsonInclude.Include.NON_NULL)\n}\n\nTestSystem()\n    .with {\n        http {\n            HttpClientSystemOptions(\n                baseUrl = \"http://localhost:8080\",\n                contentConverter = JacksonConverter(customObjectMapper)\n            )\n        }\n\n        kafka {\n            KafkaSystemOptions(\n                serde = StoveSerde.jackson.anyByteArraySerde(customObjectMapper)\n            ) { /* config */ }\n        }\n\n        wiremock {\n            WireMockSystemOptions(\n                serde = StoveSerde.jackson.anyByteArraySerde(customObjectMapper)\n            )\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#application-configuration","title":"Application Configuration","text":""},{"location":"best-practices/#make-configuration-testable","title":"Make Configuration Testable","text":"<p>Your application should accept configuration from various sources:</p> <pre><code>// \u2705 Good: Configurable properties\n@Configuration\nclass KafkaConfig(\n    @Value(\"\\${kafka.bootstrapServers}\") private val bootstrapServers: String,\n    @Value(\"\\${kafka.offset:latest}\") private val offset: String,\n    @Value(\"\\${kafka.autoCreateTopics:false}\") private val autoCreate: Boolean\n) {\n    // Stove can override these via command line args\n}\n</code></pre>"},{"location":"best-practices/#external-service-urls-must-be-configurable","title":"External Service URLs Must Be Configurable","text":"<p>When using WireMock, all external service URLs must point to WireMock's URL:</p> <pre><code>// \u2705 Good: External service URLs are configurable\n@Configuration\nclass ExternalServicesConfig(\n    @Value(\"\\${payment.service.url}\") val paymentUrl: String,\n    @Value(\"\\${inventory.service.url}\") val inventoryUrl: String\n)\n\n// In tests, pass WireMock URL for all external services\nTestSystem()\n    .with {\n        wiremock {\n            WireMockSystemOptions(port = 9090)\n        }\n        springBoot(\n            withParameters = listOf(\n                \"payment.service.url=http://localhost:9090\",\n                \"inventory.service.url=http://localhost:9090\"\n            )\n        )\n    }\n</code></pre> <pre><code>// \u274c Bad: Hardcoded URLs won't be intercepted by WireMock\nclass PaymentClient {\n    private val url = \"http://payment-service.com\"  // WireMock can't intercept this!\n}\n</code></pre> <pre><code>// \u274c Bad: Hardcoded values\n@Configuration\nclass KafkaConfig {\n    private val bootstrapServers = \"localhost:9092\"  // Can't change in tests!\n}\n</code></pre>"},{"location":"best-practices/#use-test-profiles-wisely","title":"Use Test Profiles Wisely","text":"<p>Minimize differences between test and production:</p> <pre><code>springBoot(\n    runner = { params -&gt; myApp.run(params) },\n    withParameters = listOf(\n        \"server.port=8080\",\n        \"spring.profiles.active=default\",  // Use default profile when possible\n        \"logging.level.root=warn\",\n        // Override only what's necessary\n        \"kafka.bootstrapServers=${kafkaConfig.bootstrapServers}\"\n    )\n)\n</code></pre>"},{"location":"best-practices/#debugging","title":"Debugging","text":""},{"location":"best-practices/#enable-verbose-logging-when-needed","title":"Enable Verbose Logging When Needed","text":"<pre><code>springBoot(\n    runner = { params -&gt; myApp.run(params) },\n    withParameters = listOf(\n        \"logging.level.root=debug\",  // For debugging\n        \"logging.level.org.springframework.web=trace\"\n    )\n)\n</code></pre>"},{"location":"best-practices/#use-container-inspection","title":"Use Container Inspection","text":"<p>Debug container issues:</p> <pre><code>TestSystem.validate {\n    mongodb {\n        val info = inspect()\n        println(\"Container ID: ${info?.containerId}\")\n        println(\"Network: ${info?.network}\")\n        println(\"IP: ${info?.ipAddress}\")\n    }\n}\n</code></pre>"},{"location":"best-practices/#access-application-beans","title":"Access Application Beans","text":"<p>Debug by accessing application components:</p> <pre><code>TestSystem.validate {\n    using&lt;OrderRepository&gt; {\n        val order = findById(orderId)\n        println(\"Order state: $order\")\n    }\n\n    using&lt;OrderService, PaymentService&gt; { orderService, paymentService -&gt;\n        // Debug complex scenarios\n    }\n}\n</code></pre>"},{"location":"best-practices/#cicd-considerations","title":"CI/CD Considerations","text":""},{"location":"best-practices/#use-provided-instances-in-ci","title":"Use Provided Instances in CI","text":"<p>For faster CI builds, use pre-provisioned infrastructure:</p> <pre><code>val isCI = System.getenv(\"CI\") == \"true\"\n\nTestSystem()\n    .with {\n        kafka {\n            if (isCI) {\n                KafkaSystemOptions.provided(\n                    bootstrapServers = System.getenv(\"KAFKA_SERVERS\"),\n                    configureExposedConfiguration = { cfg -&gt;\n                        listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n                    }\n                )\n            } else {\n                KafkaSystemOptions {\n                    listOf(\"kafka.bootstrapServers=${it.bootstrapServers}\")\n                }\n            }\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#configure-docker-registry","title":"Configure Docker Registry","text":"<p>For corporate environments:</p> <pre><code>// Set globally for all components\nDEFAULT_REGISTRY = System.getenv(\"DOCKER_REGISTRY\") ?: \"docker.io\"\n</code></pre>"},{"location":"best-practices/#handle-resource-constraints","title":"Handle Resource Constraints","text":"<p>Configure for CI resource limits:</p> <pre><code>TestSystem()\n    .with {\n        couchbase {\n            CouchbaseSystemOptions(\n                container = CouchbaseContainerOptions(\n                    containerFn = { container -&gt;\n                        container.withCreateContainerCmdModifier { cmd -&gt;\n                            cmd.hostConfig?.withMemory(512 * 1024 * 1024)  // 512MB limit\n                        }\n                    }\n                )\n            ) { /* config */ }\n        }\n    }\n    .run()\n</code></pre>"},{"location":"best-practices/#common-anti-patterns","title":"Common Anti-Patterns","text":""},{"location":"best-practices/#testing-implementation-details","title":"\u274c Testing Implementation Details","text":"<pre><code>// Bad: Testing internal implementation\nusing&lt;OrderRepository&gt; {\n    save(order)\n}\nshouldGet&lt;Order&gt;(orderId) { /* verify */ }\n\n// Good: Test through the API\nhttp {\n    postAndExpectBody&lt;OrderResponse&gt;(\"/orders\", body = order.some()) { /* verify */ }\n}\ncouchbase {\n    shouldGet&lt;Order&gt;(\"orders\", orderId) { /* verify */ }\n}\n</code></pre>"},{"location":"best-practices/#sleeping-instead-of-waiting","title":"\u274c Sleeping Instead of Waiting","text":"<pre><code>// Bad: Fixed sleep\nhttp { post(\"/async-operation\") }\nThread.sleep(5000)  // Fragile!\nkafka { shouldBeConsumed&lt;Event&gt; { true } }\n\n// Good: Poll with timeout\nkafka {\n    shouldBePublished&lt;Event&gt;(atLeastIn = 10.seconds) {\n        actual.id == expectedId\n    }\n}\n</code></pre>"},{"location":"best-practices/#sharing-state-between-tests","title":"\u274c Sharing State Between Tests","text":"<pre><code>// Bad: Shared mutable state\nvar createdUserId: String? = null\n\ntest(\"create user\") {\n    createdUserId = createUser()\n}\n\ntest(\"get user\") {\n    getUser(createdUserId!!)  // Depends on test order!\n}\n\n// Good: Independent tests\ntest(\"create and get user\") {\n    val userId = createUser()\n    getUser(userId)\n}\n</code></pre>"},{"location":"best-practices/#overly-broad-assertions","title":"\u274c Overly Broad Assertions","text":"<pre><code>// Bad: Too vague\nresponse.status shouldBe 200\n\n// Good: Specific assertions\nresponse.status shouldBe 200\nresponse.body().id shouldBe expectedId\nresponse.body().status shouldBe \"ACTIVE\"\nresponse.body().createdAt shouldNotBe null\n</code></pre>"},{"location":"best-practices/#summary","title":"Summary","text":"Do Don't Use unique test data Use hardcoded IDs Test through public APIs Test implementation details Mock external services Call real external services Use appropriate timeouts Use fixed sleeps Clean up test data Leave test artifacts Keep tests independent Share state between tests Be specific in assertions Use vague assertions Test error scenarios Only test happy paths"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get Stove up and running in your project in just a few minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>JDK 17+ - Stove requires Java 17 or higher</li> <li>Docker - Latest version recommended (Stove uses testcontainers under the hood)</li> <li>Kotlin 1.8+ - For writing your tests</li> <li>Gradle or Maven - Gradle is recommended and used in all examples</li> </ul> <p>IDE Setup</p> <p>If you're using IntelliJ IDEA, install the Kotest plugin for a better testing experience with run buttons and test discovery.</p>"},{"location":"getting-started/#step-1-add-dependencies","title":"Step 1: Add Dependencies","text":"<p>Add Stove to your <code>build.gradle.kts</code>:</p> <pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    // Core framework\n    testImplementation(\"com.trendyol:stove-testing-e2e:$stoveVersion\")\n\n    // Choose your application framework\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:$stoveVersion\")\n    // OR\n    testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$stoveVersion\")\n\n    // Add components you need\n    testImplementation(\"com.trendyol:stove-testing-e2e-http:$stoveVersion\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$stoveVersion\")\n    // ... add more as needed\n}\n</code></pre> <p>Latest Version</p> <p>Check the Releases page for the latest version.</p>"},{"location":"getting-started/#step-2-prepare-your-application","title":"Step 2: Prepare Your Application","text":"<p>Stove needs to start your application from the test context. This requires a small modification to your main function.</p> Spring BootKtor <pre><code>// Before\n@SpringBootApplication\nclass MyApplication\n\nfun main(args: Array&lt;String&gt;) {\n    runApplication&lt;MyApplication&gt;(*args)\n}\n\n// After\n@SpringBootApplication\nclass MyApplication\n\nfun main(args: Array&lt;String&gt;) = run(args)\n\nfun run(\n    args: Array&lt;String&gt;,\n    init: SpringApplication.() -&gt; Unit = {}\n): ConfigurableApplicationContext {\n    return runApplication&lt;MyApplication&gt;(*args, init = init)\n}\n</code></pre> <pre><code>// Before\nfun main() {\n    embeddedServer(Netty, port = 8080) {\n        configureRouting()\n    }.start(wait = true)\n}\n\n// After\nobject MyApp {\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) = run(args)\n\n    fun run(\n        args: Array&lt;String&gt;,\n        wait: Boolean = true,\n        configure: Application.() -&gt; Unit = {}\n    ): Application {\n        // Your application setup\n        return embeddedServer(Netty, port = args.getPort()) {\n            configureRouting()\n            configure()\n        }.start(wait = wait)\n    }\n}\n</code></pre>"},{"location":"getting-started/#step-3-create-test-configuration","title":"Step 3: Create Test Configuration","text":"<p>Set up Stove once for your entire test suite. We recommend using a dedicated <code>src/test-e2e</code> source set for e2e tests (see Best Practices for Gradle configuration).</p> KotestJUnit <pre><code>// src/test-e2e/kotlin/e2e/TestConfig.kt\nclass TestConfig : AbstractProjectConfig() {\n\n    override suspend fun beforeProject() {\n        TestSystem()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions(\n                        baseUrl = \"http://localhost:8080\"\n                    )\n                }\n\n                springBoot(\n                    runner = { params -&gt; \n                        com.myapp.run(params)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8080\",\n                        \"logging.level.root=warn\"\n                    )\n                )\n            }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        TestSystem.stop()\n    }\n}\n</code></pre> <pre><code>// src/test-e2e/kotlin/e2e/TestConfig.kt\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nabstract class BaseE2ETest {\n\n    companion object {\n        @JvmStatic\n        @BeforeAll\n        fun setup() = runBlocking {\n            TestSystem()\n                .with {\n                    httpClient {\n                        HttpClientSystemOptions(\n                            baseUrl = \"http://localhost:8080\"\n                        )\n                    }\n\n                    springBoot(\n                        runner = { params -&gt; \n                            com.myapp.run(params)\n                        },\n                        withParameters = listOf(\n                            \"server.port=8080\",\n                            \"logging.level.root=warn\"\n                        )\n                    )\n                }\n                .run()\n        }\n\n        @JvmStatic\n        @AfterAll\n        fun teardown() = runBlocking {\n            TestSystem.stop()\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#step-4-write-your-first-test","title":"Step 4: Write Your First Test","text":"KotestJUnit <pre><code>class MyFirstE2ETest : FunSpec({\n\n    test(\"should return hello world\") {\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello\") { response -&gt;\n                    response shouldBe \"Hello, World!\"\n                }\n            }\n        }\n    }\n\n    test(\"should create a user\") {\n        TestSystem.validate {\n            http {\n                postAndExpectBody&lt;UserResponse&gt;(\n                    uri = \"/users\",\n                    body = CreateUserRequest(name = \"John\", email = \"john@example.com\").some()\n                ) { response -&gt;\n                    response.status shouldBe 201\n                    response.body().name shouldBe \"John\"\n                }\n            }\n        }\n    }\n})\n</code></pre> <pre><code>class MyFirstE2ETest : BaseE2ETest() {\n\n    @Test\n    fun `should return hello world`() = runBlocking {\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello\") { response -&gt;\n                    response shouldBe \"Hello, World!\"\n                }\n            }\n        }\n    }\n\n    @Test\n    fun `should create a user`() = runBlocking {\n        TestSystem.validate {\n            http {\n                postAndExpectBody&lt;UserResponse&gt;(\n                    uri = \"/users\",\n                    body = CreateUserRequest(name = \"John\", email = \"john@example.com\").some()\n                ) { response -&gt;\n                    response.status shouldBe 201\n                    response.body().name shouldBe \"John\"\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#step-5-add-more-components","title":"Step 5: Add More Components","text":"<p>As your application grows, add more components:</p> <pre><code>TestSystem()\n    .with {\n        httpClient {\n            HttpClientSystemOptions(baseUrl = \"http://localhost:8080\")\n        }\n\n        // Add Kafka for event-driven tests\n        kafka {\n            KafkaSystemOptions {\n                listOf(\n                    \"kafka.bootstrapServers=${it.bootstrapServers}\",\n                    \"kafka.interceptorClasses=${it.interceptorClass}\"\n                )\n            }\n        }\n\n        // Add Couchbase for database tests\n        couchbase {\n            CouchbaseSystemOptions(\n                defaultBucket = \"myBucket\",\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"couchbase.hosts=${cfg.hostsWithPort}\",\n                        \"couchbase.username=${cfg.username}\",\n                        \"couchbase.password=${cfg.password}\"\n                    )\n                }\n            )\n        }\n\n        // Add WireMock for external service mocking\n        wiremock {\n            WireMockSystemOptions(port = 9090)\n        }\n\n        // Add bridge for DI container access\n        bridge()\n\n        springBoot(\n            runner = { params -&gt; com.myapp.run(params) },\n            withParameters = listOf(\n                \"server.port=8080\",\n                \"external.service.url=http://localhost:9090\"\n            )\n        )\n    }\n    .run()\n</code></pre>"},{"location":"getting-started/#step-6-write-comprehensive-tests","title":"Step 6: Write Comprehensive Tests","text":"<p>Now you can write tests that span multiple systems:</p> <pre><code>test(\"should create order and publish event\") {\n    TestSystem.validate {\n        val orderId = UUID.randomUUID().toString()\n\n        // Mock external payment service\n        wiremock {\n            mockPost(\n                url = \"/payments\",\n                statusCode = 200,\n                responseBody = PaymentResult(success = true).some()\n            )\n        }\n\n        // Create order via API\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(\n                    id = orderId,\n                    items = listOf(\"item1\", \"item2\"),\n                    amount = 99.99\n                ).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // Verify order stored in database\n        couchbase {\n            shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n                order.status shouldBe \"CREATED\"\n                order.amount shouldBe 99.99\n            }\n        }\n\n        // Verify event was published\n        kafka {\n            shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n                actual.orderId == orderId &amp;&amp;\n                actual.amount == 99.99\n            }\n        }\n\n        // Access application beans directly\n        using&lt;OrderService&gt; {\n            val order = getOrder(orderId)\n            order.status shouldBe \"CREATED\"\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#running-tests","title":"Running Tests","text":"<p>Run your tests using Gradle:</p> <pre><code>./gradlew test\n</code></pre> <p>Or run specific test classes:</p> <pre><code>./gradlew test --tests \"com.myapp.e2e.OrderE2ETest\"\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Components documentation for each available component</li> <li>Learn about Best Practices for writing effective e2e tests</li> <li>Check Troubleshooting if you encounter issues</li> <li>Browse Examples for complete working projects</li> </ul>"},{"location":"getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/#keep-dependencies-running","title":"Keep Dependencies Running","text":"<p>For faster development cycles, keep containers running between test runs:</p> <pre><code>TestSystem {\n    keepDependenciesRunning()\n}.with {\n    // Your configuration\n}.run()\n</code></pre>"},{"location":"getting-started/#custom-container-registry","title":"Custom Container Registry","text":"<p>If you're behind a corporate firewall:</p> <pre><code>// Set globally\nDEFAULT_REGISTRY = \"your.registry.com\"\n\n// Or per component\nkafka {\n    KafkaSystemOptions(\n        container = KafkaContainerOptions(\n            registry = \"your.registry.com\"\n        )\n    )\n}\n</code></pre>"},{"location":"getting-started/#use-random-test-data","title":"Use Random Test Data","text":"<p>Generate unique data for each test:</p> <pre><code>test(\"should create user\") {\n    val userId = UUID.randomUUID().toString()\n    val email = \"test-${UUID.randomUUID()}@example.com\"\n\n    TestSystem.validate {\n        // Use unique data to avoid conflicts\n    }\n}\n</code></pre>"},{"location":"getting-started/#troubleshooting-quick-tips","title":"Troubleshooting Quick Tips","text":"Problem Solution Docker not found Ensure Docker is running and accessible Port conflicts Use dynamic ports or ensure no conflicts Slow startup Enable <code>keepDependenciesRunning()</code> for development Serialization errors Configure <code>StoveSerde</code> to match your app's serializer Test isolation issues Use unique test data and cleanup functions <p>For more help, see the Troubleshooting Guide.</p>"},{"location":"troubleshooting/","title":"Troubleshooting &amp; FAQ","text":"<p>This guide helps you diagnose and resolve common issues when working with Stove.</p>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#docker-issues","title":"Docker Issues","text":""},{"location":"troubleshooting/#docker-not-found-not-running","title":"Docker Not Found / Not Running","text":"<p>Symptoms: <pre><code>Could not find a valid Docker environment\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify Docker is installed and running: <pre><code>docker --version\ndocker ps\n</code></pre></p> </li> <li> <p>Check Docker daemon status: <pre><code># macOS/Linux\nsystemctl status docker\n\n# or\ndocker info\n</code></pre></p> </li> <li> <p>Restart Docker Desktop (if using Docker Desktop)</p> </li> <li> <p>Check Docker socket permissions: <pre><code># Linux\nsudo chmod 666 /var/run/docker.sock\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#docker-image-pull-failures","title":"Docker Image Pull Failures","text":"<p>Symptoms: <pre><code>Error pulling image: denied: access denied\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Use a custom registry: <pre><code>DEFAULT_REGISTRY = \"your-registry.com\"\n</code></pre></p> </li> <li> <p>Login to registry: <pre><code>docker login your-registry.com\n</code></pre></p> </li> <li> <p>Configure per-component registry: <pre><code>kafka {\n    KafkaSystemOptions(\n        container = KafkaContainerOptions(\n            registry = \"your-registry.com\"\n        )\n    ) { /* config */ }\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#port-already-in-use","title":"Port Already in Use","text":"<p>Symptoms: <pre><code>Bind for 0.0.0.0:8080 failed: port is already allocated\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Find and kill the process using the port: <pre><code># macOS/Linux\nlsof -i :8080\nkill -9 &lt;PID&gt;\n\n# Windows\nnetstat -ano | findstr :8080\ntaskkill /PID &lt;PID&gt; /F\n</code></pre></p> </li> <li> <p>Use a different port: <pre><code>springBoot(\n    runner = { params -&gt; myApp.run(params) },\n    withParameters = listOf(\"server.port=8081\")\n)\n</code></pre></p> </li> <li> <p>Use dynamic ports: Let the framework assign available ports when possible.</p> </li> </ol>"},{"location":"troubleshooting/#startup-issues","title":"Startup Issues","text":""},{"location":"troubleshooting/#application-fails-to-start","title":"Application Fails to Start","text":"<p>Symptoms: <pre><code>Application failed to start\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check application logs: <pre><code>springBoot(\n    withParameters = listOf(\n        \"logging.level.root=debug\",\n        \"logging.level.org.springframework=debug\"\n    )\n)\n</code></pre></p> </li> <li> <p>Verify configuration is being passed correctly: <pre><code>kafka {\n    KafkaSystemOptions { cfg -&gt;\n        println(\"Kafka config: ${cfg.bootstrapServers}\")  // Debug print\n        listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n    }\n}\n</code></pre></p> </li> <li> <p>Ensure your application accepts CLI arguments: <pre><code>// Application should parse args\nfun run(args: Array&lt;String&gt;) {\n    // args should include Stove's configuration\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#container-startup-timeout","title":"Container Startup Timeout","text":"<p>Symptoms: <pre><code>Container startup timed out\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase container startup timeout: <pre><code>couchbase {\n    CouchbaseSystemOptions(\n        container = CouchbaseContainerOptions(\n            containerFn = { container -&gt;\n                container.withStartupTimeout(Duration.ofMinutes(5))\n            }\n        )\n    ) { /* config */ }\n}\n</code></pre></p> </li> <li> <p>Check container resource requirements:</p> </li> <li>Elasticsearch needs at least 2GB RAM</li> <li>Couchbase needs significant memory</li> <li> <p>Reduce memory limits in resource-constrained environments</p> </li> <li> <p>Check Docker resources:</p> </li> <li>Increase Docker Desktop memory allocation</li> <li>Ensure sufficient disk space</li> </ol>"},{"location":"troubleshooting/#test-failures","title":"Test Failures","text":""},{"location":"troubleshooting/#assertion-timeout","title":"Assertion Timeout","text":"<p>Symptoms: <pre><code>Timed out waiting for condition\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase assertion timeout: <pre><code>kafka {\n    shouldBePublished&lt;Event&gt;(atLeastIn = 30.seconds) {\n        actual.id == expectedId\n    }\n}\n</code></pre></p> </li> <li> <p>Check if the operation actually completes:</p> </li> <li>Add logging to verify the operation is triggered</li> <li> <p>Check application logs for errors</p> </li> <li> <p>Verify async processing is working: <pre><code>// Debug by checking intermediate state\nusing&lt;EventProcessor&gt; {\n    println(\"Pending events: ${pendingCount()}\")\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#serializationdeserialization-errors","title":"Serialization/Deserialization Errors","text":"<p>Symptoms: <pre><code>JsonParseException: Unrecognized field\nMismatchedInputException: Cannot deserialize\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Align ObjectMapper configuration: <pre><code>val objectMapper = ObjectMapper().apply {\n    registerModule(KotlinModule.Builder().build())\n    registerModule(JavaTimeModule())\n    disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n}\n\nTestSystem()\n    .with {\n        http {\n            HttpClientSystemOptions(\n                contentConverter = JacksonConverter(objectMapper)\n            )\n        }\n        kafka {\n            KafkaSystemOptions(\n                serde = StoveSerde.jackson.anyByteArraySerde(objectMapper)\n            ) { /* config */ }\n        }\n    }\n</code></pre></p> </li> <li> <p>Check field name mapping: <pre><code>data class MyEvent(\n    @JsonProperty(\"eventId\")  // Match exact field name\n    val id: String\n)\n</code></pre></p> </li> <li> <p>Verify data class has default constructor for Jackson: <pre><code>// Add default values or use @JsonCreator\ndata class MyEvent(\n    val id: String = \"\",\n    val name: String = \"\"\n)\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#data-not-found","title":"Data Not Found","text":"<p>Symptoms: <pre><code>Resource with key (xxx) is not found\nDocument not found\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify data was actually saved: <pre><code>// Save\ncouchbase {\n    save(collection = \"orders\", id = orderId, instance = order)\n\n    // Immediately verify\n    shouldGet&lt;Order&gt;(\"orders\", orderId) { o -&gt;\n        println(\"Saved order: $o\")\n    }\n}\n</code></pre></p> </li> <li> <p>Check timing - wait for async operations: <pre><code>// If save is async, wait for it\ndelay(1.seconds)\n\ncouchbase {\n    shouldGet&lt;Order&gt;(\"orders\", orderId) { /* verify */ }\n}\n</code></pre></p> </li> <li> <p>Verify collection/index names match: <pre><code>// Ensure collection names are consistent\nsave(collection = \"orders\", ...)  // Note: \"orders\" not \"order\"\nshouldGet&lt;Order&gt;(\"orders\", ...)   // Must match!\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#kafka-message-not-found","title":"Kafka Message Not Found","text":"<p>Symptoms: <pre><code>Message was not published within timeout\nMessage was not consumed within timeout\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify Kafka interceptor is configured: <pre><code>// In TestInitializer\nclass TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;TestSystemInterceptor&gt;(isPrimary = true)\n})\n</code></pre></p> </li> <li> <p>Check topic names: <pre><code>kafka {\n    shouldBePublished&lt;Event&gt;(atLeastIn = 10.seconds) {\n        println(\"Checking topic: ${metadata.topic}\")  // Debug\n        actual.id == expectedId\n    }\n}\n</code></pre></p> </li> <li> <p>Verify interceptor class is passed to application: <pre><code>kafka {\n    KafkaSystemOptions { cfg -&gt;\n        listOf(\n            \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n            \"kafka.interceptorClasses=${cfg.interceptorClass}\"  // Important!\n        )\n    }\n}\n</code></pre></p> </li> <li> <p>Check consumer group offset configuration: <pre><code>springBoot(\n    withParameters = listOf(\n        \"kafka.offset=earliest\",  // Start from beginning\n        \"kafka.autoCreateTopics=true\"\n    )\n)\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#wiremock-stubs-not-being-hit","title":"WireMock Stubs Not Being Hit","text":"<p>Symptoms: <pre><code>Connection refused to external service\nTest timeout when calling mocked endpoint\nMock not found / unexpected request\n</code></pre></p> <p>Cause: This is almost always because your application's external service URLs don't match the WireMock URL.</p> <p>Solutions:</p> <ol> <li> <p>Ensure ALL external service URLs point to WireMock: <pre><code>TestSystem()\n    .with {\n        wiremock {\n            WireMockSystemOptions(port = 9090)\n        }\n        springBoot(\n            runner = { params -&gt; myApp.run(params) },\n            withParameters = listOf(\n                // ALL external services must use WireMock URL\n                \"payment.service.url=http://localhost:9090\",\n                \"inventory.service.url=http://localhost:9090\",\n                \"notification.service.url=http://localhost:9090\"\n            )\n        )\n    }\n</code></pre></p> </li> <li> <p>Verify your application is reading the URLs from configuration: <pre><code>// Your application should read URLs from config, not hardcode them\n@Value(\"\\${payment.service.url}\")\nprivate lateinit var paymentServiceUrl: String\n</code></pre></p> </li> <li> <p>Check the port matches: <pre><code>// WireMock port\nWireMockSystemOptions(port = 9090)\n\n// Application parameter must match\n\"payment.service.url=http://localhost:9090\"  // Same port!\n</code></pre></p> </li> <li> <p>Debug by checking WireMock requests: <pre><code>wiremock {\n    // After test, check what requests WireMock received\n    WireMock.getAllServeEvents().forEach { event -&gt;\n        println(\"Request: ${event.request.url}\")\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#memory-issues","title":"Memory Issues","text":""},{"location":"troubleshooting/#outofmemoryerror","title":"OutOfMemoryError","text":"<p>Symptoms: <pre><code>java.lang.OutOfMemoryError: Java heap space\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase JVM heap for tests: <pre><code>// build.gradle.kts\ntasks.test {\n    jvmArgs(\"-Xmx2g\", \"-Xms512m\")\n}\n</code></pre></p> </li> <li> <p>Limit container memory: <pre><code>elasticsearch {\n    ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n            containerFn = { container -&gt;\n                container.withEnv(\"ES_JAVA_OPTS\", \"-Xms512m -Xmx512m\")\n            }\n        )\n    ) { /* config */ }\n}\n</code></pre></p> </li> <li> <p>Use provided instances instead of containers for CI environments.</p> </li> </ol>"},{"location":"troubleshooting/#cicd-issues","title":"CI/CD Issues","text":""},{"location":"troubleshooting/#docker-in-docker-not-working","title":"Docker-in-Docker Not Working","text":"<p>Solutions:</p> <ol> <li> <p>Use DinD sidecar in CI: <pre><code># GitLab CI example\nservices:\n  - docker:dind\nvariables:\n  DOCKER_HOST: tcp://docker:2375\n</code></pre></p> </li> <li> <p>Use provided instances: <pre><code>TestSystem()\n    .with {\n        kafka {\n            KafkaSystemOptions.provided(\n                bootstrapServers = System.getenv(\"KAFKA_SERVERS\"),\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n                }\n            )\n        }\n    }\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#slow-ci-builds","title":"Slow CI Builds","text":"<p>Solutions:</p> <ol> <li>Use provided instances for external infrastructure</li> <li>Enable container reuse: <pre><code>TestSystem {\n    keepDependenciesRunning()  // In development only\n}\n</code></pre></li> <li>Run tests in parallel (ensure proper isolation)</li> <li>Use smaller container images when available</li> </ol>"},{"location":"troubleshooting/#intermittent-failures-with-shared-infrastructure","title":"Intermittent Failures with Shared Infrastructure","text":"<p>Symptoms: <pre><code>Tests pass locally but fail randomly in CI\nData from another test run appears in assertions\n\"Topic already exists\" or \"Index already exists\" errors\nTests fail when multiple builds run in parallel\n</code></pre></p> <p>Cause: Multiple test runs are using the same resource names (databases, topics, indices) in shared infrastructure.</p> <p>Solutions:</p> <ol> <li> <p>Use unique resource prefixes per test run: <pre><code>object TestRunContext {\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: UUID.randomUUID().toString().take(8)\n\n    val databaseName = \"testdb_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n}\n</code></pre></p> </li> <li> <p>Apply prefixes to all resources: <pre><code>springBoot(\n    withParameters = listOf(\n        \"spring.datasource.url=jdbc:postgresql://db:5432/${TestRunContext.databaseName}\",\n        \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n        \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\"\n    )\n)\n</code></pre></p> </li> <li> <p>Clean up only your resources: <pre><code>cleanup = { admin -&gt;\n    val ourTopics = admin.listTopics().names().get()\n        .filter { it.startsWith(TestRunContext.topicPrefix) }\n    if (ourTopics.isNotEmpty()) {\n        admin.deleteTopics(ourTopics).all().get()\n    }\n}\n</code></pre></p> </li> <li> <p>Log the run ID for debugging: <pre><code>init {\n    println(\"Test Run ID: ${TestRunContext.runId}\")\n}\n</code></pre></p> </li> </ol> <p>Detailed Guide</p> <p>See Provided Instances - Test Isolation for comprehensive examples.</p>"},{"location":"troubleshooting/#faq","title":"FAQ","text":""},{"location":"troubleshooting/#general-questions","title":"General Questions","text":""},{"location":"troubleshooting/#q-can-i-use-stove-with-java","title":"Q: Can I use Stove with Java?","text":"<p>A: Yes, you can use Stove in Java projects! However, the e2e tests themselves need to be written in Kotlin. Stove's DSL is designed specifically for Kotlin, providing a clean and expressive syntax:</p> <pre><code>class MyE2ETest : FunSpec({\n    test(\"should create order\") {\n        TestSystem.validate {\n            http {\n                postAndExpectBodilessResponse(\n                    uri = \"/orders\",\n                    body = Some(CreateOrderRequest()),\n                    expect = { status shouldBe 201 }\n                )\n            }\n        }\n    }\n})\n</code></pre> <p>You can still test your Java application with Stove - just write your e2e test files in Kotlin.</p>"},{"location":"troubleshooting/#q-can-i-use-junit-instead-of-kotest","title":"Q: Can I use JUnit instead of Kotest?","text":"<p>A: Yes, Stove works with both JUnit and Kotest. See the Getting Started guide for JUnit examples.</p>"},{"location":"troubleshooting/#q-how-do-i-debug-tests","title":"Q: How do I debug tests?","text":"<p>A: </p> <ol> <li>Set breakpoints in your application code</li> <li>Run tests in debug mode</li> <li>Use verbose logging:    <pre><code>withParameters = listOf(\"logging.level.root=debug\")\n</code></pre></li> <li>Access application beans:    <pre><code>using&lt;MyService&gt; {\n    println(\"Service state: $this\")\n}\n</code></pre></li> </ol>"},{"location":"troubleshooting/#q-can-i-run-tests-in-parallel","title":"Q: Can I run tests in parallel?","text":"<p>A: Yes, but ensure proper test isolation:</p> <ul> <li>Use unique test data (UUIDs)</li> <li>Don't share state between tests</li> <li>Be careful with shared resources</li> </ul>"},{"location":"troubleshooting/#q-how-do-i-test-with-ssltls","title":"Q: How do I test with SSL/TLS?","text":"<p>A: Configure the component with security enabled:</p> <pre><code>elasticsearch {\n    ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n            disableSecurity = false\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n            // Certificate info available in cfg.certificate\n            listOf(...)\n        }\n    )\n}\n</code></pre>"},{"location":"troubleshooting/#component-specific-questions","title":"Component-Specific Questions","text":""},{"location":"troubleshooting/#q-why-isnt-my-kafka-message-being-intercepted","title":"Q: Why isn't my Kafka message being intercepted?","text":"<p>A: Ensure:</p> <ol> <li><code>TestSystemInterceptor</code> is registered as a bean</li> <li><code>kafka.interceptorClasses</code> is configured correctly</li> <li>Your Kafka listener container uses the interceptor</li> </ol> <pre><code>// Application configuration\n@Bean\nfun containerFactory(\n    interceptor: ConsumerAwareRecordInterceptor&lt;String, String&gt;\n): ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; {\n    return ConcurrentKafkaListenerContainerFactory&lt;String, String&gt;().apply {\n        setRecordInterceptor(interceptor)\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#q-how-do-i-test-multiple-databases","title":"Q: How do I test multiple databases?","text":"<p>A: Add multiple database components:</p> <pre><code>TestSystem()\n    .with {\n        postgresql { PostgresqlOptions(...) }\n        mongodb { MongodbSystemOptions(...) }\n        couchbase { CouchbaseSystemOptions(...) }\n    }\n</code></pre>"},{"location":"troubleshooting/#q-can-i-use-custom-container-images","title":"Q: Can I use custom container images?","text":"<p>A: Yes:</p> <pre><code>kafka {\n    KafkaSystemOptions(\n        container = KafkaContainerOptions(\n            registry = \"my-registry.com\",\n            image = \"custom/kafka\",\n            tag = \"3.5.0\"\n        )\n    ) { /* config */ }\n}\n</code></pre>"},{"location":"troubleshooting/#q-how-do-i-handle-database-migrations","title":"Q: How do I handle database migrations?","text":"<p>A: Use the migrations API:</p> <pre><code>postgresql {\n    PostgresqlOptions(...).migrations {\n        register&lt;CreateUserTableMigration&gt;()\n        register&lt;CreateOrderTableMigration&gt;()\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#q-can-i-access-the-underlying-testcontainer","title":"Q: Can I access the underlying testcontainer?","text":"<p>A: For container operations like pause/unpause:</p> <pre><code>couchbase {\n    pause()    // Pause container\n    unpause()  // Resume container\n}\n</code></pre> <p>For the client: <pre><code>elasticsearch {\n    val client = client()  // Get Elasticsearch client\n    // Use client directly\n}\n</code></pre></p>"},{"location":"troubleshooting/#performance-questions","title":"Performance Questions","text":""},{"location":"troubleshooting/#q-how-can-i-speed-up-test-execution","title":"Q: How can I speed up test execution?","text":"<p>A:</p> <ol> <li> <p>Keep containers running: <pre><code>TestSystem { keepDependenciesRunning() }\n</code></pre></p> </li> <li> <p>Use provided instances in CI: <pre><code>kafka { KafkaSystemOptions.provided(bootstrapServers = \"...\", configureExposedConfiguration = { ... }) }\n</code></pre></p> </li> <li> <p>Reduce container resource allocation: <pre><code>withEnv(\"ES_JAVA_OPTS\", \"-Xms256m -Xmx256m\")\n</code></pre></p> </li> <li> <p>Run independent tests in parallel</p> </li> </ol>"},{"location":"troubleshooting/#q-why-is-container-startup-slow","title":"Q: Why is container startup slow?","text":"<p>A: Container startup depends on:</p> <ul> <li>Image pull time (first run)</li> <li>Container initialization time</li> <li>Health check completion</li> </ul> <p>Solutions: - Pre-pull images in CI - Use <code>keepDependenciesRunning()</code> locally - Increase startup timeout for slow containers</p>"},{"location":"troubleshooting/#migration-questions","title":"Migration Questions","text":""},{"location":"troubleshooting/#q-how-do-i-migrate-from-014x-to-015x","title":"Q: How do I migrate from 0.14.x to 0.15.x?","text":"<p>A: See Migration Notes for detailed instructions. Key changes:</p> <ul> <li><code>StoveSerde</code> replaces direct <code>ObjectMapper</code> usage</li> <li>Configure serde for each component that needs it</li> </ul>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you can't find a solution:</p> <ol> <li>Search existing issues: GitHub Issues</li> <li>Check examples: Examples Directory</li> <li>Open a new issue: Include:</li> <li>Stove version</li> <li>JDK version</li> <li>Docker version</li> <li>Complete error message</li> <li>Minimal reproduction code</li> </ol>"},{"location":"troubleshooting/#debug-checklist","title":"Debug Checklist","text":"<p>When troubleshooting, check these items:</p> <ul> <li>[ ] Docker is running and accessible</li> <li>[ ] Correct Stove version in dependencies</li> <li>[ ] Application main function is properly modified</li> <li>[ ] Configuration is passed to application</li> <li>[ ] Serializers match between Stove and application</li> <li>[ ] Container has enough resources</li> <li>[ ] Ports are not conflicting</li> <li>[ ] Network is accessible (for provided instances)</li> <li>[ ] Timeouts are appropriate for your environment</li> </ul>"},{"location":"writing-custom-systems/","title":"Writing Custom Systems","text":"<p>One of Stove's most powerful features is its extensibility. You can create your own custom systems to integrate with any component or capture any behavior specific to your application.</p>"},{"location":"writing-custom-systems/#why-write-custom-systems","title":"Why Write Custom Systems?","text":"<p>Custom systems are useful when you need to:</p> <ul> <li>Capture application events in memory for testing</li> <li>Integrate with schedulers like db-scheduler, Quartz, or custom job runners</li> <li>Test domain-specific behavior that isn't covered by built-in components</li> <li>Advance time or control time-bounded operations</li> <li>Access custom application components during tests</li> </ul>"},{"location":"writing-custom-systems/#core-concepts","title":"Core Concepts","text":""},{"location":"writing-custom-systems/#pluggedsystem-interface","title":"PluggedSystem Interface","text":"<p>All Stove systems implement the <code>PluggedSystem</code> interface:</p> <pre><code>interface PluggedSystem : AutoCloseable {\n    val testSystem: TestSystem\n}\n</code></pre>"},{"location":"writing-custom-systems/#lifecycle-interfaces","title":"Lifecycle Interfaces","text":"<p>Stove provides several lifecycle interfaces your system can implement:</p> Interface Method When Called <code>RunAware</code> <code>run()</code> Before application starts <code>AfterRunAware</code> <code>afterRun()</code> After application starts <code>AfterRunAwareWithContext&lt;T&gt;</code> <code>afterRun(context: T)</code> After application starts, with DI context <code>ExposesConfiguration</code> <code>configuration()</code> When collecting app configuration"},{"location":"writing-custom-systems/#registration-functions","title":"Registration Functions","text":"<p>To make your system available in the DSL, you need:</p> <ol> <li>Registration function - Adds system to TestSystem</li> <li>Getter function - Retrieves system from TestSystem  </li> <li>DSL extension functions - For <code>WithDsl</code> and <code>ValidationDsl</code></li> </ol>"},{"location":"writing-custom-systems/#example-1-db-scheduler-integration","title":"Example 1: Db-Scheduler Integration","text":"<p>Here's a complete example of integrating with db-scheduler:</p>"},{"location":"writing-custom-systems/#step-1-create-the-event-listener","title":"Step 1: Create the Event Listener","text":"<p>First, create a listener that captures scheduler events:</p> <pre><code>import com.github.kagkarlsson.scheduler.task.ExecutionComplete\nimport com.github.kagkarlsson.scheduler.task.TaskInstanceId\nimport java.time.Instant\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.concurrent.ConcurrentMap\nimport kotlin.reflect.KClass\nimport kotlin.time.Duration\nimport kotlinx.coroutines.*\n\nclass StoveDbSchedulerListener : AbstractSchedulerListener() {\n    private val completedExecutions: ConcurrentMap&lt;String, ExecutionComplete&gt; = ConcurrentHashMap()\n    private val scheduledExecutions: ConcurrentMap&lt;String, Instant&gt; = ConcurrentHashMap()\n\n    override fun onExecutionComplete(executionComplete: ExecutionComplete) {\n        completedExecutions[executionComplete.execution.taskInstance.id] = executionComplete\n    }\n\n    override fun onExecutionScheduled(taskInstanceId: TaskInstanceId, executionTime: Instant) {\n        scheduledExecutions[taskInstanceId.id] = executionTime\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    suspend fun &lt;T : Any&gt; waitUntilObserved(\n        atLeastIn: Duration,\n        clazz: KClass&lt;T&gt;,\n        condition: (T) -&gt; Boolean\n    ) = coroutineScope {\n        val getExecutions = { completedExecutions.map { it.value } }\n        val getExecutionData = { getExecutions().mapNotNull { it.execution.taskInstance?.data } }\n\n        getExecutionData.waitUntilConditionMet(atLeastIn, \"While OBSERVING ${clazz.java.simpleName}\") {\n            when {\n                clazz.java.isAssignableFrom(it.javaClass) -&gt; condition(it as T)\n                else -&gt; false\n            }\n        }\n    }\n\n    private suspend fun &lt;T&gt; (() -&gt; Collection&lt;T&gt;).waitUntilConditionMet(\n        duration: Duration,\n        subject: String,\n        condition: (T) -&gt; Boolean\n    ): Collection&lt;T&gt; = runCatching {\n        val collectionFunc = this\n        withTimeout(duration) {\n            while (!collectionFunc().any { condition(it) }) {\n                delay(50)\n            }\n        }\n        return collectionFunc().filter { condition(it) }\n    }.recoverCatching {\n        when (it) {\n            is TimeoutCancellationException -&gt; throw AssertionError(\"GOT A TIMEOUT: $subject.\")\n            is ConcurrentModificationException -&gt; \n                Result.success(waitUntilConditionMet(duration, subject, condition))\n            else -&gt; throw it\n        }.getOrThrow()\n    }.getOrThrow()\n}\n</code></pre>"},{"location":"writing-custom-systems/#step-2-create-the-system","title":"Step 2: Create the System","text":"<p>Create the system class that integrates with Stove:</p> <pre><code>import com.trendyol.stove.testing.e2e.system.TestSystem\nimport com.trendyol.stove.testing.e2e.system.abstractions.*\nimport org.springframework.context.ApplicationContext\nimport kotlin.time.Duration\nimport kotlin.time.Duration.Companion.seconds\nimport kotlinx.coroutines.coroutineScope\n\nclass DbSchedulerSystem(\n    override val testSystem: TestSystem\n) : PluggedSystem, AfterRunAwareWithContext&lt;ApplicationContext&gt; {\n\n    lateinit var listener: StoveDbSchedulerListener\n\n    override suspend fun afterRun(context: ApplicationContext) {\n        // Get the listener bean from Spring context\n        listener = context.getBean(StoveDbSchedulerListener::class.java)\n    }\n\n    /**\n     * Assert that a task was executed with the given condition.\n     */\n    suspend inline fun &lt;reified T : Any&gt; shouldBeExecuted(\n        atLeastIn: Duration = 5.seconds,\n        noinline condition: T.() -&gt; Boolean\n    ): DbSchedulerSystem = coroutineScope {\n        listener.waitUntilObserved(atLeastIn, T::class, condition)\n    }.let { this }\n\n    override fun close() {\n        // Cleanup if needed\n    }\n}\n</code></pre>"},{"location":"writing-custom-systems/#step-3-create-dsl-extensions","title":"Step 3: Create DSL Extensions","text":"<p>Create extension functions for the Stove DSL:</p> <pre><code>import arrow.core.getOrElse\nimport com.trendyol.stove.testing.e2e.system.*\nimport com.trendyol.stove.testing.e2e.system.abstractions.*\nimport com.trendyol.stove.testing.e2e.system.annotations.StoveDsl\n\n/**\n * Registers the DbSchedulerSystem with TestSystem.\n */\n@StoveDsl\nfun TestSystem.withDbSchedulerListener(): TestSystem = \n    getOrRegister(DbSchedulerSystem(this)).let { this }\n\n/**\n * Gets the DbSchedulerSystem from TestSystem.\n */\n@StoveDsl\nfun TestSystem.dbScheduler(): DbSchedulerSystem = \n    getOrNone&lt;DbSchedulerSystem&gt;().getOrElse { \n        throw SystemNotRegisteredException(DbSchedulerSystem::class) \n    }\n\n/**\n * Configuration DSL extension.\n */\n@StoveDsl\nfun WithDsl.dbScheduler(): TestSystem = \n    this.testSystem.withDbSchedulerListener()\n\n/**\n * Validation DSL extension.\n */\n@StoveDsl\nsuspend fun ValidationDsl.tasks(\n    validation: suspend DbSchedulerSystem.() -&gt; Unit\n): Unit = validation(this.testSystem.dbScheduler())\n</code></pre>"},{"location":"writing-custom-systems/#step-4-register-the-listener-bean","title":"Step 4: Register the Listener Bean","text":"<p>In your test initializer, register the listener as a Spring bean:</p> <pre><code>class TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;StoveDbSchedulerListener&gt;(isPrimary = true)\n})\n\nfun SpringApplication.addTestDependencies() {\n    this.addInitializers(TestInitializer())\n}\n</code></pre>"},{"location":"writing-custom-systems/#step-5-use-in-tests","title":"Step 5: Use in Tests","text":"<pre><code>// Configuration\nTestSystem()\n    .with {\n        httpClient { HttpClientSystemOptions(...) }\n        postgresql { PostgresqlOptions(...) }\n        dbScheduler()  // Register the custom system\n\n        springBoot(\n            runner = { params -&gt; \n                myApp.run(params) { addTestDependencies() }\n            }\n        )\n    }\n    .run()\n\n// In tests\ntest(\"should execute scheduled task\") {\n    TestSystem.validate {\n        // Trigger task scheduling\n        http {\n            postAndExpectBodilessResponse(\"/schedule-task\", body = TaskRequest(...).some()) {\n                it.status shouldBe 200\n            }\n        }\n\n        // Assert task was executed\n        tasks {\n            shouldBeExecuted&lt;MyScheduledTaskData&gt;(atLeastIn = 10.seconds) {\n                taskId == expectedTaskId &amp;&amp; \n                status == \"COMPLETED\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"writing-custom-systems/#example-2-in-memory-event-capture-system","title":"Example 2: In-Memory Event Capture System","text":"<p>Here's another example for capturing domain events published by your application:</p>"},{"location":"writing-custom-systems/#step-1-create-event-listener","title":"Step 1: Create Event Listener","text":"<pre><code>import org.springframework.context.event.EventListener\nimport java.util.concurrent.ConcurrentLinkedQueue\nimport kotlin.reflect.KClass\n\n/**\n * Captures all domain events in memory for testing.\n */\nclass StoveDomainEventListener {\n    private val capturedEvents = ConcurrentLinkedQueue&lt;Any&gt;()\n\n    @EventListener\n    fun onEvent(event: Any) {\n        capturedEvents.add(event)\n    }\n\n    fun getAllEvents(): List&lt;Any&gt; = capturedEvents.toList()\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun &lt;T : Any&gt; getEventsOfType(clazz: KClass&lt;T&gt;): List&lt;T&gt; =\n        capturedEvents\n            .filter { clazz.java.isAssignableFrom(it.javaClass) }\n            .map { it as T }\n\n    fun clear() = capturedEvents.clear()\n}\n</code></pre>"},{"location":"writing-custom-systems/#step-2-create-the-system_1","title":"Step 2: Create the System","text":"<pre><code>import com.trendyol.stove.testing.e2e.system.TestSystem\nimport com.trendyol.stove.testing.e2e.system.abstractions.*\nimport kotlinx.coroutines.*\nimport org.springframework.context.ApplicationContext\nimport kotlin.time.Duration\nimport kotlin.time.Duration.Companion.seconds\n\nclass DomainEventSystem(\n    override val testSystem: TestSystem\n) : PluggedSystem, AfterRunAwareWithContext&lt;ApplicationContext&gt; {\n\n    private lateinit var listener: StoveDomainEventListener\n\n    override suspend fun afterRun(context: ApplicationContext) {\n        listener = context.getBean(StoveDomainEventListener::class.java)\n    }\n\n    /**\n     * Assert that an event of type T was published matching the condition.\n     */\n    suspend inline fun &lt;reified T : Any&gt; shouldBePublished(\n        atLeastIn: Duration = 5.seconds,\n        crossinline condition: T.() -&gt; Boolean\n    ): DomainEventSystem = coroutineScope {\n        waitUntilEventObserved(atLeastIn, T::class) { condition(it) }\n        this@DomainEventSystem\n    }\n\n    /**\n     * Assert that no event of type T was published matching the condition.\n     */\n    inline fun &lt;reified T : Any&gt; shouldNotBePublished(\n        condition: T.() -&gt; Boolean\n    ): DomainEventSystem {\n        val events = listener.getEventsOfType(T::class)\n        val matchingEvents = events.filter { condition(it) }\n        if (matchingEvents.isNotEmpty()) {\n            throw AssertionError(\n                \"Expected no ${T::class.simpleName} matching condition, \" +\n                \"but found ${matchingEvents.size}: $matchingEvents\"\n            )\n        }\n        return this\n    }\n\n    /**\n     * Get all captured events of type T.\n     */\n    inline fun &lt;reified T : Any&gt; getEvents(): List&lt;T&gt; =\n        listener.getEventsOfType(T::class)\n\n    /**\n     * Clear all captured events.\n     */\n    fun clearEvents(): DomainEventSystem {\n        listener.clear()\n        return this\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    suspend fun &lt;T : Any&gt; waitUntilEventObserved(\n        atLeastIn: Duration,\n        clazz: KClass&lt;T&gt;,\n        condition: (T) -&gt; Boolean\n    ): T = withTimeout(atLeastIn) {\n        while (true) {\n            val events = listener.getEventsOfType(clazz)\n            val matching = events.find { condition(it) }\n            if (matching != null) {\n                return@withTimeout matching\n            }\n            delay(50)\n        }\n        @Suppress(\"UNREACHABLE_CODE\")\n        throw AssertionError(\"Should not reach here\")\n    }\n\n    override fun close() {\n        // Cleanup if needed\n    }\n}\n</code></pre>"},{"location":"writing-custom-systems/#step-3-create-dsl-extensions_1","title":"Step 3: Create DSL Extensions","text":"<pre><code>import arrow.core.getOrElse\nimport com.trendyol.stove.testing.e2e.system.*\nimport com.trendyol.stove.testing.e2e.system.abstractions.*\nimport com.trendyol.stove.testing.e2e.system.annotations.StoveDsl\n\n@StoveDsl\nfun TestSystem.withDomainEvents(): TestSystem =\n    getOrRegister(DomainEventSystem(this)).let { this }\n\n@StoveDsl\nfun TestSystem.domainEvents(): DomainEventSystem =\n    getOrNone&lt;DomainEventSystem&gt;().getOrElse {\n        throw SystemNotRegisteredException(DomainEventSystem::class)\n    }\n\n@StoveDsl\nfun WithDsl.domainEvents(): TestSystem =\n    this.testSystem.withDomainEvents()\n\n@StoveDsl\nsuspend fun ValidationDsl.domainEvents(\n    validation: suspend DomainEventSystem.() -&gt; Unit\n): Unit = validation(this.testSystem.domainEvents())\n</code></pre>"},{"location":"writing-custom-systems/#step-4-register-and-use","title":"Step 4: Register and Use","text":"<pre><code>// TestInitializer\nclass TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;StoveDomainEventListener&gt;(isPrimary = true)\n})\n\n// Configuration\nTestSystem()\n    .with {\n        httpClient { HttpClientSystemOptions(...) }\n        domainEvents()  // Register custom system\n        springBoot(\n            runner = { params -&gt; myApp.run(params) { addTestDependencies() } }\n        )\n    }\n    .run()\n\n// Tests\ntest(\"should publish UserCreatedEvent when user is created\") {\n    TestSystem.validate {\n        val userId = UUID.randomUUID().toString()\n\n        http {\n            postAndExpectBody&lt;UserResponse&gt;(\n                uri = \"/users\",\n                body = CreateUserRequest(id = userId, name = \"John\").some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        domainEvents {\n            shouldBePublished&lt;UserCreatedEvent&gt;(atLeastIn = 5.seconds) {\n                this.userId == userId &amp;&amp;\n                this.name == \"John\"\n            }\n\n            shouldNotBePublished&lt;UserDeletedEvent&gt; {\n                this.userId == userId\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"writing-custom-systems/#example-3-time-control-system","title":"Example 3: Time Control System","text":"<p>Control time-bounded operations in your tests:</p> <pre><code>import java.time.Clock\nimport java.time.Instant\nimport java.time.ZoneId\n\nclass StoveTestClock : Clock() {\n    @Volatile\n    private var instant: Instant = Instant.now()\n    private val zone: ZoneId = ZoneId.systemDefault()\n\n    override fun instant(): Instant = instant\n    override fun withZone(zone: ZoneId): Clock = this\n    override fun getZone(): ZoneId = zone\n\n    fun advance(duration: java.time.Duration) {\n        instant = instant.plus(duration)\n    }\n\n    fun setTime(newInstant: Instant) {\n        instant = newInstant\n    }\n\n    fun reset() {\n        instant = Instant.now()\n    }\n}\n\nclass TimeSystem(\n    override val testSystem: TestSystem\n) : PluggedSystem, AfterRunAwareWithContext&lt;ApplicationContext&gt; {\n\n    private lateinit var clock: StoveTestClock\n\n    override suspend fun afterRun(context: ApplicationContext) {\n        clock = context.getBean(StoveTestClock::class.java)\n    }\n\n    fun advance(duration: kotlin.time.Duration): TimeSystem {\n        clock.advance(java.time.Duration.ofMillis(duration.inWholeMilliseconds))\n        return this\n    }\n\n    fun setTime(instant: Instant): TimeSystem {\n        clock.setTime(instant)\n        return this\n    }\n\n    fun reset(): TimeSystem {\n        clock.reset()\n        return this\n    }\n\n    override fun close() {}\n}\n\n// DSL Extensions\n@StoveDsl\nfun WithDsl.timeControl(): TestSystem = \n    testSystem.getOrRegister(TimeSystem(testSystem)).let { testSystem }\n\n@StoveDsl\nsuspend fun ValidationDsl.time(\n    action: suspend TimeSystem.() -&gt; Unit\n): Unit = action(testSystem.getOrNone&lt;TimeSystem&gt;().getOrElse { \n    throw SystemNotRegisteredException(TimeSystem::class) \n})\n\n// Usage in tests\ntest(\"should expire session after 30 minutes\") {\n    TestSystem.validate {\n        // Create session and capture session ID\n        var sessionId: String = \"\"\n        http {\n            postAndExpectBody&lt;SessionResponse&gt;(\"/login\", body = credentials.some()) { response -&gt;\n                sessionId = response.body().sessionId \n            }\n        }\n\n        // Advance time by 31 minutes\n        time {\n            advance(31.minutes)\n        }\n\n        // Session should be expired\n        http {\n            getResponse&lt;ErrorResponse&gt;(\"/protected\", headers = mapOf(\"Session-ID\" to sessionId)) { response -&gt;\n                response.status shouldBe 401\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"writing-custom-systems/#implementing-exposesconfiguration","title":"Implementing ExposesConfiguration","text":"<p>If your system needs to provide configuration to the application:</p> <pre><code>class MyCustomSystem(\n    override val testSystem: TestSystem,\n    private val options: MySystemOptions\n) : PluggedSystem, RunAware, ExposesConfiguration {\n\n    private lateinit var config: MyExposedConfig\n\n    override suspend fun run() {\n        // Initialize and prepare configuration\n        config = MyExposedConfig(\n            host = \"localhost\",\n            port = findAvailablePort()\n        )\n    }\n\n    override fun configuration(): List&lt;String&gt; {\n        // Return configuration properties for the application\n        return options.configureExposedConfiguration(config)\n    }\n\n    override fun close() {}\n}\n\n// Configuration will be collected and passed to the application\nTestSystem()\n    .with {\n        myCustomSystem {\n            MySystemOptions(\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"my.service.host=${cfg.host}\",\n                        \"my.service.port=${cfg.port}\"\n                    )\n                }\n            )\n        }\n    }\n    .run()\n</code></pre>"},{"location":"writing-custom-systems/#extending-existing-systems","title":"Extending Existing Systems","text":"<p>Beyond creating entirely new systems, you can also extend existing Stove systems with custom DSL extensions. This is useful when you want to add domain-specific functionality to built-in systems like <code>HttpSystem</code>, <code>KafkaSystem</code>, etc.</p>"},{"location":"writing-custom-systems/#example-adding-graphql-support-to-httpsystem","title":"Example: Adding GraphQL Support to HttpSystem","text":"<p>Here's a complete example of extending <code>HttpSystem</code> with GraphQL query capabilities:</p>"},{"location":"writing-custom-systems/#step-1-define-response-types","title":"Step 1: Define Response Types","text":"<pre><code>import com.fasterxml.jackson.databind.JsonNode\n\n/**\n * Represents a GraphQL error from the response.\n */\ndata class GraphQLError(\n    val message: String,\n    val locations: List&lt;Map&lt;String, Int&gt;&gt;? = null,\n    val path: List&lt;Any?&gt;? = null,\n    val extensions: Map&lt;String, Any?&gt;? = null\n)\n\n/**\n * The standard GraphQL response envelope.\n */\ndata class GraphQLEnvelope(\n    val data: JsonNode?,\n    val errors: List&lt;GraphQLError&gt; = emptyList()\n)\n</code></pre>"},{"location":"writing-custom-systems/#step-2-create-extension-functions","title":"Step 2: Create Extension Functions","text":"<pre><code>import com.trendyol.stove.testing.e2e.http.HttpSystem\nimport com.trendyol.stove.testing.e2e.system.annotations.StoveDsl\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\n\n/**\n * Executes a GraphQL query/mutation and deserializes the response.\n *\n * @param operationName The name of the GraphQL operation (must match the query/mutation name)\n * @param body The complete GraphQL request body as JSON string\n * @param token Optional authorization token\n * @param assert Assertion function to validate the response\n */\n@StoveDsl\nsuspend inline fun &lt;reified T&gt; HttpSystem.graphql(\n    operationName: String,\n    body: String,\n    token: String? = null,\n    crossinline assert: (T) -&gt; Unit\n) {\n    val value: T = executeGraphQL(operationName, body, token)\n    assert(value)\n}\n\n/**\n * Executes a GraphQL query/mutation expecting it to fail with an error.\n *\n * @param body The complete GraphQL request body as JSON string\n * @param token Optional authorization token\n * @param assert Assertion function to validate the error\n */\n@StoveDsl\nsuspend fun HttpSystem.graphqlExpectingError(\n    body: String,\n    token: String? = null,\n    assert: (GraphQLError) -&gt; Unit\n) {\n    client { urlBuilder -&gt;\n        val url = urlBuilder.apply { appendPathSegments(\"graphql\") }.build().toString()\n\n        post(url) {\n            contentType(ContentType.Application.Json)\n            token?.let { headers { append(\"Authorization\", \"Bearer $it\") } }\n            setBody(body)\n        }.let { response -&gt;\n            if (response.status != HttpStatusCode.OK) {\n                throw AssertionError(\n                    \"GraphQL operation failed with HTTP error: ${response.status}\\n\" +\n                    \"Body:\\n${response.bodyAsText()}\"\n                )\n            }\n\n            val envelope = objectMapper.readValue(response.bodyAsText(), GraphQLEnvelope::class.java)\n\n            if (envelope.errors.isEmpty()) {\n                throw AssertionError(\n                    \"Expected GraphQL errors but got none. Data:\\n${envelope.data?.toPrettyString() ?: \"&lt;null&gt;\"}\"\n                )\n            }\n\n            assert(envelope.errors.first())\n        }\n    }\n}\n\n/**\n * Executes a GraphQL query/mutation with dynamic JSON navigation.\n */\n@StoveDsl\nsuspend fun HttpSystem.graphqlDynamic(\n    operationName: String,\n    body: String,\n    token: String? = null,\n    assert: (GraphQLNode) -&gt; Unit\n) {\n    val node = executeGraphQLInternal(operationName, body, token) { fieldNode -&gt; \n        GraphQLNode(fieldNode) \n    }\n    assert(node)\n}\n\nprivate suspend inline fun &lt;reified T&gt; HttpSystem.executeGraphQL(\n    operationName: String,\n    body: String,\n    token: String?\n): T = executeGraphQLInternal(operationName, body, token) { fieldNode -&gt;\n    objectMapper.readValue(fieldNode.toString(), T::class.java)\n}\n\nprivate suspend fun &lt;R&gt; HttpSystem.executeGraphQLInternal(\n    operationName: String,\n    body: String,\n    token: String?,\n    decode: (JsonNode) -&gt; R\n): R {\n    var result: R? = null\n\n    client { urlBuilder -&gt;\n        val url = urlBuilder.apply { appendPathSegments(\"graphql\") }.build().toString()\n\n        post(url) {\n            contentType(ContentType.Application.Json)\n            token?.let { headers { append(\"Authorization\", \"Bearer $it\") } }\n            setBody(body)\n        }.let { response -&gt;\n            if (response.status != HttpStatusCode.OK) {\n                throw AssertionError(\n                    \"GraphQL operation($operationName) failed: ${response.status}\\n\" +\n                    \"Body:\\n${response.bodyAsText()}\"\n                )\n            }\n\n            val envelope = objectMapper.readValue(response.bodyAsText(), GraphQLEnvelope::class.java)\n\n            if (envelope.errors.isNotEmpty()) {\n                val errorText = envelope.errors.joinToString(\"\\n\") { e -&gt;\n                    \"\u2022 ${e.message}\" + \n                    (e.path?.let { \" | path: $it\" } ?: \"\") +\n                    (e.extensions?.let { \" | ext: $it\" } ?: \"\")\n                }\n                throw AssertionError(\n                    \"GraphQL operation($operationName) returned errors:\\n$errorText\\n\\n\" +\n                    \"Data:\\n${envelope.data?.toPrettyString() ?: \"&lt;null&gt;\"}\"\n                )\n            }\n\n            val dataNode = envelope.data\n                ?: throw AssertionError(\n                    \"GraphQL operation($operationName) returned no 'data'. \" +\n                    \"Response:\\n${response.bodyAsText()}\"\n                )\n\n            val fieldNode = dataNode.get(operationName)\n                ?: throw AssertionError(\n                    \"GraphQL response has no field '$operationName'. \" +\n                    \"Available: ${dataNode.fieldNames().asSequence().toList()}\"\n                )\n\n            result = decode(fieldNode)\n        }\n    }\n\n    return result ?: throw AssertionError(\"GraphQL operation mapping failed\")\n}\n</code></pre>"},{"location":"writing-custom-systems/#step-3-create-dynamic-navigation-helper-optional","title":"Step 3: Create Dynamic Navigation Helper (Optional)","text":"<p>For flexible JSON navigation without strict typing:</p> <pre><code>import com.fasterxml.jackson.databind.JsonNode\nimport kotlin.reflect.KProperty1\n\n/**\n * A wrapper for dynamic GraphQL response navigation.\n */\n@JvmInline\nvalue class GraphQLNode(val node: JsonNode?) {\n\n    fun exists() = node != null &amp;&amp; !node.isNull\n\n    operator fun get(key: String): GraphQLNode {\n        val obj = node ?: error(\"Expected object but was &lt;null&gt;\")\n        if (!obj.isObject) error(\"Expected object to access key '$key' but was ${obj.nodeType}\")\n        return GraphQLNode(obj.get(key))\n    }\n\n    operator fun get(index: Int): GraphQLNode {\n        val arr = node ?: error(\"Expected array but was &lt;null&gt;\")\n        if (!arr.isArray) error(\"Expected array to access [$index] but was ${arr.nodeType}\")\n        return GraphQLNode(arr.get(index))\n    }\n\n    /**\n     * Navigate using dot notation: \"user.address.city\" or \"items[0].name\"\n     */\n    fun at(path: String): GraphQLNode {\n        var current = this\n        val tokens = parsePath(path)\n        for (token in tokens) {\n            current = when (token) {\n                is PathToken.Key -&gt; current[token.name]\n                is PathToken.Index -&gt; current[token.index]\n            }\n        }\n        return current\n    }\n\n    fun asNodes(): List&lt;GraphQLNode&gt; {\n        val arr = node ?: error(\"Expected array but was &lt;null&gt;\")\n        if (!arr.isArray) error(\"Expected array but was ${arr.nodeType}\")\n        return arr.map { GraphQLNode(it) }\n    }\n\n    inline fun &lt;reified T&gt; asType(): T {\n        val n = node ?: error(\"Value is &lt;null&gt;, expected ${T::class.simpleName}\")\n        return when (T::class) {\n            String::class -&gt; n.asText() as T\n            Int::class -&gt; n.asInt() as T\n            Long::class -&gt; n.asLong() as T\n            Boolean::class -&gt; n.asBoolean() as T\n            Double::class -&gt; n.asDouble() as T\n            else -&gt; objectMapper.convertValue(n, T::class.java)\n        }\n    }\n\n    fun string() = asType&lt;String&gt;()\n    fun int() = asType&lt;Int&gt;()\n    fun long() = asType&lt;Long&gt;()\n    fun bool() = asType&lt;Boolean&gt;()\n    fun double() = asType&lt;Double&gt;()\n    fun raw(): JsonNode? = node\n\n    private sealed interface PathToken {\n        data class Key(val name: String) : PathToken\n        data class Index(val index: Int) : PathToken\n    }\n\n    private fun parsePath(path: String): List&lt;PathToken&gt; {\n        if (path.isBlank()) return emptyList()\n        val tokens = mutableListOf&lt;PathToken&gt;()\n        var i = 0\n        val buffer = StringBuilder()\n\n        fun flushKey() {\n            if (buffer.isNotEmpty()) {\n                tokens += PathToken.Key(buffer.toString())\n                buffer.setLength(0)\n            }\n        }\n\n        while (i &lt; path.length) {\n            when (val c = path[i]) {\n                '.' -&gt; { flushKey(); i++ }\n                '[' -&gt; {\n                    flushKey()\n                    val end = path.indexOf(']', i + 1)\n                    val idx = path.substring(i + 1, end).toInt()\n                    tokens += PathToken.Index(idx)\n                    i = end + 1\n                }\n                else -&gt; { buffer.append(c); i++ }\n            }\n        }\n        flushKey()\n        return tokens\n    }\n}\n\n// Property-based access extensions\noperator fun &lt;T&gt; GraphQLNode.get(prop: KProperty1&lt;*, T&gt;): GraphQLNode = this[prop.name]\n\ninline fun &lt;reified T&gt; GraphQLNode.valueOf(prop: KProperty1&lt;*, T&gt;): T = this[prop].asType()\n\ninline fun &lt;reified T&gt; List&lt;GraphQLNode&gt;.findBy(prop: KProperty1&lt;*, T&gt;, value: T): GraphQLNode? =\n    firstOrNull { it.valueOf(prop) == value }\n\ninline fun &lt;reified T&gt; List&lt;GraphQLNode&gt;.requireBy(prop: KProperty1&lt;*, T&gt;, value: T): GraphQLNode =\n    findBy(prop, value) ?: error(\"No element where ${prop.name} == $value\")\n</code></pre>"},{"location":"writing-custom-systems/#step-4-use-in-tests","title":"Step 4: Use in Tests","text":"<pre><code>data class Product(\n    val id: String,\n    val name: String,\n    val price: Double,\n    val category: String\n)\n\ndata class User(\n    val id: String,\n    val name: String,\n    val email: String\n)\n\ntest(\"should query products by category\") {\n    TestSystem.validate {\n        http {\n            val query = \"\"\"\n                {\n                    \"query\": \"query { productsByCategory(category: \\\"ELECTRONICS\\\") { id name price category } }\"\n                }\n            \"\"\".trimIndent()\n\n            graphql&lt;List&lt;Product&gt;&gt;(\"productsByCategory\", query) { products -&gt;\n                products.shouldNotBeEmpty()\n                products.forEach { product -&gt;\n                    product.category shouldBe \"ELECTRONICS\"\n                }\n            }\n        }\n    }\n}\n\ntest(\"should query current user\") {\n    TestSystem.validate {\n        http {\n            val query = \"\"\"\n                {\n                    \"query\": \"query { me { id name email } }\"\n                }\n            \"\"\".trimIndent()\n\n            graphql&lt;User&gt;(\"me\", query, token = \"user-jwt-token\") { user -&gt;\n                user.id shouldNotBe null\n                user.email shouldContain \"@\"\n            }\n        }\n    }\n}\n\ntest(\"should handle GraphQL errors\") {\n    TestSystem.validate {\n        http {\n            val query = \"\"\"\n                {\n                    \"query\": \"query { invalidField }\"\n                }\n            \"\"\".trimIndent()\n\n            graphqlExpectingError(query) { error -&gt;\n                error.message shouldContain \"Cannot query field\"\n            }\n        }\n    }\n}\n\ntest(\"should navigate dynamic response\") {\n    TestSystem.validate {\n        http {\n            val query = \"\"\"\n                {\n                    \"query\": \"query { searchResults { items { id title metadata { tags } } totalCount } }\"\n                }\n            \"\"\".trimIndent()\n\n            graphqlDynamic(\"searchResults\", query) { result -&gt;\n                // Navigate using dot notation\n                result[\"totalCount\"].int() shouldBeGreaterThan 0\n\n                // Navigate arrays\n                val items = result[\"items\"].asNodes()\n                items.shouldNotBeEmpty()\n\n                // Access nested fields\n                val firstItem = result.at(\"items[0]\")\n                firstItem[\"title\"].string() shouldNotBe null\n\n                // Property-based navigation\n                val found = items.findBy(Product::id, \"expected-id\")\n                found shouldNotBe null\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"writing-custom-systems/#benefits-of-extending-existing-systems","title":"Benefits of Extending Existing Systems","text":"<ol> <li>Reuse existing infrastructure - No need to create a full system class</li> <li>Domain-specific DSL - Create readable, expressive test code</li> <li>Type safety - Leverage Kotlin's type system for assertions</li> <li>Composability - Combine with other Stove systems seamlessly</li> </ol>"},{"location":"writing-custom-systems/#other-extension-ideas","title":"Other Extension Ideas","text":"<p>You can apply this pattern to extend any Stove system:</p> <pre><code>// Kafka: Custom message publishing with headers\n@StoveDsl\nsuspend fun KafkaSystem.publishWithCorrelationId(\n    topic: String,\n    message: Any,\n    correlationId: String = UUID.randomUUID().toString()\n) {\n    publish(\n        topic = topic,\n        message = message,\n        headers = mapOf(\"X-Correlation-ID\" to correlationId)\n    )\n}\n\n// Couchbase: Query with retry logic\n@StoveDsl\nsuspend inline fun &lt;reified T&gt; CouchbaseSystem.shouldQueryWithRetry(\n    query: String,\n    maxRetries: Int = 3,\n    crossinline assertion: (List&lt;T&gt;) -&gt; Unit\n) {\n    var lastException: Exception? = null\n    repeat(maxRetries) {\n        try {\n            shouldQuery&lt;T&gt;(query, assertion)\n            return\n        } catch (e: Exception) {\n            lastException = e\n            delay(500)\n        }\n    }\n    throw lastException ?: AssertionError(\"Query failed after $maxRetries retries\")\n}\n\n// PostgreSQL: Insert test data helper\n@StoveDsl\nsuspend fun PostgresqlSystem.insertTestUser(\n    id: String = UUID.randomUUID().toString(),\n    name: String = \"Test User\",\n    email: String = \"test-${UUID.randomUUID()}@example.com\"\n): String {\n    shouldExecute(\n        \"\"\"\n        INSERT INTO users (id, name, email) \n        VALUES ('$id', '$name', '$email')\n        \"\"\".trimIndent()\n    )\n    return id\n}\n</code></pre>"},{"location":"writing-custom-systems/#best-practices-for-custom-systems","title":"Best Practices for Custom Systems","text":""},{"location":"writing-custom-systems/#1-use-concurrent-data-structures","title":"1. Use Concurrent Data Structures","text":"<p>When capturing data from multiple threads:</p> <pre><code>private val events = ConcurrentLinkedQueue&lt;Event&gt;()\nprivate val executionMap = ConcurrentHashMap&lt;String, Execution&gt;()\n</code></pre>"},{"location":"writing-custom-systems/#2-handle-timeouts-gracefully","title":"2. Handle Timeouts Gracefully","text":"<p>Provide meaningful error messages:</p> <pre><code>suspend fun &lt;T&gt; waitFor(\n    duration: Duration,\n    description: String,\n    condition: () -&gt; T?\n): T = withTimeout(duration) {\n    while (true) {\n        condition()?.let { return@withTimeout it }\n        delay(50)\n    }\n    throw AssertionError(\"Timeout waiting for: $description\")\n}\n</code></pre>"},{"location":"writing-custom-systems/#3-make-systems-chainable","title":"3. Make Systems Chainable","text":"<p>Return <code>this</code> for fluent API:</p> <pre><code>fun doSomething(): MySystem {\n    // operation\n    return this\n}\n\n// Allows chaining\nmySystem {\n    doSomething()\n        .doSomethingElse()\n        .verify { ... }\n}\n</code></pre>"},{"location":"writing-custom-systems/#4-annotate-dsl-functions","title":"4. Annotate DSL Functions","text":"<p>Use <code>@StoveDsl</code> for IDE support:</p> <pre><code>@StoveDsl\nsuspend fun ValidationDsl.mySystem(\n    validation: suspend MySystem.() -&gt; Unit\n): Unit = validation(this.testSystem.mySystem())\n</code></pre>"},{"location":"writing-custom-systems/#5-document-your-system","title":"5. Document Your System","text":"<p>Provide clear KDoc comments:</p> <pre><code>/**\n * System for testing scheduled task execution.\n *\n * Example usage:\n * ```kotlin\n * tasks {\n *     shouldBeExecuted&lt;MyTask&gt;(atLeastIn = 10.seconds) {\n *         status == \"COMPLETED\"\n *     }\n * }\n * ```\n */\nclass DbSchedulerSystem(...)\n</code></pre>"},{"location":"writing-custom-systems/#summary","title":"Summary","text":"<p>Stove offers two powerful ways to extend its functionality:</p>"},{"location":"writing-custom-systems/#creating-new-systems","title":"Creating New Systems","text":"<p>For integrating with components not covered by built-in systems:</p> <ol> <li>Create a listener/component that captures the behavior you want to test</li> <li>Create a System class implementing <code>PluggedSystem</code> and appropriate lifecycle interfaces</li> <li>Create DSL extensions for <code>WithDsl</code> and <code>ValidationDsl</code></li> <li>Register beans in your test initializer</li> <li>Use in tests with the fluent DSL</li> </ol>"},{"location":"writing-custom-systems/#extending-existing-systems_1","title":"Extending Existing Systems","text":"<p>For adding domain-specific functionality to built-in systems:</p> <ol> <li>Create extension functions on existing system classes (e.g., <code>HttpSystem</code>, <code>KafkaSystem</code>)</li> <li>Use <code>@StoveDsl</code> annotation for IDE support</li> <li>Leverage existing infrastructure without creating new system classes</li> <li>Compose with other systems seamlessly</li> </ol> <p>Both approaches make Stove adaptable to virtually any testing scenario in your application, whether you need to integrate with external components like db-scheduler, capture domain events, add GraphQL support, or create custom assertion helpers.</p>"},{"location":"Components/","title":"Components","text":"<p>Stove provides a pluggable architecture where each physical dependency is a separate module that you can add based on your testing needs. All components are designed to work seamlessly together, allowing you to compose your test environment exactly as your production setup requires.</p>"},{"location":"Components/#available-components","title":"Available Components","text":"Component Module Description Kafka <code>stove-testing-e2e-kafka</code> Message broker for event-driven architectures Couchbase <code>stove-testing-e2e-couchbase</code> NoSQL document database Elasticsearch <code>stove-testing-e2e-elasticsearch</code> Search and analytics engine PostgreSQL <code>stove-testing-e2e-rdbms-postgres</code> Relational database MongoDB <code>stove-testing-e2e-mongodb</code> NoSQL document database MSSQL <code>stove-testing-e2e-rdbms-mssql</code> Microsoft SQL Server Redis <code>stove-testing-e2e-redis</code> In-memory data store WireMock <code>stove-testing-e2e-wiremock</code> HTTP mock server for external services HTTP Client <code>stove-testing-e2e-http</code> HTTP client for testing your API Bridge Built-in Access to application's DI container"},{"location":"Components/#quick-start","title":"Quick Start","text":"<p>Add the components you need to your <code>build.gradle.kts</code>:</p> Gradle <pre><code>dependencies {\n    // Core testing framework\n    testImplementation(\"com.trendyol:stove-testing-e2e:$version\")\n\n    // Application framework support\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n    // or\n    testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$version\")\n\n    // Add components based on your needs\n    testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-couchbase:$version\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-elasticsearch:$version\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n    testImplementation(\"com.trendyol:stove-testing-e2e-wiremock:$version\")\n    // ... add more as needed\n}\n</code></pre>"},{"location":"Components/#architecture-overview","title":"Architecture Overview","text":"<p>Each component follows a consistent pattern:</p> <ol> <li>Configuration - Define how the component should be set up</li> <li>Container/Runtime - Manages the testcontainer or provided instance</li> <li>DSL - Fluent API for test assertions</li> <li>Cleanup - Automatic resource management</li> </ol> <pre><code>TestSystem()\n  .with {\n    // Each component is configured in the `with` block\n    kafka { KafkaSystemOptions(...) }\n    couchbase { CouchbaseSystemOptions(...) }\n    http { HttpClientSystemOptions(...) }\n    wiremock { WireMockSystemOptions(...) }\n\n    // Application under test\n    springBoot(runner = { params -&gt; myApp.run(params) })\n  }\n  .run() // Starts all components and the application\n\n// Test your application\nTestSystem.validate {\n  http { /* HTTP assertions */ }\n  kafka { /* Kafka assertions */ }\n  couchbase { /* Database assertions */ }\n}\n</code></pre>"},{"location":"Components/#component-categories","title":"Component Categories","text":""},{"location":"Components/#databases","title":"Databases","text":"Type Components Use Case Document Couchbase, MongoDB, Elasticsearch JSON document storage, search Relational PostgreSQL, MSSQL Structured data, transactions Key-Value Redis Caching, sessions, pub/sub"},{"location":"Components/#messaging","title":"Messaging","text":"Component Use Case Kafka Event streaming, message queues, pub/sub"},{"location":"Components/#network","title":"Network","text":"Component Use Case HTTP Client Testing your application's REST API WireMock Mocking external HTTP services"},{"location":"Components/#application-integration","title":"Application Integration","text":"Component Use Case Bridge Access application beans and services directly"},{"location":"Components/#common-configuration-pattern","title":"Common Configuration Pattern","text":"<p>All components follow a similar configuration pattern:</p> <pre><code>componentName {\n  ComponentSystemOptions(\n    // Container configuration\n    container = ContainerOptions(\n      registry = \"docker.io\",\n      image = \"component-image\",\n      tag = \"version\"\n    ),\n\n    // Expose configuration to your application\n    configureExposedConfiguration = { cfg -&gt;\n      listOf(\n        \"app.component.host=${cfg.host}\",\n        \"app.component.port=${cfg.port}\"\n      )\n    }\n  )\n}\n</code></pre>"},{"location":"Components/#testcontainer-vs-provided-instance","title":"Testcontainer vs Provided Instance","text":"<p>Each component supports two modes:</p>"},{"location":"Components/#container-mode-default","title":"Container Mode (Default)","text":"<p>Stove automatically manages testcontainers:</p> <pre><code>kafka {\n  KafkaSystemOptions(\n    container = KafkaContainerOptions(tag = \"latest\"),\n    configureExposedConfiguration = { cfg -&gt; listOf(...) }\n  )\n}\n</code></pre>"},{"location":"Components/#provided-instance-mode","title":"Provided Instance Mode","text":"<p>Connect to existing infrastructure (useful for CI/CD):</p> <pre><code>kafka {\n  KafkaSystemOptions.provided(\n    bootstrapServers = \"localhost:9092\",\n    configureExposedConfiguration = { cfg -&gt; \n      listOf(\"kafka.bootstrapServers=${cfg.bootstrapServers}\")\n    }\n  )\n}\n</code></pre> <p>See Provided Instances for detailed documentation.</p>"},{"location":"Components/#migrations-support","title":"Migrations Support","text":"<p>Database components support migrations:</p> <pre><code>class CreateTableseMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: PostgresSqlMigrationContext) {\n    connection.operations.execute(\"CREATE TABLE ...\")\n  }\n}\n\npostgresql {\n  PostgresqlOptions(...).migrations {\n    register&lt;CreateTablesMigration&gt;()\n  }\n}\n</code></pre>"},{"location":"Components/#cleanup-support","title":"Cleanup Support","text":"<p>All components support cleanup functions for data isolation:</p> <pre><code>couchbase(\n  cleanup = { cluster -&gt;\n    cluster.query(\"DELETE FROM `bucket` WHERE type = 'test'\")\n  }\n) {\n  CouchbaseSystemOptions(...)\n}\n</code></pre>"},{"location":"Components/#best-practices","title":"Best Practices","text":"<ol> <li>Use random data - Generate unique identifiers for each test to avoid conflicts</li> <li>Leverage cleanup functions - Clean test data between runs</li> <li>Configure timeouts appropriately - Set realistic timeouts for your environment</li> <li>Use the DSL consistently - Leverage the fluent API for readable tests</li> <li>Combine components - Test complete workflows across multiple systems</li> </ol>"},{"location":"Components/#example-full-stack-test","title":"Example: Full Stack Test","text":"<pre><code>test(\"should process order end-to-end\") {\n  TestSystem.validate {\n    val orderId = UUID.randomUUID().toString()\n\n    // Mock payment service\n    wiremock {\n      mockPost(\"/payments\", statusCode = 200, responseBody = PaymentResult(success = true).some())\n    }\n\n    // Create order via API\n    http {\n      postAndExpectBody&lt;OrderResponse&gt;(\"/orders\", body = CreateOrderRequest(orderId).some()) { \n        it.status shouldBe 201 \n      }\n    }\n\n    // Verify stored in database\n    couchbase {\n      shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n        order.status shouldBe \"CREATED\"\n      }\n    }\n\n    // Verify event published\n    kafka {\n      shouldBePublished&lt;OrderCreatedEvent&gt; { actual.orderId == orderId }\n    }\n\n    // Verify indexed for search\n    elasticsearch {\n      shouldGet&lt;Order&gt;(index = \"orders\", key = orderId) { it.status shouldBe \"CREATED\" }\n    }\n\n    // Verify cached\n    redis {\n      client().connect().sync().get(\"order:$orderId\") shouldNotBe null\n    }\n  }\n}\n</code></pre>"},{"location":"Components/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>Couchbase - NoSQL document database with N1QL queries</li> <li>Kafka - Message streaming with producer/consumer testing</li> <li>Elasticsearch - Search engine with query DSL support</li> <li>WireMock - Mock external HTTP dependencies</li> <li>HTTP Client - Test your REST API endpoints</li> <li>PostgreSQL - Relational database with SQL support</li> <li>MongoDB - Document database with aggregation support</li> <li>MSSQL - Microsoft SQL Server support</li> <li>Redis - In-memory data store for caching</li> <li>Bridge - Direct access to application beans</li> <li>Provided Instances - Use external infrastructure</li> </ul>"},{"location":"Components/01-couchbase/","title":"Couchbase","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-couchbase:$version\")\n    }\n</code></pre>"},{"location":"Components/01-couchbase/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>couchbase</code> function. This function configures the Couchbase Docker container that is going to be started.</p> <p>Here you can define a <code>defaultBucket</code> name.</p> <p>Warning</p> <p>Make sure that your application has the same bucket names.</p> <pre><code>TestSystem()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(defaultBucket = \"test-bucket\", configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      })\n    }\n  }\n  .run()\n</code></pre> <p>Stove exposes configuration that is generated by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. Your application will start with the physical dependencies that are spun-up by the framework.</p>"},{"location":"Components/01-couchbase/#migrations","title":"Migrations","text":"<p>Stove provides a way to run migrations before the test starts.</p> <pre><code>class CouchbaseMigration : DatabaseMigration&lt;Cluster&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: Cluster) {\n    val bucket = connection.bucket(CollectionConstants.BUCKET_NAME)\n    listOf(CollectionConstants.PRODUCT_COLLECTION).forEach { collection -&gt;\n      bucket.collections.createCollection(bucket.defaultScope().name, collection)\n    }\n    connection.waitUntilReady(30.seconds)\n  }\n}\n</code></pre> <p>You can define your migration class by implementing the <code>DatabaseMigration</code> interface. You can define the order of the migration by overriding the <code>order</code> property. The migrations will be executed in the order of the <code>order</code> property.</p> <p>After defining your migration class, you can pass it to the <code>migrations</code> function of the <code>couchbase</code> configuration.</p> <pre><code>TestSystem()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(defaultBucket = \"test-bucket\", configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      }).migrations {\n        register&lt;CouchbaseMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/01-couchbase/#usage","title":"Usage","text":""},{"location":"Components/01-couchbase/#saving-documents","title":"Saving Documents","text":"<p>Save documents to Couchbase collections:</p> <pre><code>TestSystem.validate {\n  couchbase {\n    // Save to default collection (_default)\n    saveToDefaultCollection(\n      id = \"user:123\",\n      instance = User(id = \"123\", name = \"John Doe\", email = \"john@example.com\")\n    )\n\n    // Save to a specific collection\n    save(\n      collection = \"products\",\n      id = \"product:456\",\n      instance = Product(id = \"456\", name = \"Laptop\", price = 999.99)\n    )\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#getting-documents","title":"Getting Documents","text":"<p>Retrieve and validate documents:</p> <pre><code>TestSystem.validate {\n  couchbase {\n    // Get from default collection\n    shouldGet&lt;User&gt;(\"user:123\") { user -&gt;\n      user.id shouldBe \"123\"\n      user.name shouldBe \"John Doe\"\n      user.email shouldBe \"john@example.com\"\n    }\n\n    // Get from specific collection\n    shouldGet&lt;Product&gt;(\"products\", \"product:456\") { product -&gt;\n      product.id shouldBe \"456\"\n      product.name shouldBe \"Laptop\"\n      product.price shouldBe 999.99\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#checking-non-existence","title":"Checking Non-Existence","text":"<p>Verify that documents don't exist:</p> <pre><code>TestSystem.validate {\n  couchbase {\n    // Check default collection\n    shouldNotExist(\"user:999\")\n\n    // Check specific collection\n    shouldNotExist(\"products\", \"product:999\")\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#deleting-documents","title":"Deleting Documents","text":"<p>Delete documents and verify deletion:</p> <pre><code>TestSystem.validate {\n  couchbase {\n    // Delete from default collection\n    shouldDelete(\"user:123\")\n    shouldNotExist(\"user:123\")\n\n    // Delete from specific collection\n    shouldDelete(\"products\", \"product:456\")\n    shouldNotExist(\"products\", \"product:456\")\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#n1ql-queries","title":"N1QL Queries","text":"<p>Execute N1QL queries and validate results:</p> <pre><code>TestSystem.validate {\n  couchbase {\n    // Simple query\n    shouldQuery&lt;User&gt;(\"SELECT u.* FROM `users` u WHERE u.age &gt; 18\") { users -&gt;\n      users.size shouldBeGreaterThan 0\n      users.all { it.age &gt; 18 } shouldBe true\n    }\n\n    // Query with multiple conditions\n    shouldQuery&lt;Product&gt;(\n      \"\"\"\n      SELECT p.* \n      FROM `products` p \n      WHERE p.price &gt; 100 AND p.category = 'Electronics'\n      \"\"\".trimIndent()\n    ) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.price &gt; 100 &amp;&amp; it.category == \"Electronics\" } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#working-with-collections-and-scopes","title":"Working with Collections and Scopes","text":"<p>Access bucket, collection, and cluster directly:</p> <pre><code>TestSystem.validate {\n  couchbase {\n    // Access the cluster\n    val cluster = cluster()\n\n    // Access the bucket\n    val bucket = bucket()\n\n    // Perform custom operations\n    val customResult = bucket.collections.getAllScopes()\n    customResult shouldNotBe null\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Control the Couchbase container for testing failure scenarios:</p> <pre><code>TestSystem.validate {\n  couchbase {\n    // Pause the container\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the container\n    unpause()\n\n    // Verify recovery\n    shouldGet&lt;User&gt;(\"user:123\") { user -&gt;\n      user.id shouldBe \"123\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, Couchbase, and Kafka:</p> <pre><code>test(\"should create product and store in couchbase\") {\n  TestSystem.validate {\n    val productId = UUID.randomUUID().toString()\n    val productName = \"Gaming Laptop\"\n    val categoryId = 1\n\n    // Mock external service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Create product via API\n    http {\n      postAndExpectBody&lt;Any&gt;(\n        uri = \"/products\",\n        body = ProductCreateRequest(\n          name = productName,\n          price = 1299.99,\n          categoryId = categoryId\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify stored in Couchbase\n    couchbase {\n      shouldGet&lt;Product&gt;(\"products\", \"product:$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe productName\n        product.price shouldBe 1299.99\n        product.categoryId shouldBe categoryId\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName &amp;&amp;\n        actual.price == 1299.99\n      }\n    }\n\n    // Query products by category\n    couchbase {\n      shouldQuery&lt;Product&gt;(\n        \"\"\"\n        SELECT p.* \n        FROM `products` p \n        WHERE p.categoryId = $categoryId\n        \"\"\".trimIndent()\n      ) { products -&gt;\n        products.size shouldBeGreaterThan 0\n        products.any { it.id == productId } shouldBe true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#integration-with-application","title":"Integration with Application","text":"<p>Verify application behavior using the bridge:</p> <pre><code>test(\"should use repository to save product\") {\n  TestSystem.validate {\n    val productId = UUID.randomUUID().toString()\n    val product = Product(id = productId, name = \"Test Product\", price = 99.99)\n\n    // Use application's repository\n    using&lt;ProductRepository&gt; {\n      save(product)\n    }\n\n    // Verify in Couchbase\n    couchbase {\n      shouldGet&lt;Product&gt;(\"products\", \"product:$productId\") { savedProduct -&gt;\n        savedProduct.id shouldBe productId\n        savedProduct.name shouldBe \"Test Product\"\n        savedProduct.price shouldBe 99.99\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#advanced-operations","title":"Advanced Operations","text":""},{"location":"Components/01-couchbase/#batch-operations","title":"Batch Operations","text":"<pre><code>TestSystem.validate {\n  couchbase {\n    // Save multiple documents\n    val users = listOf(\n      User(id = \"1\", name = \"Alice\"),\n      User(id = \"2\", name = \"Bob\"),\n      User(id = \"3\", name = \"Charlie\")\n    )\n\n    users.forEach { user -&gt;\n      saveToDefaultCollection(\"user:${user.id}\", user)\n    }\n\n    // Query all\n    shouldQuery&lt;User&gt;(\"SELECT u.* FROM `${bucket().name}` u\") { result -&gt;\n      result.size shouldBeGreaterThanOrEqual users.size\n    }\n\n    // Verify each\n    users.forEach { user -&gt;\n      shouldGet&lt;User&gt;(\"user:${user.id}\") { actual -&gt;\n        actual.name shouldBe user.name\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/01-couchbase/#error-handling","title":"Error Handling","text":"<pre><code>TestSystem.validate {\n  couchbase {\n    // Document not found\n    shouldNotExist(\"non-existent:key\")\n\n    // Attempting to delete non-existent document throws exception\n    assertThrows&lt;DocumentNotFoundException&gt; {\n      shouldDelete(\"non-existent:key\")\n    }\n\n    // Attempting to assert non-existence on existing document throws assertion error\n    saveToDefaultCollection(\"user:123\", User(id = \"123\", name = \"John\"))\n    assertThrows&lt;AssertionError&gt; {\n      shouldNotExist(\"user:123\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/","title":"Kafka","text":"<p>There are two ways to work with Kafka in Stove. You can use standalone Kafka or Kafka with Spring. You can use only one of them in your project.</p>"},{"location":"Components/02-kafka/#standalone-kafka","title":"Standalone Kafka","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n    }\n</code></pre>"},{"location":"Components/02-kafka/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    // other dependencies\n\n    kafka {\n      stoveKafkaObjectMapperRef = objectMapperRef\n      KafkaSystemOptions {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\"\n        )\n      }\n    }\n  }.run()\n</code></pre> <p>The configuration values are:</p> <pre><code>class KafkaSystemOptions(\n  /**\n   * Suffixes for error and retry topics in the application.\n   */\n  val topicSuffixes: TopicSuffixes = TopicSuffixes(),\n  /**\n   * If true, the system will listen to the messages published by the Kafka system.\n   */\n  val listenPublishedMessagesFromStove: Boolean = false,\n  /**\n   * The port of the bridge gRPC server that is used to communicate with the Kafka system.\n   */\n  val bridgeGrpcServerPort: Int = stoveKafkaBridgePortDefault.toInt(),\n  /**\n   * The Serde that is used while asserting the messages,\n   * serializing while bridging the messages. Take a look at the [serde] property for more information.\n   *\n   * The default value is [StoveSerde.jackson]'s anyByteArraySerde.\n   * Depending on your application's needs you might want to change this value.\n   *\n   * The places where it was used listed below:\n   *\n   * @see [com.trendyol.stove.testing.e2e.standalone.kafka.intercepting.StoveKafkaBridge] for bridging the messages.\n   * @see StoveKafkaValueSerializer for serializing the messages.\n   * @see StoveKafkaValueDeserializer for deserializing the messages.\n   * @see valueSerializer for serializing the messages.\n   */\n  val serde: StoveSerde&lt;Any, ByteArray&gt; = stoveSerdeRef,\n  /**\n   * The Value serializer that is used to serialize messages.\n   */\n  val valueSerializer: Serializer&lt;Any&gt; = StoveKafkaValueSerializer(),\n  /**\n   * The options for the Kafka container.\n   */\n  val containerOptions: KafkaContainerOptions = KafkaContainerOptions(),\n  /**\n   * The options for the Kafka system that is exposed to the application\n   */\n  override val configureExposedConfiguration: (KafkaExposedConfiguration) -&gt; List&lt;String&gt;\n) : SystemOptions, ConfiguresExposedConfiguration&lt;KafkaExposedConfiguration&gt;\n</code></pre>"},{"location":"Components/02-kafka/#configuring-serializer-and-deserializer","title":"Configuring Serializer and Deserializer","text":"<p>Like every <code>SystemOptions</code> object, <code>KafkaSystemOptions</code> has a <code>serde</code> property that you can configure. It is a <code>StoveSerde</code> object that has two functions <code>serialize</code> and <code>deserialize</code>. You can configure them depending on your application's needs.</p> <pre><code>val kafkaSystemOptions = KafkaSystemOptions(\n  serde = object : StoveSerde&lt;Any, ByteArray&gt; {\n    override fun serialize(value: Any): ByteArray {\n      return objectMapper.writeValueAsBytes(value)\n    }\n\n    override fun &lt;T&gt; deserialize(value: ByteArray): T {\n      return objectMapper.readValue(value, Any::class.java) as T\n    }\n  }\n)\n</code></pre>"},{"location":"Components/02-kafka/#kafka-bridge-with-your-application","title":"Kafka Bridge With Your Application","text":"<p>Stove Kafka bridge is a MUST to work with Kafka. Otherwise you can't assert any messages from your application.</p> <p>As you can see in the example above, you need to add a support to your application to work with interceptor that Stove provides.</p> <pre><code> \"kafka.interceptorClasses=com.trendyol.stove.testing.e2e.standalone.kafka.intercepting.StoveKafkaBridge\"\n\n// or\n\n\"kafka.interceptorClasses={cfg.interceptorClass}\" // cfg.interceptorClass is exposed by Stove\n</code></pre> <p>Important</p> <p><code>kafka.</code> prefix or <code>interceptorClasses</code> are assumptions that you can change it with your own prefix or configuration.</p>"},{"location":"Components/02-kafka/#spring-kafka","title":"Spring Kafka","text":"<p>When you want to use Kafka with Application Aware testing it provides more assertion capabilities. It is recommended way of working. Stove-Kafka does that with intercepting the messages.</p>"},{"location":"Components/02-kafka/#how-to-get","title":"How to get?","text":"GradleMaven <pre><code>    dependencies {\n      testImplementation(\"com.trendyol:stove-spring-testing-e2e-kafka:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-spring-testing-e2e-kafka&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"Components/02-kafka/#configure_1","title":"Configure","text":""},{"location":"Components/02-kafka/#configuration-values","title":"Configuration Values","text":"<p>Kafka works with some settings as default, your application might have these values as not configurable, to make the application testable we need to tweak a little bit.</p> <p>If you have the following configurations:</p> <ul> <li><code>AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" | should be \"earliest\"</code></li> <li><code>ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" | should be true</code></li> <li><code>HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" | should be 2 seconds</code></li> </ul> <p>You better make them configurable, so from the e2e testing context we can change them work with Stove-Kafka testing.</p> <p>As an example:</p> <pre><code>TestSystem()\n  .with {\n    httpClient {\n      HttpClientSystemOptions(baseUrl = \"http://localhost:8080\")\n    }\n    kafka {\n      KafkaSystemOptions {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\"\n        )\n      }\n    }\n    springBoot(\n      runner = { parameters -&gt;\n        com.trendyol.exampleapp.run(parameters)\n      },\n      withParameters = listOf(\n        \"logging.level.root=error\",\n        \"logging.level.org.springframework.web=error\",\n        \"spring.profiles.active=default\",\n        \"server.http2.enabled=false\",\n        \"kafka.heartbeatInSeconds=2\",\n        \"kafka.autoCreateTopics=true\",\n        \"kafka.offset=earliest\"\n      )\n    )\n  }.run()\n</code></pre> <p>As you can see, we pass these configuration values as parameters. Since they are configurable, the application considers these values instead of application-default values.</p>"},{"location":"Components/02-kafka/#consumer-settings","title":"Consumer Settings","text":"<p>Second thing we need to do is tweak your consumer configuration. For that we will provide Stove-Kafka interceptor to your Kafka configuration.</p> <p>Locate to the point where you define your <code>ConcurrentKafkaListenerContainerFactory</code> or where you can set the interceptor. Interceptor needs to implement <code>ConsumerAwareRecordInterceptor&lt;String, String&gt;</code> since Stove-Kafka relies on that.</p> <pre><code>@EnableKafka\n@Configuration\nclass KafkaConsumerConfiguration(\n  private val interceptor: ConsumerAwareRecordInterceptor&lt;String, String&gt;,\n) {\n\n  @Bean\n  fun kafkaListenerContainerFactory(): ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; {\n    val factory = ConcurrentKafkaListenerContainerFactory&lt;String, String&gt;()\n    // ...\n    factory.setRecordInterceptor(interceptor)\n    return factory\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#producer-settings","title":"Producer Settings","text":"<p>Make sure that the aforementioned values are also configurable for producer settings, too. Stove will have access to <code>KafkaTemplate</code> and will use <code>setProducerListener</code> to arrange itself to listen produced messages.</p>"},{"location":"Components/02-kafka/#plugging-in","title":"Plugging in","text":"<p>When all the configuration is done, it is time to tell to application to use our <code>TestSystemInterceptor</code> and configuration values.</p>"},{"location":"Components/02-kafka/#testsysteminterceptor-and-testinitializer","title":"TestSystemInterceptor and TestInitializer","text":"<pre><code>class TestInitializer : BaseApplicationContextInitializer({\n  bean&lt;TestSystemInterceptor&gt;(isPrimary = true)\n  bean { StoveSerde.jackson.anyByteArraySerde(yourObjectMapper()) } // or any serde that implements StoveSerde&lt;Any, ByteArray&gt;\n})\n\nfun SpringApplication.addTestDependencies() {\n  this.addInitializers(TestInitializer())\n}\n</code></pre>"},{"location":"Components/02-kafka/#configuring-the-systemundertest-and-parameters","title":"Configuring the SystemUnderTest and Parameters","text":"<p><code>addTestDependencies</code> is an extension that helps us to register our dependencies in the application.</p> <pre><code>springBoot(\n  runner = { parameters -&gt;\n    com.trendyol.exampleapp.run(parameters) {\n      addTestDependencies() // Enable TestInitializer with extensions call\n    }\n  },\n  withParameters = listOf(\n    \"logging.level.root=error\",\n    \"logging.level.org.springframework.web=error\",\n    \"spring.profiles.active=default\",\n    \"server.http2.enabled=false\",\n    \"kafka.heartbeatInSeconds=2\", // Added Parameter\n    \"kafka.autoCreateTopics=true\", // Added Parameter\n    \"kafka.offset=earliest\" // Added Parameter\n  )\n)\n</code></pre> <p>Now you're full set and have control over Kafka messages from the testing context.</p>"},{"location":"Components/02-kafka/#testing","title":"Testing","text":""},{"location":"Components/02-kafka/#publishing-messages","title":"Publishing Messages","text":"<p>You can publish messages to Kafka topics for testing:</p> <pre><code>TestSystem.validate {\n  kafka {\n    publish(\n      topic = \"product-events\",\n      message = ProductCreated(id = \"123\", name = \"T-Shirt\"),\n      key = \"product-123\".some(), // Optional\n      headers = mapOf(\"X-UserEmail\" to \"user@example.com\"), // Optional\n      partition = 0 // Optional\n    )\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#asserting-published-messages","title":"Asserting Published Messages","text":"<p>Test that your application publishes messages correctly:</p> <pre><code>TestSystem.validate {\n  // Trigger an action in your application\n  http {\n    postAndExpectBodilessResponse(\"/products\", body = CreateProductRequest(name = \"Laptop\").some()) { response -&gt;\n      response.status shouldBe 200\n    }\n  }\n\n  // Verify the message was published\n  kafka {\n    shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n      actual.name == \"Laptop\" &amp;&amp;\n      actual.id != null &amp;&amp;\n      metadata.topic == \"product-events\" &amp;&amp;\n      metadata.headers[\"event-type\"] == \"PRODUCT_CREATED\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#asserting-consumed-messages","title":"Asserting Consumed Messages","text":"<p>Test that your application consumes messages correctly:</p> <pre><code>TestSystem.validate {\n  // Publish a message\n  kafka {\n    publish(\n      topic = \"order-events\",\n      message = OrderCreated(orderId = \"456\", amount = 100.0)\n    )\n  }\n\n  // Verify your application consumed and processed it\n  kafka {\n    shouldBeConsumed&lt;OrderCreated&gt;(atLeastIn = 20.seconds) {\n      actual.orderId == \"456\" &amp;&amp;\n      actual.amount == 100.0\n    }\n  }\n\n  // Verify side effects (e.g., database write)\n  couchbase {\n    shouldGet&lt;Order&gt;(\"order:456\") { order -&gt;\n      order.orderId shouldBe \"456\"\n      order.status shouldBe \"CREATED\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#testing-failed-messages","title":"Testing Failed Messages","text":"<p>Test that your application handles failures correctly:</p> <pre><code>TestSystem.validate {\n  kafka {\n    // Publish an invalid message\n    publish(\"user-events\", FailingEvent(id = 5L))\n\n    // Verify it failed with the expected reason\n    shouldBeFailed&lt;FailingEvent&gt;(atLeastIn = 10.seconds) {\n      actual.id == 5L &amp;&amp;\n      reason is BusinessException\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#testing-retry-logic","title":"Testing Retry Logic","text":"<p>Test that your application retries failed messages:</p> <pre><code>TestSystem.validate {\n  kafka {\n    publish(\"product-failing\", ProductFailingCreated(productId = \"789\"))\n\n    // Verify it was retried 3 times\n    shouldBeRetried&lt;ProductFailingCreated&gt;(atLeastIn = 1.minutes, times = 3) {\n      actual.productId == \"789\"\n    }\n\n    // Verify it ended up in error topic\n    shouldBePublished&lt;ProductFailingCreated&gt;(atLeastIn = 1.minutes) {\n      metadata.topic == \"product-failing.error\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#working-with-message-metadata","title":"Working with Message Metadata","text":"<p>Access message metadata including headers, topic, partition, offset:</p> <pre><code>TestSystem.validate {\n  kafka {\n    shouldBeConsumed&lt;OrderCreated&gt; {\n      actual.orderId == \"123\" &amp;&amp;\n      metadata.topic == \"order-events\" &amp;&amp;\n      metadata.headers[\"correlation-id\"] != null &amp;&amp;\n      metadata.partition == 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#peeking-messages","title":"Peeking Messages","text":"<p>Inspect messages without consuming them:</p> <pre><code>TestSystem.validate {\n  kafka {\n    // Peek at published messages\n    peekPublishedMessages(atLeastIn = 5.seconds, topic = \"product-events\") { record -&gt;\n      record.key == \"product-123\"\n    }\n\n    // Peek at consumed messages\n    peekConsumedMessages(atLeastIn = 5.seconds, topic = \"order-events\") { record -&gt;\n      record.offset &gt;= 10L\n    }\n\n    // Peek at committed messages\n    peekCommittedMessages(topic = \"order-events\") { record -&gt;\n      record.offset == 101L // next offset after 100 messages\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#admin-operations","title":"Admin Operations","text":"<p>Manage Kafka topics and configurations:</p> <pre><code>TestSystem.validate {\n  kafka {\n    adminOperations {\n      createTopic(NewTopic(\"test-topic\", 1, 1))\n      // Other admin operations available here\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#in-flight-consumer","title":"In-Flight Consumer","text":"<p>Create a consumer for advanced testing scenarios:</p> <pre><code>TestSystem.validate {\n  kafka {\n    consumer&lt;String, ProductCreated&gt;(\n      topic = \"product-events\",\n      readOnly = false, // commit messages\n      autoOffsetReset = \"earliest\",\n      autoCreateTopics = true,\n      keepConsumingAtLeastFor = 10.seconds\n    ) { record -&gt;\n      println(\"Consumed: ${record.value()}\")\n      // Process the message\n    }\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, Kafka, and database assertions:</p> <pre><code>test(\"should create product and publish event\") {\n  TestSystem.validate {\n    val productId = UUID.randomUUID()\n    val productName = \"Laptop\"\n\n    // Mock external service\n    wiremock {\n      mockGet(\"/categories/electronics\", statusCode = 200, responseBody = Category(id = 1, active = true).some())\n    }\n\n    // Make HTTP request\n    http {\n      postAndExpectBodilessResponse(\n        uri = \"/products\",\n        body = ProductCreateRequest(id = productId, name = productName, categoryId = 1).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify Kafka message was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName &amp;&amp;\n        metadata.headers[\"X-UserEmail\"] != null\n      }\n    }\n\n    // Verify database state\n    couchbase {\n      shouldGet&lt;Product&gt;(\"product:$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe productName\n      }\n    }\n\n    // Verify the event was consumed by another service\n    kafka {\n      shouldBeConsumed&lt;ProductCreatedEvent&gt;(atLeastIn = 20.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/","title":"Elasticsearch","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-elasticsearch:$version\")\n    }\n</code></pre>"},{"location":"Components/03-elasticsearch/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>elasticsearch</code> function. This function configures the Elasticsearch Docker container that is going to be started.</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"elasticsearch.host=${cfg.host}\",\n          \"elasticsearch.port=${cfg.port}\",\n          \"elasticsearch.password=${cfg.password}\"\n        )\n      })\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#container-options","title":"Container Options","text":"<p>You can customize the Elasticsearch container:</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n          registry = \"docker.elastic.co/\",\n          image = \"elasticsearch/elasticsearch\",\n          tag = \"8.6.1\",\n          password = \"password\",\n          disableSecurity = true, // Disable for simpler test setup\n          exposedPorts = listOf(9200)\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#security-configuration","title":"Security Configuration","text":"<p>For secure Elasticsearch setups with authentication:</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        container = ElasticContainerOptions(\n          disableSecurity = false, // Enable security\n          password = \"your-secure-password\"\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\",\n            \"elasticsearch.password=${cfg.password}\",\n            \"elasticsearch.ssl.enabled=true\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#client-configurer","title":"Client Configurer","text":"<p>Customize the Elasticsearch REST client:</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        clientConfigurer = ElasticClientConfigurer(\n          httpClientBuilder = {\n            setDefaultRequestConfig(\n              RequestConfig.custom()\n                .setSocketTimeout(60000)\n                .setConnectTimeout(30000)\n                .build()\n            )\n          }\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#custom-json-mapper","title":"Custom JSON Mapper","text":"<p>Use a custom Jackson ObjectMapper for serialization:</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      val customMapper = ObjectMapper().apply {\n        registerModule(JavaTimeModule())\n        disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n      }\n      ElasticsearchSystemOptions(\n        jsonpMapper = JacksonJsonpMapper(customMapper),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#migrations","title":"Migrations","text":"<p>Stove provides a way to run index migrations before tests start:</p> <pre><code>class CreateProductIndex : DatabaseMigration&lt;ElasticsearchClient&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: ElasticsearchClient) {\n    connection.indices().create { c -&gt;\n      c.index(\"products\")\n        .mappings { m -&gt;\n          m.properties(\"name\") { p -&gt; p.text { t -&gt; t } }\n            .properties(\"price\") { p -&gt; p.double_ { d -&gt; d } }\n            .properties(\"category\") { p -&gt; p.keyword { k -&gt; k } }\n            .properties(\"createdAt\") { p -&gt; p.date { d -&gt; d } }\n        }\n    }\n  }\n}\n</code></pre> <p>Register migrations in your TestSystem configuration:</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      ).migrations {\n        register&lt;CreateProductIndex&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#usage","title":"Usage","text":""},{"location":"Components/03-elasticsearch/#saving-documents","title":"Saving Documents","text":"<p>Save documents to Elasticsearch indices:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    // Save a document\n    save(\n      id = \"product-123\",\n      instance = Product(\n        id = \"123\",\n        name = \"Laptop\",\n        price = 999.99,\n        category = \"Electronics\"\n      ),\n      index = \"products\"\n    )\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#getting-documents","title":"Getting Documents","text":"<p>Retrieve and validate documents:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    // Get by ID and validate\n    shouldGet&lt;Product&gt;(index = \"products\", key = \"product-123\") { product -&gt;\n      product.id shouldBe \"123\"\n      product.name shouldBe \"Laptop\"\n      product.price shouldBe 999.99\n      product.category shouldBe \"Electronics\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#checking-non-existence","title":"Checking Non-Existence","text":"<p>Verify that documents don't exist:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    // Verify document doesn't exist\n    shouldNotExist(key = \"product-999\", index = \"products\")\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#deleting-documents","title":"Deleting Documents","text":"<p>Delete documents and verify deletion:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    // Delete a document\n    shouldDelete(key = \"product-123\", index = \"products\")\n\n    // Verify deletion\n    shouldNotExist(key = \"product-123\", index = \"products\")\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#querying-with-json-query-dsl","title":"Querying with JSON Query DSL","text":"<p>Execute Elasticsearch queries using JSON DSL:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    // Query using JSON DSL\n    shouldQuery&lt;Product&gt;(\n      query = \"\"\"\n        {\n          \"bool\": {\n            \"must\": [\n              { \"match\": { \"category\": \"Electronics\" } },\n              { \"range\": { \"price\": { \"gte\": 500 } } }\n            ]\n          }\n        }\n      \"\"\".trimIndent(),\n      index = \"products\"\n    ) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.category == \"Electronics\" &amp;&amp; it.price &gt;= 500 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#querying-with-query-builder","title":"Querying with Query Builder","text":"<p>Use the Elasticsearch Java client's query builder:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    // Query using Query builder\n    val query = Query.of { q -&gt;\n      q.bool { b -&gt;\n        b.must { m -&gt;\n          m.match { t -&gt; t.field(\"category\").query(\"Electronics\") }\n        }.filter { f -&gt;\n          f.range { r -&gt; r.field(\"price\").gte(JsonData.of(500)) }\n        }\n      }\n    }\n\n    shouldQuery&lt;Product&gt;(query) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.category == \"Electronics\" &amp;&amp; it.price &gt;= 500 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#accessing-the-client-directly","title":"Accessing the Client Directly","text":"<p>For advanced operations, access the Elasticsearch client:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    val esClient = client()\n\n    // Perform custom operations\n    val indexExists = esClient.indices().exists { e -&gt; e.index(\"products\") }.value()\n    indexExists shouldBe true\n\n    // Bulk operations\n    esClient.bulk { b -&gt;\n      b.operations { op -&gt;\n        op.index { i -&gt;\n          i.index(\"products\")\n            .id(\"bulk-1\")\n            .document(Product(id = \"bulk-1\", name = \"Mouse\", price = 29.99, category = \"Electronics\"))\n        }\n      }.operations { op -&gt;\n        op.index { i -&gt;\n          i.index(\"products\")\n            .id(\"bulk-2\")\n            .document(Product(id = \"bulk-2\", name = \"Keyboard\", price = 79.99, category = \"Electronics\"))\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Control the Elasticsearch container for testing failure scenarios:</p> <pre><code>TestSystem.validate {\n  elasticsearch {\n    // Elasticsearch is running\n    shouldGet&lt;Product&gt;(index = \"products\", key = \"product-123\") { product -&gt;\n      product.id shouldBe \"123\"\n    }\n\n    // Pause the container\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the container\n    unpause()\n\n    // Verify recovery\n    shouldGet&lt;Product&gt;(index = \"products\", key = \"product-123\") { product -&gt;\n      product.id shouldBe \"123\"\n    }\n  }\n}\n</code></pre> <p>Warning</p> <p><code>pause()</code> and <code>unpause()</code> operations are not supported when using a provided instance.</p>"},{"location":"Components/03-elasticsearch/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, Elasticsearch, and Kafka:</p> <pre><code>test(\"should create product and index in elasticsearch\") {\n  TestSystem.validate {\n    val productId = UUID.randomUUID().toString()\n    val productName = \"Gaming Laptop\"\n    val categoryId = 1\n\n    // Mock external service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Create product via API\n    http {\n      postAndExpectBody&lt;ProductResponse&gt;(\n        uri = \"/products\",\n        body = ProductCreateRequest(\n          name = productName,\n          price = 1299.99,\n          categoryId = categoryId\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().id shouldNotBe null\n      }\n    }\n\n    // Verify indexed in Elasticsearch\n    elasticsearch {\n      shouldGet&lt;Product&gt;(index = \"products\", key = productId) { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe productName\n        product.price shouldBe 1299.99\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.id == productId &amp;&amp;\n        actual.name == productName\n      }\n    }\n\n    // Query products by category\n    elasticsearch {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"\n          {\n            \"term\": { \"category\": \"Electronics\" }\n          }\n        \"\"\".trimIndent(),\n        index = \"products\"\n      ) { products -&gt;\n        products.size shouldBeGreaterThan 0\n        products.any { it.id == productId } shouldBe true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#integration-with-application","title":"Integration with Application","text":"<p>Verify application behavior using the bridge:</p> <pre><code>test(\"should use service to index product\") {\n  TestSystem.validate {\n    val productId = UUID.randomUUID().toString()\n    val product = Product(id = productId, name = \"Test Product\", price = 99.99, category = \"Test\")\n\n    // Use application's service\n    using&lt;ProductIndexingService&gt; {\n      indexProduct(product)\n    }\n\n    // Verify in Elasticsearch\n    elasticsearch {\n      shouldGet&lt;Product&gt;(index = \"products\", key = productId) { indexed -&gt;\n        indexed.id shouldBe productId\n        indexed.name shouldBe \"Test Product\"\n        indexed.price shouldBe 99.99\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#advanced-operations","title":"Advanced Operations","text":""},{"location":"Components/03-elasticsearch/#full-text-search","title":"Full-Text Search","text":"<pre><code>TestSystem.validate {\n  elasticsearch {\n    // Setup test data\n    listOf(\n      Product(id = \"1\", name = \"MacBook Pro 16 inch\", price = 2499.99, category = \"Laptops\"),\n      Product(id = \"2\", name = \"MacBook Air M2\", price = 1199.99, category = \"Laptops\"),\n      Product(id = \"3\", name = \"Dell XPS 15\", price = 1799.99, category = \"Laptops\")\n    ).forEach { product -&gt;\n      save(id = product.id, instance = product, index = \"products\")\n    }\n\n    // Full-text search\n    shouldQuery&lt;Product&gt;(\n      query = \"\"\"\n        {\n          \"multi_match\": {\n            \"query\": \"MacBook\",\n            \"fields\": [\"name\", \"description\"]\n          }\n        }\n      \"\"\".trimIndent(),\n      index = \"products\"\n    ) { results -&gt;\n      results.size shouldBe 2\n      results.all { \"MacBook\" in it.name } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#aggregations","title":"Aggregations","text":"<pre><code>TestSystem.validate {\n  elasticsearch {\n    val esClient = client()\n\n    // Search with aggregations\n    val response = esClient.search({ s -&gt;\n      s.index(\"products\")\n        .size(0)\n        .aggregations(\"price_stats\") { a -&gt;\n          a.stats { st -&gt; st.field(\"price\") }\n        }\n        .aggregations(\"by_category\") { a -&gt;\n          a.terms { t -&gt; t.field(\"category.keyword\") }\n        }\n    }, Product::class.java)\n\n    // Access aggregation results\n    val priceStats = response.aggregations()[\"price_stats\"]?.stats()\n    priceStats?.avg() shouldNotBe null\n    priceStats?.min() shouldNotBe null\n    priceStats?.max() shouldNotBe null\n\n    val categoryBuckets = response.aggregations()[\"by_category\"]?.sterms()?.buckets()?.array()\n    categoryBuckets?.size shouldBeGreaterThan 0\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#index-management","title":"Index Management","text":"<pre><code>TestSystem.validate {\n  elasticsearch {\n    val esClient = client()\n\n    // Create index with custom settings\n    esClient.indices().create { c -&gt;\n      c.index(\"test-index\")\n        .settings { s -&gt;\n          s.numberOfShards(\"1\")\n            .numberOfReplicas(\"0\")\n        }\n        .mappings { m -&gt;\n          m.properties(\"title\") { p -&gt; p.text { t -&gt; t.analyzer(\"standard\") } }\n            .properties(\"tags\") { p -&gt; p.keyword { k -&gt; k } }\n        }\n    }\n\n    // Check index exists\n    val exists = esClient.indices().exists { e -&gt; e.index(\"test-index\") }.value()\n    exists shouldBe true\n\n    // Delete index\n    esClient.indices().delete { d -&gt; d.index(\"test-index\") }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/#provided-instance-external-elasticsearch","title":"Provided Instance (External Elasticsearch)","text":"<p>For CI/CD pipelines or shared infrastructure:</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions.provided(\n        host = System.getenv(\"ELASTICSEARCH_HOST\") ?: \"localhost\",\n        port = System.getenv(\"ELASTICSEARCH_PORT\")?.toInt() ?: 9200,\n        password = System.getenv(\"ELASTICSEARCH_PASSWORD\") ?: \"\",\n        runMigrations = true,\n        cleanup = { esClient -&gt;\n          // Clean up test indices after tests\n          esClient.indices().delete { d -&gt; d.index(\"test-*\") }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\",\n            \"elasticsearch.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/03-elasticsearch/#data-classes-example","title":"Data Classes Example","text":"<pre><code>data class Product(\n  val id: String,\n  val name: String,\n  val description: String? = null,\n  val price: Double,\n  val category: String,\n  val tags: List&lt;String&gt; = emptyList(),\n  val createdAt: Instant = Instant.now()\n)\n\ndata class SearchResult(\n  val total: Long,\n  val products: List&lt;Product&gt;\n)\n</code></pre>"},{"location":"Components/04-wiremock/","title":"Wiremock","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-wiremock:$version\")\n    }\n</code></pre>"},{"location":"Components/04-wiremock/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>wiremock</code> function.</p> <p>This will start an instance of Wiremock server. You can configure the port of the Wiremock server.</p> <pre><code>TestSystem()\n  .with {\n    wiremock {\n      WiremockSystemOptions(\n        port = 8080,\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/04-wiremock/#options","title":"Options","text":"<pre><code>data class WireMockSystemOptions(\n  /**\n   * Port of wiremock server\n   */\n  val port: Int = 9090,\n  /**\n   * Configures wiremock server\n   */\n  val configure: WireMockConfiguration.() -&gt; WireMockConfiguration = { this.notifier(ConsoleNotifier(true)) },\n  /**\n   * Removes the stub when request matches/completes\n   * Default value is false\n   */\n  val removeStubAfterRequestMatched: Boolean = false,\n  /**\n   * Called after stub removed\n   */\n  val afterStubRemoved: AfterStubRemoved = { _, _ -&gt; },\n  /**\n   * Called after request handled\n   */\n  val afterRequest: AfterRequestHandler = { _, _ -&gt; },\n  /**\n   * ObjectMapper for serialization/deserialization\n   */\n  val serde: StoveSerde&lt;Any, ByteArray&gt; = StoveSerde.jackson.anyByteArraySerde()\n) : SystemOptions\n</code></pre>"},{"location":"Components/04-wiremock/#mocking","title":"Mocking","text":"<p>Wiremock starts a mock server on <code>localhost</code> with the configured port. </p> <p>Critical: External Service URLs Must Match WireMock</p> <p>All external service URLs in your application must be configured to point to the WireMock server.</p> <p>This is one of the most common configuration mistakes. If your application's external service URLs  don't match WireMock's URL, your mocks won't be hit and tests will fail or timeout.</p>"},{"location":"Components/04-wiremock/#url-configuration","title":"URL Configuration","text":"<p>Say your application calls external services in production:</p> <ul> <li><code>http://payment-service.com/api/payments</code></li> <li><code>http://inventory-service.com/api/stock</code></li> <li><code>http://notification-service.com/api/notify</code></li> </ul> <p>For testing, all these base URLs must be replaced with the WireMock URL (e.g., <code>http://localhost:9090</code>).</p> <p>You can pass these as application parameters:</p> <pre><code>TestSystem()\n  .with {\n    wiremock {\n      WireMockSystemOptions(\n        port = 9090,\n      )\n    }\n    springBoot( // or ktor\n      runner = { params -&gt;\n        com.myapp.run(params)\n      },\n      withParameters = listOf(\n        // All external services point to WireMock\n        \"payment.service.url=http://localhost:9090\",\n        \"inventory.service.url=http://localhost:9090\",\n        \"notification.service.url=http://localhost:9090\"\n      )\n    )\n  }\n  .run()\n</code></pre>"},{"location":"Components/04-wiremock/#application-configuration-tips","title":"Application Configuration Tips","text":"<p>Make your external service URLs configurable in your application:</p> Spring Boot (application.yml)Ktor <pre><code>external:\n  payment-service:\n    url: ${PAYMENT_SERVICE_URL:http://payment-service.com}\n  inventory-service:\n    url: ${INVENTORY_SERVICE_URL:http://inventory-service.com}\n</code></pre> <pre><code>val paymentUrl = environment.config.propertyOrNull(\"payment.service.url\")\n    ?.getString() ?: \"http://payment-service.com\"\n</code></pre> <p>Then in your tests, Stove passes the WireMock URL through parameters, overriding the defaults.</p> <p>All service endpoints will be pointing to the WireMock server. You can now define the stubs for the services that your application calls.</p>"},{"location":"Components/04-wiremock/#usage","title":"Usage","text":""},{"location":"Components/04-wiremock/#get-requests","title":"GET Requests","text":"<p>Mock GET requests with various configurations:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // Simple GET mock\n    mockGet(\n      url = \"/api/products\",\n      statusCode = 200,\n      responseBody = listOf(\n        Product(\"1\", \"Laptop\", 999.99),\n        Product(\"2\", \"Mouse\", 29.99)\n      ).some()\n    )\n\n    // GET with custom headers\n    mockGet(\n      url = \"/api/user/profile\",\n      statusCode = 200,\n      responseBody = UserProfile(id = \"123\", name = \"John\").some(),\n      responseHeaders = mapOf(\n        \"Content-Type\" to \"application/json\",\n        \"X-Rate-Limit\" to \"100\"\n      )\n    )\n\n    // GET returning error\n    mockGet(\n      url = \"/api/products/999\",\n      statusCode = 404,\n      responseBody = ErrorResponse(\"Product not found\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#post-requests","title":"POST Requests","text":"<p>Mock POST requests with request/response bodies:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // POST with request and response body\n    mockPost(\n      url = \"/api/orders\",\n      statusCode = 201,\n      requestBody = CreateOrderRequest(items = listOf(\"item1\", \"item2\")).some(),\n      responseBody = OrderResponse(orderId = \"order-123\", status = \"CREATED\").some()\n    )\n\n    // POST with metadata matching\n    mockPost(\n      url = \"/api/users\",\n      statusCode = 201,\n      requestBody = CreateUserRequest(name = \"John\").some(),\n      responseBody = UserResponse(id = \"user-123\", name = \"John\").some(),\n      metadata = mapOf(\"Content-Type\" to \"application/json\")\n    )\n\n    // POST returning error\n    mockPost(\n      url = \"/api/orders\",\n      statusCode = 400,\n      requestBody = InvalidOrderRequest().some(),\n      responseBody = ValidationError(\"Invalid order data\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#put-requests","title":"PUT Requests","text":"<p>Mock PUT requests for updates:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // PUT with full update\n    mockPut(\n      url = \"/api/products/123\",\n      statusCode = 200,\n      requestBody = UpdateProductRequest(name = \"Updated Product\", price = 899.99).some(),\n      responseBody = Product(\"123\", \"Updated Product\", 899.99).some()\n    )\n\n    // PUT with no response body\n    mockPut(\n      url = \"/api/settings/update\",\n      statusCode = 204,\n      requestBody = UpdateSettingsRequest(theme = \"dark\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#patch-requests","title":"PATCH Requests","text":"<p>Mock PATCH requests for partial updates:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // PATCH for partial update\n    mockPatch(\n      url = \"/api/users/123\",\n      statusCode = 200,\n      requestBody = mapOf(\"email\" to \"newemail@example.com\").some(),\n      responseBody = UserResponse(id = \"123\", email = \"newemail@example.com\").some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#delete-requests","title":"DELETE Requests","text":"<p>Mock DELETE requests:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // DELETE returning success\n    mockDelete(\n      url = \"/api/products/123\",\n      statusCode = 204\n    )\n\n    // DELETE with metadata\n    mockDelete(\n      url = \"/api/users/456\",\n      statusCode = 200,\n      metadata = mapOf(\"Authorization\" to \"Bearer token123\")\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#head-requests","title":"HEAD Requests","text":"<p>Mock HEAD requests:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    mockHead(\n      url = \"/api/products/exists/123\",\n      statusCode = 200\n    )\n\n    mockHead(\n      url = \"/api/products/exists/999\",\n      statusCode = 404\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#advanced-configuration","title":"Advanced Configuration","text":"<p>For complex scenarios, use the configure methods:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // Advanced GET configuration\n    mockGetConfigure(\n      url = \"/api/search\",\n      urlPatternFn = { urlPathMatching(\"/api/search.*\") }\n    ) { builder, serde -&gt;\n      builder\n        .withQueryParam(\"q\", matching(\".*laptop.*\"))\n        .willReturn(\n          aResponse()\n            .withStatus(200)\n            .withBody(serde.serialize(SearchResults(items = listOf(\"item1\", \"item2\"))))\n        )\n    }\n\n    // Advanced POST configuration\n    mockPostConfigure(\n      url = \"/api/webhooks\",\n      urlPatternFn = { urlEqualTo(it) }\n    ) { builder, serde -&gt;\n      builder\n        .withHeader(\"X-Webhook-Secret\", equalTo(\"secret123\"))\n        .withRequestBody(containing(\"event_type\"))\n        .willReturn(\n          aResponse()\n            .withStatus(200)\n            .withBody(\"Webhook received\")\n        )\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#partial-body-matching","title":"Partial Body Matching","text":"<p>When you only need to match specific fields in a request body without specifying the entire payload,  use the <code>*Containing</code> methods. This is useful when:</p> <ul> <li>The request body has fields you don't control (timestamps, generated IDs)</li> <li>You only care about matching certain business-critical fields</li> <li>The request body structure is complex but you need to match a single unique identifier</li> </ul>"},{"location":"Components/04-wiremock/#basic-partial-matching","title":"Basic Partial Matching","text":"<p>Match requests containing specific fields:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // Only matches requests where productId = 123, ignores other fields\n    mockPostContaining(\n      url = \"/api/orders\",\n      requestContaining = mapOf(\"productId\" to 123),\n      statusCode = 201,\n      responseBody = OrderResponse(orderId = \"order-123\").some()\n    )\n  }\n}\n\n// This request WILL match (extra fields are ignored):\n// POST /api/orders\n// {\"productId\": 123, \"quantity\": 5, \"userId\": \"user-456\", \"timestamp\": \"2024-01-01T00:00:00Z\"}\n</code></pre>"},{"location":"Components/04-wiremock/#multiple-field-matching-and-logic","title":"Multiple Field Matching (AND Logic)","text":"<p>When you specify multiple fields, they are matched using AND logic - all specified fields  must be present and match for the stub to be triggered:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // ALL three fields must match for this stub to respond\n    mockPostContaining(\n      url = \"/api/payments\",\n      requestContaining = mapOf(\n        \"orderId\" to \"order-123\",      // AND\n        \"amount\" to 99.99,              // AND\n        \"currency\" to \"USD\"\n      ),\n      statusCode = 200,\n      responseBody = PaymentResponse(transactionId = \"txn-789\").some()\n    )\n  }\n}\n\n// \u2705 MATCHES - all three fields present and correct:\n// {\"orderId\": \"order-123\", \"amount\": 99.99, \"currency\": \"USD\", \"extra\": \"ignored\"}\n\n// \u274c DOES NOT MATCH - missing \"currency\":\n// {\"orderId\": \"order-123\", \"amount\": 99.99}\n\n// \u274c DOES NOT MATCH - wrong value for \"amount\":\n// {\"orderId\": \"order-123\", \"amount\": 50.00, \"currency\": \"USD\"}\n</code></pre>"},{"location":"Components/04-wiremock/#deep-nested-matching-with-dot-notation","title":"Deep Nested Matching with Dot Notation","text":"<p>Match specific fields deep within nested JSON structures using dot notation:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // Match a single field deep in the JSON structure\n    mockPostContaining(\n      url = \"/api/orders\",\n      requestContaining = mapOf(\"order.customer.id\" to \"cust-123\"),\n      statusCode = 200,\n      responseBody = OrderConfirmation(status = \"confirmed\").some()\n    )\n  }\n}\n\n// This request WILL match:\n// POST /api/orders\n// {\n//   \"order\": {\n//     \"id\": \"order-999\",\n//     \"customer\": {\n//       \"id\": \"cust-123\",           &lt;-- Only this field is matched\n//       \"name\": \"John Doe\",\n//       \"email\": \"john@example.com\"\n//     },\n//     \"items\": [...]\n//   },\n//   \"metadata\": {...}\n// }\n</code></pre>"},{"location":"Components/04-wiremock/#multiple-deep-nested-fields","title":"Multiple Deep Nested Fields","text":"<p>Match multiple fields at different levels of nesting:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    mockPostContaining(\n      url = \"/api/checkout\",\n      requestContaining = mapOf(\n        \"order.customer.id\" to \"cust-123\",\n        \"order.payment.method\" to \"credit_card\",\n        \"metadata.source\" to \"mobile_app\"\n      ),\n      statusCode = 200,\n      responseBody = CheckoutResponse(success = true).some()\n    )\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#nested-object-matching","title":"Nested Object Matching","text":"<p>Match nested objects with partial comparison (extra fields in nested objects are ignored):</p> <pre><code>TestSystem.validate {\n  wiremock {\n    // Match if the \"settings\" object contains at least {enabled: true}\n    mockPutContaining(\n      url = \"/api/config\",\n      requestContaining = mapOf(\n        \"settings\" to mapOf(\"enabled\" to true)\n      ),\n      statusCode = 200\n    )\n  }\n}\n\n// This request WILL match (extra fields in settings are ignored):\n// PUT /api/config\n// {\n//   \"settings\": {\n//     \"enabled\": true,      &lt;-- Matched\n//     \"level\": 5,           &lt;-- Ignored\n//     \"features\": [...]     &lt;-- Ignored\n//   }\n// }\n</code></pre>"},{"location":"Components/04-wiremock/#available-partial-matching-methods","title":"Available Partial Matching Methods","text":"Method HTTP Method Description <code>mockPostContaining</code> POST Partial body matching for POST requests <code>mockPutContaining</code> PUT Partial body matching for PUT requests <code>mockPatchContaining</code> PATCH Partial body matching for PATCH requests <p>All methods support:</p> <ul> <li>Simple values: strings, numbers, booleans</li> <li>Dot notation: <code>\"order.customer.id\"</code> for deep nested access</li> <li>Nested objects: <code>mapOf(\"user\" to mapOf(\"id\" to 123))</code></li> <li>Arrays: <code>mapOf(\"tags\" to listOf(\"important\", \"urgent\"))</code></li> <li>URL patterns: Use <code>urlPatternFn</code> parameter for regex URL matching</li> </ul>"},{"location":"Components/04-wiremock/#url-pattern-with-partial-matching","title":"URL Pattern with Partial Matching","text":"<p>Combine URL patterns with partial body matching:</p> <pre><code>TestSystem.validate {\n  wiremock {\n    mockPostContaining(\n      url = \"/api/v[0-9]+/orders\",\n      requestContaining = mapOf(\"orderId\" to \"order-123\"),\n      statusCode = 200,\n      urlPatternFn = { urlPathMatching(it) }  // Enable regex URL matching\n    )\n  }\n}\n\n// Matches: POST /api/v1/orders, POST /api/v2/orders, etc.\n</code></pre>"},{"location":"Components/04-wiremock/#behavioral-mocking","title":"Behavioral Mocking","text":"<p>Simulate service behavior changes over multiple calls:</p> <pre><code>test(\"service recovers from failure\") {\n  TestSystem.validate {\n    wiremock {\n      behaviourFor(\"/api/external-service\", WireMock::get) {\n        initially {\n          aResponse()\n            .withStatus(503)\n            .withBody(\"Service unavailable\")\n        }\n        then {\n          aResponse()\n            .withStatus(503)\n            .withBody(\"Still unavailable\")\n        }\n        then {\n          aResponse()\n            .withStatus(200)\n            .withHeader(\"Content-Type\", \"application/json\")\n            .withBody(it.serialize(ServiceResponse(status = \"OK\")))\n        }\n      }\n    }\n\n    http {\n      // First call - failure\n      getResponse(\"/api/external-service\") { response -&gt;\n        response.status shouldBe 503\n      }\n\n      // Second call - still failing\n      getResponse(\"/api/external-service\") { response -&gt;\n        response.status shouldBe 503\n      }\n\n      // Third call - success\n      get&lt;ServiceResponse&gt;(\"/api/external-service\") { response -&gt;\n        response.status shouldBe \"OK\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#testing-circuit-breaker","title":"Testing Circuit Breaker","text":"<p>Test circuit breaker patterns with WireMock:</p> <pre><code>test(\"circuit breaker opens after failures\") {\n  TestSystem.validate {\n    wiremock {\n      // Mock service that fails\n      mockGet(\n        url = \"/api/unreliable-service\",\n        statusCode = 500,\n        responseBody = \"Internal Server Error\".some()\n      )\n    }\n\n    // Application calls the service multiple times\n    repeat(5) {\n      http {\n        getResponse(\"/api/call-external\") { response -&gt;\n          // First few calls fail\n          response.status shouldBe 500\n        }\n      }\n    }\n\n    // Update mock to return success\n    wiremock {\n      mockGet(\n        url = \"/api/unreliable-service\",\n        statusCode = 200,\n        responseBody = ServiceResponse(status = \"OK\").some()\n      )\n    }\n\n    // Circuit breaker should open, need to wait for recovery\n    delay(5.seconds)\n\n    http {\n      get&lt;ServiceResponse&gt;(\"/api/call-external\") { response -&gt;\n        response.status shouldBe \"OK\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#complete-example","title":"Complete Example","text":"<p>Here's a complete test with multiple external service mocks:</p> <pre><code>test(\"should create order with external service validation\") {\n  TestSystem.validate {\n    val userId = \"user-123\"\n    val productId = \"product-456\"\n    val categoryId = 1\n\n    // Mock user service\n    wiremock {\n      mockGet(\n        url = \"/users/$userId\",\n        statusCode = 200,\n        responseBody = User(id = userId, name = \"John Doe\", active = true).some(),\n        responseHeaders = mapOf(\"X-Service\" to \"UserService\")\n      )\n    }\n\n    // Mock product catalog service\n    wiremock {\n      mockGet(\n        url = \"/products/$productId\",\n        statusCode = 200,\n        responseBody = Product(\n          id = productId,\n          name = \"Laptop\",\n          price = 999.99,\n          stock = 10\n        ).some()\n      )\n    }\n\n    // Mock category service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Mock inventory service (POST to reserve stock)\n    wiremock {\n      mockPost(\n        url = \"/inventory/reserve\",\n        statusCode = 200,\n        requestBody = ReserveStockRequest(productId = productId, quantity = 1).some(),\n        responseBody = ReservationResponse(reservationId = \"res-789\", success = true).some()\n      )\n    }\n\n    // Create order via your API\n    http {\n      postAndExpectBody&lt;OrderResponse&gt;(\n        uri = \"/orders\",\n        body = CreateOrderRequest(\n          userId = userId,\n          productId = productId,\n          quantity = 1\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().orderId shouldNotBe null\n        response.body().status shouldBe \"CREATED\"\n      }\n    }\n\n    // Verify order was stored\n    postgresql {\n      shouldQuery&lt;Order&gt;(\n        \"SELECT * FROM orders WHERE user_id = ?\",\n        mapper = { row -&gt;\n          Order(\n            id = row.long(\"id\"),\n            userId = row.string(\"user_id\"),\n            productId = row.string(\"product_id\"),\n            quantity = row.int(\"quantity\")\n          )\n        }\n      ) { orders -&gt;\n        orders.size shouldBe 1\n        orders.first().userId shouldBe userId\n        orders.first().productId shouldBe productId\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.userId == userId &amp;&amp;\n        actual.productId == productId\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#error-scenarios","title":"Error Scenarios","text":"<p>Test how your application handles external service failures:</p> <pre><code>test(\"should handle external service unavailability\") {\n  TestSystem.validate {\n    // Mock external service returning 503\n    wiremock {\n      mockGet(\n        url = \"/external-api/data\",\n        statusCode = 503,\n        responseBody = ErrorResponse(\"Service temporarily unavailable\").some()\n      )\n    }\n\n    // Your application should handle this gracefully\n    http {\n      getResponse(\"/api/fetch-data\") { response -&gt;\n        response.status shouldBe 503 // or your fallback status\n      }\n    }\n  }\n}\n\ntest(\"should handle timeout\") {\n  TestSystem.validate {\n    wiremock {\n      mockGetConfigure(\"/slow-endpoint\") { builder, _ -&gt;\n        builder.willReturn(\n          aResponse()\n            .withStatus(200)\n            .withBody(\"Response\")\n            .withFixedDelay(5000) // 5 second delay\n        )\n      }\n    }\n\n    http {\n      getResponse(\"/api/call-slow-service\") { response -&gt;\n        // Your application should timeout and handle it\n        response.status shouldBe 504 // Gateway timeout\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#integration-testing","title":"Integration Testing","text":"<p>Test complex integrations with multiple services:</p> <pre><code>test(\"should orchestrate multiple services\") {\n  TestSystem.validate {\n    val userId = \"user-123\"\n\n    // Mock authentication service\n    wiremock {\n      mockPost(\n        url = \"/auth/validate\",\n        statusCode = 200,\n        requestBody = TokenRequest(token = \"jwt-token\").some(),\n        responseBody = TokenValidation(valid = true, userId = userId).some()\n      )\n    }\n\n    // Mock permissions service\n    wiremock {\n      mockGet(\n        url = \"/permissions/$userId\",\n        statusCode = 200,\n        responseBody = Permissions(\n          userId = userId,\n          roles = listOf(\"USER\", \"ADMIN\")\n        ).some()\n      )\n    }\n\n    // Make authenticated request\n    http {\n      get&lt;SecureData&gt;(\n        uri = \"/api/secure-data\",\n        token = \"jwt-token\".some()\n      ) { data -&gt;\n        data.accessible shouldBe true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/04-wiremock/#request-verification","title":"Request Verification","text":"<p>Verify that requests were made as expected:</p> <pre><code>test(\"should verify request details\") {\n  TestSystem.validate {\n    wiremock {\n      mockPost(\n        url = \"/api/webhook\",\n        statusCode = 200,\n        metadata = mapOf(\n          \"X-Signature\" to \"expected-signature\"\n        )\n      )\n    }\n\n    // Trigger webhook\n    http {\n      postAndExpectBodilessResponse(\n        uri = \"/trigger-webhook\",\n        body = WebhookTrigger(event = \"user.created\").some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify the webhook was called with correct signature\n    // (WireMock will only match if headers match)\n  }\n}\n</code></pre>"},{"location":"Components/05-http/","title":"HttpClient","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n    }\n</code></pre>"},{"location":"Components/05-http/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>http</code></p> <pre><code>TestSystem()\n  .with {\n    http {\n      HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8080\",\n      )\n    }\n  }\n  .run()\n</code></pre> <p>The other options that you can set are: <pre><code>data class HttpClientSystemOptions(\n  /**\n   * Base URL of the HTTP client.\n   */\n  val baseUrl: String,\n\n  /**\n   * Content converter for the HTTP client. Default is JacksonConverter. You can use GsonConverter or any other converter.\n   * If you want to use your own converter, you can implement ContentConverter interface.\n   */\n  val contentConverter: ContentConverter = JacksonConverter(StoveSerde.jackson.default),\n\n  /**\n   * Timeout for the HTTP client. Default is 30 seconds.\n   */\n  val timeout: Duration = 30.seconds,\n\n  /**\n   * Create client function for the HTTP client. Default is jsonHttpClient.\n   */\n  val createClient: () -&gt; io.ktor.client.HttpClient = { jsonHttpClient(timeout, contentConverter) }\n)\n</code></pre></p>"},{"location":"Components/05-http/#usage","title":"Usage","text":""},{"location":"Components/05-http/#get-requests","title":"GET Requests","text":"<p>Making GET requests with various options:</p> <pre><code>TestSystem.validate {\n  http {\n    // Simple GET request with type-safe response\n    get&lt;UserResponse&gt;(\"/users/123\") { user -&gt;\n      user.id shouldBe 123\n      user.name shouldBe \"John Doe\"\n    }\n\n    // GET with query parameters\n    get&lt;String&gt;(\"/api/index\", queryParams = mapOf(\"keyword\" to \"search-term\")) { response -&gt;\n      response shouldContain \"search-term\"\n    }\n\n    // GET with headers\n    get&lt;UserProfile&gt;(\"/profile\", headers = mapOf(\"X-Custom-Header\" to \"value\")) { profile -&gt;\n      profile.email shouldNotBe null\n    }\n\n    // GET with authentication token\n    get&lt;SecureData&gt;(\"/secure-endpoint\", token = \"jwt-token\".some()) { data -&gt;\n      data.isAuthorized shouldBe true\n    }\n\n    // GET multiple items (list response)\n    getMany&lt;ProductResponse&gt;(\"/products\", queryParams = mapOf(\"page\" to \"1\", \"size\" to \"10\")) { products -&gt;\n      products.size shouldBe 10\n      products.first().name shouldNotBe null\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#get-with-full-response-access","title":"GET with Full Response Access","text":"<p>When you need access to status code and headers:</p> <pre><code>TestSystem.validate {\n  http {\n    getResponse&lt;UserResponse&gt;(\"/users/123\") { response -&gt;\n      response.status shouldBe 200\n      response.headers[\"Content-Type\"] shouldContain \"application/json\"\n      response.body().id shouldBe 123\n    }\n\n    // Bodiless response (only status and headers)\n    getResponse(\"/health\") { response -&gt;\n      response.status shouldBe 200\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#post-requests","title":"POST Requests","text":"<p>Various POST request patterns:</p> <pre><code>TestSystem.validate {\n  http {\n    // POST with request body and expect JSON response\n    postAndExpectJson&lt;UserResponse&gt;(\"/users\") {\n      CreateUserRequest(name = \"John\", email = \"john@example.com\")\n    } { user -&gt;\n      user.id shouldNotBe null\n      user.name shouldBe \"John\"\n    }\n\n    // POST and expect bodiless response (only status)\n    postAndExpectBodilessResponse(\n      uri = \"/products/activate\",\n      body = ActivateRequest(productId = 123).some()\n    ) { response -&gt;\n      response.status shouldBe 200\n    }\n\n    // POST with full response access\n    postAndExpectBody&lt;ProductResponse&gt;(\n      uri = \"/products\",\n      body = CreateProductRequest(name = \"Laptop\", price = 999.99).some()\n    ) { response -&gt;\n      response.status shouldBe 201\n      response.headers[\"Location\"] shouldNotBe null\n      response.body().id shouldNotBe null\n    }\n\n    // POST with headers and token\n    postAndExpectJson&lt;OrderResponse&gt;(\n      uri = \"/orders\",\n      body = CreateOrderRequest(items = listOf(\"item1\", \"item2\")).some(),\n      headers = mapOf(\"X-Request-ID\" to \"12345\"),\n      token = \"jwt-token\".some()\n    ) { order -&gt;\n      order.id shouldNotBe null\n      order.status shouldBe \"CREATED\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#put-requests","title":"PUT Requests","text":"<p>Update operations with PUT:</p> <pre><code>TestSystem.validate {\n  http {\n    // PUT with response body\n    putAndExpectJson&lt;UserResponse&gt;(\"/users/123\") {\n      UpdateUserRequest(name = \"Jane Doe\", email = \"jane@example.com\")\n    } { user -&gt;\n      user.name shouldBe \"Jane Doe\"\n      user.email shouldBe \"jane@example.com\"\n    }\n\n    // PUT without response body\n    putAndExpectBodilessResponse(\n      uri = \"/products/123\",\n      body = UpdateProductRequest(name = \"Updated Product\").some()\n    ) { response -&gt;\n      response.status shouldBe 200\n    }\n\n    // PUT with full response access\n    putAndExpectBody&lt;ProductResponse&gt;(\n      uri = \"/products/456\",\n      body = UpdateProductRequest(price = 899.99).some()\n    ) { response -&gt;\n      response.status shouldBe 200\n      response.body().price shouldBe 899.99\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#patch-requests","title":"PATCH Requests","text":"<p>Partial updates with PATCH:</p> <pre><code>TestSystem.validate {\n  http {\n    // PATCH with response body\n    patchAndExpectBody&lt;UserResponse&gt;(\n      uri = \"/users/123\",\n      body = mapOf(\"email\" to \"newemail@example.com\").some()\n    ) { response -&gt;\n      response.status shouldBe 200\n      response.body().email shouldBe \"newemail@example.com\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#delete-requests","title":"DELETE Requests","text":"<p>Delete operations:</p> <pre><code>TestSystem.validate {\n  http {\n    // DELETE without response body\n    deleteAndExpectBodilessResponse(\"/users/123\") { response -&gt;\n      response.status shouldBe 204\n    }\n\n    // DELETE with authentication\n    deleteAndExpectBodilessResponse(\n      uri = \"/products/456\",\n      token = \"jwt-token\".some()\n    ) { response -&gt;\n      response.status shouldBe 200\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#file-upload-with-multipart","title":"File Upload with Multipart","text":"<p>Upload files using multipart form data:</p> <pre><code>TestSystem.validate {\n  http {\n    postMultipartAndExpectResponse&lt;UploadResponse&gt;(\n      uri = \"/products/import\",\n      body = listOf(\n        StoveMultiPartContent.Text(\"productName\", \"Laptop\"),\n        StoveMultiPartContent.Text(\"description\", \"A powerful laptop\"),\n        StoveMultiPartContent.File(\n          param = \"file\",\n          fileName = \"products.csv\",\n          content = csvBytes,\n          contentType = MediaType.APPLICATION_OCTET_STREAM_VALUE\n        )\n      )\n    ) { response -&gt;\n      response.status shouldBe 200\n      response.body().uploadedFiles.size shouldBe 1\n      response.body().message shouldContain \"products.csv\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#advanced-using-ktor-client-directly","title":"Advanced: Using Ktor Client Directly","text":"<p>For advanced scenarios, access the underlying Ktor HttpClient:</p> <pre><code>TestSystem.validate {\n  http {\n    client { baseUrl -&gt;\n      // Direct access to Ktor HttpClient\n      val response = get {\n        url(baseUrl.buildString() + \"/custom-endpoint\")\n        header(\"Custom-Header\", \"value\")\n      }\n      println(response.status)\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#complete-example","title":"Complete Example","text":"<p>Here's a complete CRUD test example:</p> <pre><code>test(\"should perform CRUD operations on products\") {\n  TestSystem.validate {\n    var productId: Long? = null\n\n    // CREATE\n    http {\n      postAndExpectBody&lt;ProductResponse&gt;(\n        uri = \"/products\",\n        body = CreateProductRequest(name = \"Laptop\", price = 999.99, categoryId = 1).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        productId = response.body().id\n        response.body().name shouldBe \"Laptop\"\n      }\n    }\n\n    // READ\n    http {\n      get&lt;ProductResponse&gt;(\"/products/$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldBe \"Laptop\"\n        product.price shouldBe 999.99\n      }\n    }\n\n    // UPDATE\n    http {\n      putAndExpectJson&lt;ProductResponse&gt;(\"/products/$productId\") {\n        UpdateProductRequest(price = 899.99)\n      } { product -&gt;\n        product.price shouldBe 899.99\n      }\n    }\n\n    // DELETE\n    http {\n      deleteAndExpectBodilessResponse(\"/products/$productId\") { response -&gt;\n        response.status shouldBe 204\n      }\n    }\n\n    // Verify deletion\n    http {\n      getResponse&lt;ErrorResponse&gt;(\"/products/$productId\") { response -&gt;\n        response.status shouldBe 404\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#integration-with-other-components","title":"Integration with Other Components","text":""},{"location":"Components/05-http/#http-database","title":"HTTP + Database","text":"<pre><code>TestSystem.validate {\n  // Create via API and capture user ID\n  var userId: Long = 0\n  http {\n    postAndExpectBody&lt;UserResponse&gt;(\"/users\", body = CreateUserRequest(name = \"John\").some()) { response -&gt;\n      userId = response.body().id\n    }\n  }\n\n  // Verify in database\n  postgresql {\n    shouldQuery(\n      query = \"SELECT * FROM users WHERE id = $userId\",\n      mapper = { row -&gt; User(row.long(\"id\"), row.string(\"name\")) }\n    ) { users -&gt;\n      users.size shouldBe 1\n      users.first().name shouldBe \"John\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#http-kafka","title":"HTTP + Kafka","text":"<pre><code>TestSystem.validate {\n  // Trigger event via API\n  http {\n    postAndExpectBodilessResponse(\"/orders\", body = CreateOrderRequest(amount = 100.0).some()) { response -&gt;\n      response.status shouldBe 201\n    }\n  }\n\n  // Verify event was published\n  kafka {\n    shouldBePublished&lt;OrderCreatedEvent&gt;(atLeastIn = 10.seconds) {\n      actual.amount == 100.0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#http-wiremock","title":"HTTP + WireMock","text":"<pre><code>TestSystem.validate {\n  // Mock external service\n  wiremock {\n    mockGet(\n      url = \"/external-api/data\",\n      statusCode = 200,\n      responseBody = ExternalData(id = 1, value = \"test\").some()\n    )\n  }\n\n  // Call your API that depends on external service\n  http {\n    get&lt;ResponseData&gt;(\"/data\") { response -&gt;\n      response.value shouldBe \"test\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/05-http/#error-handling","title":"Error Handling","text":"<pre><code>TestSystem.validate {\n  http {\n    // Test validation errors\n    postAndExpectBody&lt;ValidationErrorResponse&gt;(\"/users\", body = InvalidUserRequest().some()) { response -&gt;\n      response.status shouldBe 400\n      response.body().errors shouldContain \"name is required\"\n    }\n\n    // Test authentication errors\n    getResponse&lt;ErrorResponse&gt;(\"/secure-endpoint\") { response -&gt;\n      response.status shouldBe 401\n    }\n\n    // Test not found\n    getResponse&lt;ErrorResponse&gt;(\"/users/999999\") { response -&gt;\n      response.status shouldBe 404\n    }\n\n    // Test business logic errors\n    postAndExpectBody&lt;ErrorResponse&gt;(\"/products\", body = InvalidProductRequest().some()) { response -&gt;\n      response.status shouldBe 409 // Conflict\n      response.body().message shouldContain \"already exists\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/","title":"Postgresql","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-rdbms-postgres:$version\")\n    }\n</code></pre>"},{"location":"Components/06-postgresql/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    postgresql {\n      PostgresqlSystemOptions {\n        listOf(\n          \"postgresql.host=${it.host}\",\n          \"postgresql.port=${it.port}\",\n          \"postgresql.database=${it.database}\",\n          \"postgresql.username=${it.username}\",\n          \"postgresql.password=${it.password}\"\n        )\n      }\n    }\n  }.run()\n</code></pre>"},{"location":"Components/06-postgresql/#migrations","title":"Migrations","text":"<p>Stove provides a way to run database migrations before tests start:</p> <pre><code>class InitialMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: PostgresSqlMigrationContext) {\n    connection.operations.execute(\n      \"\"\"\n      CREATE TABLE IF NOT EXISTS users (\n        id serial PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        email VARCHAR(100) NOT NULL UNIQUE,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      );\n      \"\"\".trimIndent()\n    )\n  }\n}\n</code></pre> <p>Register migrations in your TestSystem configuration:</p> <pre><code>TestSystem()\n  .with {\n    postgresql {\n      PostgresqlOptions(\n        databaseName = \"testing\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      ).migrations {\n        register&lt;InitialMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/06-postgresql/#usage","title":"Usage","text":""},{"location":"Components/06-postgresql/#executing-sql","title":"Executing SQL","text":"<p>Execute DDL and DML statements:</p> <pre><code>TestSystem.validate {\n  postgresql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      DROP TABLE IF EXISTS products;\n      CREATE TABLE IF NOT EXISTS products (\n        id serial PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        price DECIMAL(10, 2) NOT NULL,\n        stock INT DEFAULT 0\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert data\n    shouldExecute(\n      \"\"\"\n      INSERT INTO products (name, price, stock) \n      VALUES ('Laptop', 999.99, 10)\n      \"\"\".trimIndent()\n    )\n\n    // Update data\n    shouldExecute(\"UPDATE products SET stock = 5 WHERE name = 'Laptop'\")\n\n    // Delete data\n    shouldExecute(\"DELETE FROM products WHERE stock = 0\")\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#querying-data","title":"Querying Data","text":"<p>Query data with type-safe mappers:</p> <pre><code>data class Product(\n  val id: Long,\n  val name: String,\n  val price: Double,\n  val stock: Int\n)\n\nTestSystem.validate {\n  postgresql {\n    shouldQuery&lt;Product&gt;(\n      query = \"SELECT * FROM products WHERE price &gt; 500\",\n      mapper = { row -&gt;\n        Product(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          price = row.double(\"price\"),\n          stock = row.int(\"stock\")\n        )\n      }\n    ) { products -&gt;\n      products.size shouldBeGreaterThan 0\n      products.all { it.price &gt; 500 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#query-with-parameters","title":"Query with Parameters","text":"<p>Use parameterized queries for safety:</p> <pre><code>TestSystem.validate {\n  postgresql {\n    val minPrice = 100.0\n    shouldQuery&lt;Product&gt;(\n      query = \"SELECT * FROM products WHERE price &gt;= ?\",\n      mapper = { row -&gt;\n        Product(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          price = row.double(\"price\"),\n          stock = row.int(\"stock\")\n        )\n      }\n    ) { products -&gt;\n      products.all { it.price &gt;= minPrice } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#working-with-nullable-fields","title":"Working with Nullable Fields","text":"<p>Handle nullable columns:</p> <pre><code>data class User(\n  val id: Long,\n  val name: String,\n  val email: String?,\n  val phone: String?\n)\n\nTestSystem.validate {\n  postgresql {\n    shouldQuery&lt;User&gt;(\n      query = \"SELECT * FROM users\",\n      mapper = { row -&gt;\n        User(\n          id = row.long(\"id\"),\n          name = row.string(\"name\"),\n          email = row.stringOrNull(\"email\"),\n          phone = row.stringOrNull(\"phone\")\n        )\n      }\n    ) { users -&gt;\n      users.size shouldBeGreaterThan 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#complex-queries","title":"Complex Queries","text":"<p>Execute joins and aggregations:</p> <pre><code>data class OrderSummary(\n  val userId: Long,\n  val userName: String,\n  val totalOrders: Int,\n  val totalAmount: Double\n)\n\nTestSystem.validate {\n  postgresql {\n    shouldQuery&lt;OrderSummary&gt;(\n      query = \"\"\"\n        SELECT \n          u.id as user_id,\n          u.name as user_name,\n          COUNT(o.id) as total_orders,\n          SUM(o.amount) as total_amount\n        FROM users u\n        LEFT JOIN orders o ON u.id = o.user_id\n        GROUP BY u.id, u.name\n        HAVING COUNT(o.id) &gt; 0\n      \"\"\".trimIndent(),\n      mapper = { row -&gt;\n        OrderSummary(\n          userId = row.long(\"user_id\"),\n          userName = row.string(\"user_name\"),\n          totalOrders = row.int(\"total_orders\"),\n          totalAmount = row.double(\"total_amount\")\n        )\n      }\n    ) { summaries -&gt;\n      summaries.all { it.totalOrders &gt; 0 } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Test failure scenarios:</p> <pre><code>TestSystem.validate {\n  postgresql {\n    // Database is running\n    shouldQuery&lt;Product&gt;(\n      \"SELECT COUNT(*) as count FROM products\",\n      mapper = { row -&gt; row.int(\"count\") }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n\n    // Pause the database\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the database\n    unpause()\n\n    // Verify recovery\n    shouldQuery&lt;Product&gt;(\n      \"SELECT COUNT(*) as count FROM products\",\n      mapper = { row -&gt; row.int(\"count\") }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test:</p> <pre><code>test(\"should create user via API and verify in database\") {\n  TestSystem.validate {\n    val userName = \"John Doe\"\n    val userEmail = \"john@example.com\"\n\n    // Create user via API\n    http {\n      postAndExpectBody&lt;UserResponse&gt;(\n        uri = \"/users\",\n        body = CreateUserRequest(name = userName, email = userEmail).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().name shouldBe userName\n      }\n    }\n\n    // Verify in PostgreSQL\n    postgresql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM users WHERE email = ?\",\n        mapper = { row -&gt;\n          User(\n            id = row.long(\"id\"),\n            name = row.string(\"name\"),\n            email = row.string(\"email\")\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().name shouldBe userName\n        users.first().email shouldBe userEmail\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;UserCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.name == userName &amp;&amp;\n        actual.email == userEmail\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#integration-with-application","title":"Integration with Application","text":"<p>Use the bridge to access application components:</p> <pre><code>test(\"should use repository to save user\") {\n  TestSystem.validate {\n    val user = User(id = 1L, name = \"Jane Doe\", email = \"jane@example.com\")\n\n    // Use application's repository\n    using&lt;UserRepository&gt; {\n      save(user)\n    }\n\n    // Verify in database\n    postgresql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM users WHERE id = ?\",\n        mapper = { row -&gt;\n          User(\n            id = row.long(\"id\"),\n            name = row.string(\"name\"),\n            email = row.string(\"email\")\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().name shouldBe \"Jane Doe\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#batch-operations","title":"Batch Operations","text":"<p>Execute multiple operations:</p> <pre><code>TestSystem.validate {\n  postgresql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE IF NOT EXISTS categories (\n        id serial PRIMARY KEY,\n        name VARCHAR(50) NOT NULL\n      );\n      CREATE TABLE IF NOT EXISTS products (\n        id serial PRIMARY KEY,\n        name VARCHAR(100) NOT NULL,\n        category_id INT REFERENCES categories(id)\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert categories\n    listOf(\"Electronics\", \"Books\", \"Clothing\").forEach { category -&gt;\n      shouldExecute(\"INSERT INTO categories (name) VALUES ('$category')\")\n    }\n\n    // Verify all inserted\n    shouldQuery&lt;String&gt;(\n      \"SELECT name FROM categories\",\n      mapper = { it.string(\"name\") }\n    ) { categories -&gt;\n      categories.size shouldBe 3\n      categories shouldContain \"Electronics\"\n      categories shouldContain \"Books\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#advanced-direct-sql-operations","title":"Advanced: Direct SQL Operations","text":"<p>Access SQL operations directly for advanced use cases:</p> <pre><code>TestSystem.validate {\n  postgresql {\n    val ops = operations()\n\n    // Execute with parameters\n    ops.execute(\n      \"INSERT INTO users (name, email) VALUES (?, ?)\",\n      Parameter(\"name\", \"Alice\"),\n      Parameter(\"email\", \"alice@example.com\")\n    )\n\n    // Custom select operation\n    val users = ops.select(\"SELECT * FROM users\") { row -&gt;\n      User(\n        id = row.long(\"id\"),\n        name = row.string(\"name\"),\n        email = row.string(\"email\")\n      )\n    }\n\n    users.size shouldBeGreaterThan 0\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#multiple-databases","title":"Multiple Databases","text":"<p>In production, your application might connect to multiple PostgreSQL instances (e.g., separate databases for users, orders, analytics). With Stove, you can achieve the same behavior using a single PostgreSQL container by creating multiple databases through migrations.</p>"},{"location":"Components/06-postgresql/#the-pattern","title":"The Pattern","text":"<ol> <li>Create additional databases in migrations</li> <li>Expose all database configurations to your application</li> <li>Your application connects to each database as if they were separate instances</li> </ol>"},{"location":"Components/06-postgresql/#implementation","title":"Implementation","text":""},{"location":"Components/06-postgresql/#step-1-create-a-multi-database-migration","title":"Step 1: Create a Multi-Database Migration","text":"<pre><code>class CreateDatabasesMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 0  // Run first!\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        // Create additional databases\n        // Note: You're connected to the default database, create others from here\n        connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS users_db\")\n        connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS orders_db\")\n        connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS analytics_db\")\n    }\n}\n\nclass UsersDbMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 1\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        // This runs on the default database\n        // For users_db schema, you'll set it up via application or separate connection\n        connection.operations.execute(\n            \"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(100),\n                email VARCHAR(100)\n            )\n            \"\"\".trimIndent()\n        )\n    }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#step-2-configure-testsystem-with-multiple-database-urls","title":"Step 2: Configure TestSystem with Multiple Database URLs","text":"<pre><code>TestSystem()\n    .with {\n        postgresql {\n            PostgresqlOptions(\n                databaseName = \"main_db\",  // Default/main database\n                configureExposedConfiguration = { cfg -&gt;\n                    // Expose multiple database URLs to the application\n                    // All databases are on the same host:port, just different DB names\n                    listOf(\n                        // Main database\n                        \"spring.datasource.url=${cfg.jdbcUrl}\",\n                        \"spring.datasource.username=${cfg.username}\",\n                        \"spring.datasource.password=${cfg.password}\",\n\n                        // Users database (same host, different database name)\n                        \"users.datasource.url=jdbc:postgresql://${cfg.host}:${cfg.port}/users_db\",\n                        \"users.datasource.username=${cfg.username}\",\n                        \"users.datasource.password=${cfg.password}\",\n\n                        // Orders database\n                        \"orders.datasource.url=jdbc:postgresql://${cfg.host}:${cfg.port}/orders_db\",\n                        \"orders.datasource.username=${cfg.username}\",\n                        \"orders.datasource.password=${cfg.password}\",\n\n                        // Analytics database\n                        \"analytics.datasource.url=jdbc:postgresql://${cfg.host}:${cfg.port}/analytics_db\",\n                        \"analytics.datasource.username=${cfg.username}\",\n                        \"analytics.datasource.password=${cfg.password}\"\n                    )\n                }\n            ).migrations {\n                register&lt;CreateDatabasesMigration&gt;()\n                register&lt;UsersDbMigration&gt;()\n            }\n        }\n    }\n    .run()\n</code></pre>"},{"location":"Components/06-postgresql/#step-3-application-configuration","title":"Step 3: Application Configuration","text":"<p>Your application should read these separate datasource configurations:</p> <pre><code>// Spring Boot example with multiple DataSources\n@Configuration\nclass DataSourceConfig {\n\n    @Bean\n    @Primary\n    @ConfigurationProperties(\"spring.datasource\")\n    fun mainDataSource(): DataSource = DataSourceBuilder.create().build()\n\n    @Bean\n    @ConfigurationProperties(\"users.datasource\")\n    fun usersDataSource(): DataSource = DataSourceBuilder.create().build()\n\n    @Bean\n    @ConfigurationProperties(\"orders.datasource\")\n    fun ordersDataSource(): DataSource = DataSourceBuilder.create().build()\n\n    @Bean\n    @ConfigurationProperties(\"analytics.datasource\")\n    fun analyticsDataSource(): DataSource = DataSourceBuilder.create().build()\n}\n</code></pre>"},{"location":"Components/06-postgresql/#complete-example_1","title":"Complete Example","text":"<pre><code>object DatabaseNames {\n    const val USERS = \"users_db\"\n    const val ORDERS = \"orders_db\"\n    const val ANALYTICS = \"analytics_db\"\n}\n\nclass SetupDatabasesMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 0\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        listOf(DatabaseNames.USERS, DatabaseNames.ORDERS, DatabaseNames.ANALYTICS).forEach { db -&gt;\n            connection.operations.execute(\"CREATE DATABASE IF NOT EXISTS $db\")\n        }\n    }\n}\n\n// Test configuration\nTestSystem()\n    .with {\n        postgresql {\n            PostgresqlOptions(\n                databaseName = \"main\",\n                configureExposedConfiguration = { cfg -&gt;\n                    val baseUrl = \"jdbc:postgresql://${cfg.host}:${cfg.port}\"\n                    listOf(\n                        \"db.users.url=$baseUrl/${DatabaseNames.USERS}\",\n                        \"db.users.username=${cfg.username}\",\n                        \"db.users.password=${cfg.password}\",\n\n                        \"db.orders.url=$baseUrl/${DatabaseNames.ORDERS}\",\n                        \"db.orders.username=${cfg.username}\",\n                        \"db.orders.password=${cfg.password}\",\n\n                        \"db.analytics.url=$baseUrl/${DatabaseNames.ANALYTICS}\",\n                        \"db.analytics.username=${cfg.username}\",\n                        \"db.analytics.password=${cfg.password}\"\n                    )\n                }\n            ).migrations {\n                register&lt;SetupDatabasesMigration&gt;()\n            }\n        }\n        springBoot(\n            runner = { params -&gt; myApp.run(params) }\n        )\n    }\n    .run()\n\n// In tests\ntest(\"should save user and create order in separate databases\") {\n    TestSystem.validate {\n        // Create user (goes to users_db)\n        http {\n            postAndExpectBodilessResponse(\"/users\", body = CreateUserRequest(...).some()) {\n                it.status shouldBe 201\n            }\n        }\n\n        // Create order (goes to orders_db)\n        http {\n            postAndExpectBodilessResponse(\"/orders\", body = CreateOrderRequest(...).some()) {\n                it.status shouldBe 201\n            }\n        }\n\n        // Verify using application repositories (each connects to its own DB)\n        using&lt;UserRepository, OrderRepository&gt; { userRepo, orderRepo -&gt;\n            userRepo.count() shouldBe 1\n            orderRepo.count() shouldBe 1\n        }\n    }\n}\n</code></pre>"},{"location":"Components/06-postgresql/#with-provided-instances","title":"With Provided Instances","text":"<p>The same pattern works with provided PostgreSQL instances:</p> <pre><code>TestSystem()\n    .with {\n        postgresql {\n            PostgresqlOptions.provided(\n                jdbcUrl = \"jdbc:postgresql://shared-postgres:5432/main_db\",\n                host = \"shared-postgres\",\n                port = 5432,\n                databaseName = \"main_db\",\n                username = \"postgres\",\n                password = \"postgres\",\n                runMigrations = true,  // Creates additional databases\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"db.users.url=jdbc:postgresql://${cfg.host}:${cfg.port}/users_db\",\n                        \"db.orders.url=jdbc:postgresql://${cfg.host}:${cfg.port}/orders_db\",\n                        // ... credentials\n                    )\n                }\n            ).migrations {\n                register&lt;SetupDatabasesMigration&gt;()\n            }\n        }\n    }\n</code></pre> <p>Production vs Test</p> <p>In production, these might be completely separate PostgreSQL instances (even in different regions). In tests, they're all in one container but behave identically from your application's perspective.</p>"},{"location":"Components/07-mongodb/","title":"MongoDB","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-mongodb:$version\")\n    }\n</code></pre>"},{"location":"Components/07-mongodb/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>mongodb</code> function. This function configures the MongoDB Docker container that is going to be started.</p> <pre><code>TestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#container-options","title":"Container Options","text":"<p>Customize the MongoDB container:</p> <pre><code>TestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        container = MongoContainerOptions(\n          registry = \"docker.io\",\n          image = \"mongo\",\n          tag = \"6.0\",\n          containerFn = { container -&gt;\n            // Additional container configuration\n            container.withEnv(\"MONGO_INITDB_DATABASE\", \"testdb\")\n          }\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#database-options","title":"Database Options","text":"<p>Configure the default database and collection:</p> <pre><code>TestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        databaseOptions = DatabaseOptions(\n          default = DatabaseOptions.DefaultDatabase(\n            name = \"myDatabase\",\n            collection = \"myCollection\"\n          )\n        ),\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#custom-client-configuration","title":"Custom Client Configuration","text":"<p>Customize the MongoDB client settings:</p> <pre><code>TestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        configureClient = { settings -&gt;\n          settings.applyToConnectionPoolSettings { pool -&gt;\n            pool.maxSize(10)\n            pool.minSize(1)\n          }\n          settings.applyToSocketSettings { socket -&gt;\n            socket.connectTimeout(10, TimeUnit.SECONDS)\n            socket.readTimeout(30, TimeUnit.SECONDS)\n          }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\"mongodb.uri=${cfg.connectionString}\")\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#custom-serialization","title":"Custom Serialization","text":"<p>Configure custom serialization for your documents:</p> <pre><code>TestSystem()\n  .with {\n    mongodb {\n      val customSerde = StoveSerde.jackson.anyJsonStringSerde(\n        StoveSerde.jackson.byConfiguring {\n          disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n          enable(MapperFeature.DEFAULT_VIEW_INCLUSION)\n          registerModule(JavaTimeModule())\n          registerModule(KotlinModule.Builder().build())\n        }\n      )\n\n      MongodbSystemOptions(\n        serde = customSerde,\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\"mongodb.uri=${cfg.connectionString}\")\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#migrations","title":"Migrations","text":"<p>Stove provides a way to run migrations before tests start:</p> <pre><code>class CreateIndexesMigration : DatabaseMigration&lt;MongodbMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: MongodbMigrationContext) {\n    val db = connection.client.getDatabase(connection.options.databaseOptions.default.name)\n\n    // Create indexes\n    db.getCollection&lt;Document&gt;(\"users\").createIndex(\n      Indexes.ascending(\"email\"),\n      IndexOptions().unique(true)\n    )\n\n    db.getCollection&lt;Document&gt;(\"products\").createIndex(\n      Indexes.compoundIndex(\n        Indexes.ascending(\"category\"),\n        Indexes.descending(\"createdAt\")\n      )\n    )\n  }\n}\n</code></pre> <p>Register migrations in your TestSystem configuration:</p> <pre><code>TestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\"mongodb.uri=${cfg.connectionString}\")\n        }\n      ).migrations {\n        register&lt;CreateIndexesMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#usage","title":"Usage","text":""},{"location":"Components/07-mongodb/#saving-documents","title":"Saving Documents","text":"<p>Save documents to MongoDB collections:</p> <pre><code>data class User(\n  val id: String,\n  val name: String,\n  val email: String,\n  val age: Int\n)\n\nTestSystem.validate {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // Save to default collection\n    save(\n      instance = User(id = userId, name = \"John Doe\", email = \"john@example.com\", age = 30),\n      objectId = userId\n    )\n\n    // Save to specific collection\n    save(\n      instance = User(id = userId, name = \"Jane Doe\", email = \"jane@example.com\", age = 28),\n      objectId = userId,\n      collection = \"users\"\n    )\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#getting-documents","title":"Getting Documents","text":"<p>Retrieve and validate documents by ObjectId:</p> <pre><code>TestSystem.validate {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // First save the document\n    save(\n      instance = User(id = userId, name = \"John Doe\", email = \"john@example.com\", age = 30),\n      objectId = userId,\n      collection = \"users\"\n    )\n\n    // Get from specific collection\n    shouldGet&lt;User&gt;(objectId = userId, collection = \"users\") { user -&gt;\n      user.id shouldBe userId\n      user.name shouldBe \"John Doe\"\n      user.email shouldBe \"john@example.com\"\n      user.age shouldBe 30\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#checking-non-existence","title":"Checking Non-Existence","text":"<p>Verify that documents don't exist:</p> <pre><code>TestSystem.validate {\n  mongodb {\n    val nonExistentId = ObjectId().toHexString()\n\n    // Check default collection\n    shouldNotExist(objectId = nonExistentId)\n\n    // Check specific collection\n    shouldNotExist(objectId = nonExistentId, collection = \"users\")\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#deleting-documents","title":"Deleting Documents","text":"<p>Delete documents and verify deletion:</p> <pre><code>TestSystem.validate {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // Save a document\n    save(\n      instance = User(id = userId, name = \"John Doe\", email = \"john@example.com\", age = 30),\n      objectId = userId,\n      collection = \"users\"\n    )\n\n    // Delete it\n    shouldDelete(objectId = userId, collection = \"users\")\n\n    // Verify deletion\n    shouldNotExist(objectId = userId, collection = \"users\")\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#querying-documents","title":"Querying Documents","text":"<p>Query documents using MongoDB query syntax:</p> <pre><code>TestSystem.validate {\n  mongodb {\n    // Setup test data\n    listOf(\n      User(id = ObjectId().toHexString(), name = \"Alice\", email = \"alice@example.com\", age = 25),\n      User(id = ObjectId().toHexString(), name = \"Bob\", email = \"bob@example.com\", age = 35),\n      User(id = ObjectId().toHexString(), name = \"Charlie\", email = \"charlie@example.com\", age = 28)\n    ).forEach { user -&gt;\n      save(instance = user, objectId = ObjectId().toHexString(), collection = \"users\")\n    }\n\n    // Simple query\n    shouldQuery&lt;User&gt;(\n      query = \"\"\"{ \"age\": { \"${'$'}gte\": 30 } }\"\"\",\n      collection = \"users\"\n    ) { users -&gt;\n      users.size shouldBe 1\n      users.first().name shouldBe \"Bob\"\n    }\n\n    // Query with multiple conditions\n    shouldQuery&lt;User&gt;(\n      query = \"\"\"\n        {\n          \"${'$'}and\": [\n            { \"age\": { \"${'$'}gte\": 25 } },\n            { \"age\": { \"${'$'}lte\": 30 } }\n          ]\n        }\n      \"\"\".trimIndent(),\n      collection = \"users\"\n    ) { users -&gt;\n      users.size shouldBe 2\n      users.map { it.name } shouldContainAll listOf(\"Alice\", \"Charlie\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#accessing-the-client-directly","title":"Accessing the Client Directly","text":"<p>For advanced operations, access the MongoDB client:</p> <pre><code>TestSystem.validate {\n  mongodb {\n    val mongoClient = client()\n\n    // Access the database\n    val db = mongoClient.getDatabase(\"myDatabase\")\n\n    // List collections\n    val collections = db.listCollectionNames().toList()\n\n    // Perform custom operations\n    db.getCollection&lt;Document&gt;(\"users\")\n      .find()\n      .limit(10)\n      .toList()\n      .also { documents -&gt;\n        documents.size shouldBeLessThanOrEqual 10\n      }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Control the MongoDB container for testing failure scenarios:</p> <pre><code>TestSystem.validate {\n  mongodb {\n    val userId = ObjectId().toHexString()\n\n    // MongoDB is running\n    save(\n      instance = User(id = userId, name = \"John\", email = \"john@example.com\", age = 30),\n      objectId = userId,\n      collection = \"users\"\n    )\n\n    // Pause the container\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the container\n    unpause()\n\n    // Verify recovery\n    shouldGet&lt;User&gt;(objectId = userId, collection = \"users\") { user -&gt;\n      user.name shouldBe \"John\"\n    }\n  }\n}\n</code></pre> <p>Warning</p> <p><code>pause()</code>, <code>unpause()</code>, and <code>inspect()</code> operations are not supported when using a provided instance.</p>"},{"location":"Components/07-mongodb/#container-inspection","title":"Container Inspection","text":"<p>Inspect the MongoDB container:</p> <pre><code>TestSystem.validate {\n  mongodb {\n    val info = inspect()\n    info?.let {\n      println(\"Container ID: ${it.containerId}\")\n      println(\"Network: ${it.network}\")\n      println(\"IP Address: ${it.ipAddress}\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test combining HTTP, MongoDB, and Kafka:</p> <pre><code>data class Product(\n  val id: String,\n  val name: String,\n  val description: String,\n  val price: Double,\n  val categoryId: Int,\n  val stock: Int,\n  val createdAt: Instant = Instant.now()\n)\n\ntest(\"should create product and store in mongodb\") {\n  TestSystem.validate {\n    val productId = ObjectId().toHexString()\n    val productName = \"Gaming Laptop\"\n    val categoryId = 1\n\n    // Mock external service\n    wiremock {\n      mockGet(\n        url = \"/categories/$categoryId\",\n        statusCode = 200,\n        responseBody = Category(id = categoryId, name = \"Electronics\", active = true).some()\n      )\n    }\n\n    // Create product via API\n    http {\n      postAndExpectBody&lt;ProductResponse&gt;(\n        uri = \"/products\",\n        body = ProductCreateRequest(\n          name = productName,\n          description = \"High-performance gaming laptop\",\n          price = 1299.99,\n          categoryId = categoryId,\n          stock = 10\n        ).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().id shouldNotBe null\n      }\n    }\n\n    // Verify stored in MongoDB\n    mongodb {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"{ \"name\": \"$productName\" }\"\"\",\n        collection = \"products\"\n      ) { products -&gt;\n        products.size shouldBe 1\n        products.first().also { product -&gt;\n          product.name shouldBe productName\n          product.price shouldBe 1299.99\n          product.categoryId shouldBe categoryId\n          product.stock shouldBe 10\n        }\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;ProductCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.name == productName &amp;&amp;\n        actual.price == 1299.99\n      }\n    }\n\n    // Update product stock via API\n    http {\n      putAndExpectBodilessResponse(\n        uri = \"/products/$productId/stock\",\n        body = UpdateStockRequest(quantity = -2).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify stock updated in MongoDB\n    mongodb {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"{ \"name\": \"$productName\" }\"\"\",\n        collection = \"products\"\n      ) { products -&gt;\n        products.first().stock shouldBe 8\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#integration-with-application","title":"Integration with Application","text":"<p>Verify application behavior using the bridge:</p> <pre><code>test(\"should use repository to save product\") {\n  TestSystem.validate {\n    val productId = ObjectId().toHexString()\n    val product = Product(\n      id = productId,\n      name = \"Test Product\",\n      description = \"Test Description\",\n      price = 99.99,\n      categoryId = 1,\n      stock = 5\n    )\n\n    // Use application's repository\n    using&lt;ProductRepository&gt; {\n      save(product)\n    }\n\n    // Verify in MongoDB\n    mongodb {\n      shouldQuery&lt;Product&gt;(\n        query = \"\"\"{ \"name\": \"Test Product\" }\"\"\",\n        collection = \"products\"\n      ) { products -&gt;\n        products.size shouldBe 1\n        products.first().id shouldBe productId\n        products.first().price shouldBe 99.99\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#advanced-operations","title":"Advanced Operations","text":""},{"location":"Components/07-mongodb/#aggregation-queries","title":"Aggregation Queries","text":"<pre><code>TestSystem.validate {\n  mongodb {\n    val mongoClient = client()\n    val db = mongoClient.getDatabase(\"myDatabase\")\n\n    // Aggregation pipeline\n    val pipeline = listOf(\n      Aggregates.match(Filters.gte(\"price\", 100)),\n      Aggregates.group(\"${'$'}categoryId\", \n        Accumulators.sum(\"totalProducts\", 1),\n        Accumulators.avg(\"avgPrice\", \"${'$'}price\")\n      ),\n      Aggregates.sort(Sorts.descending(\"totalProducts\"))\n    )\n\n    db.getCollection&lt;Document&gt;(\"products\")\n      .aggregate(pipeline)\n      .toList()\n      .also { results -&gt;\n        results.size shouldBeGreaterThan 0\n        // Each result has categoryId, totalProducts, and avgPrice\n      }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#bulk-operations","title":"Bulk Operations","text":"<pre><code>TestSystem.validate {\n  mongodb {\n    val mongoClient = client()\n    val db = mongoClient.getDatabase(\"myDatabase\")\n    val collection = db.getCollection&lt;Document&gt;(\"users\")\n\n    // Bulk insert\n    val users = (1..100).map { i -&gt;\n      Document()\n        .append(\"_id\", ObjectId())\n        .append(\"name\", \"User $i\")\n        .append(\"email\", \"user$i@example.com\")\n        .append(\"age\", 20 + (i % 50))\n    }\n\n    collection.insertMany(users)\n\n    // Bulk update\n    collection.updateMany(\n      Filters.gte(\"age\", 40),\n      Updates.set(\"status\", \"senior\")\n    )\n\n    // Verify\n    val seniorCount = collection.countDocuments(Filters.eq(\"status\", \"senior\"))\n    seniorCount shouldBeGreaterThan 0\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#transaction-support","title":"Transaction Support","text":"<pre><code>TestSystem.validate {\n  mongodb {\n    val mongoClient = client()\n\n    mongoClient.startSession().use { session -&gt;\n      session.startTransaction()\n      try {\n        val db = mongoClient.getDatabase(\"myDatabase\")\n\n        // Perform operations in transaction\n        db.getCollection&lt;Document&gt;(\"accounts\")\n          .updateOne(\n            session,\n            Filters.eq(\"accountId\", \"sender\"),\n            Updates.inc(\"balance\", -100.0)\n          )\n\n        db.getCollection&lt;Document&gt;(\"accounts\")\n          .updateOne(\n            session,\n            Filters.eq(\"accountId\", \"receiver\"),\n            Updates.inc(\"balance\", 100.0)\n          )\n\n        session.commitTransaction()\n      } catch (e: Exception) {\n        session.abortTransaction()\n        throw e\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#working-with-indexes","title":"Working with Indexes","text":"<pre><code>TestSystem.validate {\n  mongodb {\n    val mongoClient = client()\n    val db = mongoClient.getDatabase(\"myDatabase\")\n    val collection = db.getCollection&lt;Document&gt;(\"users\")\n\n    // Create unique index\n    collection.createIndex(\n      Indexes.ascending(\"email\"),\n      IndexOptions().unique(true)\n    )\n\n    // Create compound index\n    collection.createIndex(\n      Indexes.compoundIndex(\n        Indexes.ascending(\"status\"),\n        Indexes.descending(\"createdAt\")\n      )\n    )\n\n    // Create text index for search\n    collection.createIndex(\n      Indexes.text(\"name\")\n    )\n\n    // List indexes\n    collection.listIndexes().toList().also { indexes -&gt;\n      indexes.size shouldBeGreaterThan 1\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#provided-instance-external-mongodb","title":"Provided Instance (External MongoDB)","text":"<p>For CI/CD pipelines or shared infrastructure:</p> <pre><code>TestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions.provided(\n        connectionString = System.getenv(\"MONGODB_URI\") ?: \"mongodb://localhost:27017\",\n        host = System.getenv(\"MONGODB_HOST\") ?: \"localhost\",\n        port = System.getenv(\"MONGODB_PORT\")?.toInt() ?: 27017,\n        cleanup = { client -&gt;\n          // Clean up test data after tests\n          client.getDatabase(\"testdb\").drop()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#error-handling","title":"Error Handling","text":"<pre><code>TestSystem.validate {\n  mongodb {\n    // Document not found\n    val nonExistentId = ObjectId().toHexString()\n    shouldNotExist(objectId = nonExistentId, collection = \"users\")\n\n    // Attempting to get non-existent document throws exception\n    assertThrows&lt;NoSuchElementException&gt; {\n      shouldGet&lt;User&gt;(objectId = nonExistentId, collection = \"users\") { }\n    }\n\n    // Verify existence check on existing document\n    val existingId = ObjectId().toHexString()\n    save(\n      instance = User(id = existingId, name = \"Existing\", email = \"existing@example.com\", age = 25),\n      objectId = existingId,\n      collection = \"users\"\n    )\n\n    assertThrows&lt;AssertionError&gt; {\n      shouldNotExist(objectId = existingId, collection = \"users\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/#working-with-objectid","title":"Working with ObjectId","text":"<p>MongoDB uses <code>ObjectId</code> as the default identifier. Stove handles this transparently:</p> <pre><code>data class UserWithStringId(\n  val id: String, // String representation of ObjectId\n  val name: String,\n  val email: String\n)\n\nTestSystem.validate {\n  mongodb {\n    // Generate ObjectId\n    val objectId = ObjectId()\n    val stringId = objectId.toHexString()\n\n    // Save with string ID\n    save(\n      instance = UserWithStringId(id = stringId, name = \"Test\", email = \"test@example.com\"),\n      objectId = stringId,\n      collection = \"users\"\n    )\n\n    // Retrieve using string ID\n    shouldGet&lt;UserWithStringId&gt;(objectId = stringId, collection = \"users\") { user -&gt;\n      user.id shouldBe stringId\n      user.name shouldBe \"Test\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/","title":"Microsoft SQL Server (MSSQL)","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-rdbms-mssql:$version\")\n    }\n</code></pre>"},{"location":"Components/08-mssql/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>mssql</code> function. This function configures the MSSQL Docker container that is going to be started.</p> <pre><code>TestSystem()\n  .with {\n    mssql {\n      MsSqlOptions(\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#container-options","title":"Container Options","text":"<p>Customize the MSSQL container:</p> <pre><code>TestSystem()\n  .with {\n    mssql {\n      MsSqlOptions(\n        container = MsSqlContainerOptions(\n          registry = \"mcr.microsoft.com/\",\n          image = \"mssql/server\",\n          tag = \"2019-latest\",\n          containerFn = { container -&gt;\n            container.withEnv(\"ACCEPT_EULA\", \"Y\")\n          }\n        ),\n        applicationName = \"stove-tests\",\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#migrations","title":"Migrations","text":"<p>Stove provides a way to run database migrations before tests start:</p> <pre><code>class InitialMigration : DatabaseMigration&lt;MsSqlMigrationContext&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: MsSqlMigrationContext) {\n    connection.operations.execute(\n      \"\"\"\n      CREATE TABLE Person (\n        PersonID INT PRIMARY KEY IDENTITY(1,1),\n        LastName VARCHAR(255) NOT NULL,\n        FirstName VARCHAR(255) NOT NULL,\n        Address VARCHAR(255),\n        City VARCHAR(255)\n      );\n      \"\"\".trimIndent()\n    )\n  }\n}\n\nclass CreateOrdersTableMigration : DatabaseMigration&lt;MsSqlMigrationContext&gt; {\n  override val order: Int = 2\n\n  override suspend fun execute(connection: MsSqlMigrationContext) {\n    connection.operations.execute(\n      \"\"\"\n      CREATE TABLE Orders (\n        OrderID INT PRIMARY KEY IDENTITY(1,1),\n        PersonID INT NOT NULL,\n        OrderDate DATETIME DEFAULT GETDATE(),\n        Amount DECIMAL(10, 2),\n        FOREIGN KEY (PersonID) REFERENCES Person(PersonID)\n      );\n      \"\"\".trimIndent()\n    )\n  }\n}\n</code></pre> <p>Register migrations in your TestSystem configuration:</p> <pre><code>TestSystem()\n  .with {\n    mssql {\n      MsSqlOptions(\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      ).migrations {\n        register&lt;InitialMigration&gt;()\n        register&lt;CreateOrdersTableMigration&gt;()\n      }\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#usage","title":"Usage","text":""},{"location":"Components/08-mssql/#executing-sql","title":"Executing SQL","text":"<p>Execute DDL and DML statements:</p> <pre><code>TestSystem.validate {\n  mssql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE Products (\n        ProductID INT PRIMARY KEY IDENTITY(1,1),\n        ProductName NVARCHAR(100) NOT NULL,\n        Price DECIMAL(10, 2) NOT NULL,\n        Stock INT DEFAULT 0,\n        CreatedAt DATETIME DEFAULT GETDATE()\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert data\n    shouldExecute(\n      \"\"\"\n      INSERT INTO Products (ProductName, Price, Stock) \n      VALUES ('Laptop', 999.99, 10)\n      \"\"\".trimIndent()\n    )\n\n    // Update data\n    shouldExecute(\"UPDATE Products SET Stock = 5 WHERE ProductName = 'Laptop'\")\n\n    // Delete data\n    shouldExecute(\"DELETE FROM Products WHERE Stock = 0\")\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#querying-data","title":"Querying Data","text":"<p>Query data with type-safe mappers:</p> <pre><code>data class Person(\n  val personId: Int,\n  val lastName: String,\n  val firstName: String,\n  val address: String?,\n  val city: String?\n)\n\nTestSystem.validate {\n  mssql {\n    // Insert test data\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, Address, City) VALUES ('Doe', 'John', '123 Main St', 'Springfield')\")\n\n    // Query with mapper\n    shouldQuery&lt;Person&gt;(\n      query = \"SELECT * FROM Person\",\n      mapper = { resultSet -&gt;\n        Person(\n          personId = resultSet.getInt(1),\n          lastName = resultSet.getString(2),\n          firstName = resultSet.getString(3),\n          address = resultSet.getString(4),\n          city = resultSet.getString(5)\n        )\n      }\n    ) { result -&gt;\n      result.size shouldBe 1\n      result.first().apply {\n        personId shouldBe 1\n        lastName shouldBe \"Doe\"\n        firstName shouldBe \"John\"\n        address shouldBe \"123 Main St\"\n        city shouldBe \"Springfield\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#using-operations-directly","title":"Using Operations Directly","text":"<p>Access SQL operations directly for advanced use cases:</p> <pre><code>TestSystem.validate {\n  mssql {\n    ops {\n      // Simple select\n      val result = select(\"SELECT 1 AS value\") {\n        it.getInt(1)\n      }\n      result.first() shouldBe 1\n\n      // Execute insert\n      execute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Smith', 'Jane')\")\n\n      // Select with parameters\n      val users = select(\"SELECT * FROM Person WHERE LastName = 'Smith'\") { rs -&gt;\n        Person(\n          personId = rs.getInt(\"PersonID\"),\n          lastName = rs.getString(\"LastName\"),\n          firstName = rs.getString(\"FirstName\"),\n          address = rs.getString(\"Address\"),\n          city = rs.getString(\"City\")\n        )\n      }\n      users.size shouldBeGreaterThan 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#complex-queries","title":"Complex Queries","text":"<p>Execute joins, aggregations, and complex queries:</p> <pre><code>data class OrderSummary(\n  val personId: Int,\n  val personName: String,\n  val totalOrders: Int,\n  val totalAmount: Double\n)\n\nTestSystem.validate {\n  mssql {\n    // Setup test data\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, Address, City) VALUES ('Doe', 'John', '123 Main St', 'NYC')\")\n    shouldExecute(\"INSERT INTO Orders (PersonID, Amount) VALUES (1, 100.00)\")\n    shouldExecute(\"INSERT INTO Orders (PersonID, Amount) VALUES (1, 250.50)\")\n    shouldExecute(\"INSERT INTO Orders (PersonID, Amount) VALUES (1, 75.25)\")\n\n    // Aggregate query\n    shouldQuery&lt;OrderSummary&gt;(\n      query = \"\"\"\n        SELECT \n          p.PersonID,\n          CONCAT(p.FirstName, ' ', p.LastName) AS PersonName,\n          COUNT(o.OrderID) AS TotalOrders,\n          SUM(o.Amount) AS TotalAmount\n        FROM Person p\n        INNER JOIN Orders o ON p.PersonID = o.PersonID\n        GROUP BY p.PersonID, p.FirstName, p.LastName\n        HAVING COUNT(o.OrderID) &gt; 0\n      \"\"\".trimIndent(),\n      mapper = { rs -&gt;\n        OrderSummary(\n          personId = rs.getInt(\"PersonID\"),\n          personName = rs.getString(\"PersonName\"),\n          totalOrders = rs.getInt(\"TotalOrders\"),\n          totalAmount = rs.getDouble(\"TotalAmount\")\n        )\n      }\n    ) { summaries -&gt;\n      summaries.size shouldBe 1\n      summaries.first().apply {\n        personName shouldBe \"John Doe\"\n        totalOrders shouldBe 3\n        totalAmount shouldBe 425.75\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#working-with-nullable-fields","title":"Working with Nullable Fields","text":"<p>Handle nullable columns properly:</p> <pre><code>data class PersonWithNullable(\n  val personId: Int,\n  val firstName: String,\n  val lastName: String,\n  val address: String?,\n  val city: String?,\n  val email: String?\n)\n\nTestSystem.validate {\n  mssql {\n    // Insert with null values\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Solo', 'Han')\")\n\n    shouldQuery&lt;PersonWithNullable&gt;(\n      query = \"SELECT * FROM Person WHERE LastName = 'Solo'\",\n      mapper = { rs -&gt;\n        PersonWithNullable(\n          personId = rs.getInt(\"PersonID\"),\n          firstName = rs.getString(\"FirstName\"),\n          lastName = rs.getString(\"LastName\"),\n          address = rs.getString(\"Address\"), // Can be null\n          city = rs.getString(\"City\"), // Can be null\n          email = rs.getString(\"Email\") // Can be null\n        )\n      }\n    ) { persons -&gt;\n      persons.first().apply {\n        firstName shouldBe \"Han\"\n        lastName shouldBe \"Solo\"\n        address shouldBe null\n        city shouldBe null\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Test failure scenarios:</p> <pre><code>TestSystem.validate {\n  mssql {\n    // Database is running\n    shouldQuery&lt;Int&gt;(\n      \"SELECT COUNT(*) FROM Person\",\n      mapper = { rs -&gt; rs.getInt(1) }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n\n    // Pause the database\n    pause()\n\n    // Your application should handle the failure\n    // ...\n\n    // Unpause the database\n    unpause()\n\n    // Verify recovery\n    shouldQuery&lt;Int&gt;(\n      \"SELECT COUNT(*) FROM Person\",\n      mapper = { rs -&gt; rs.getInt(1) }\n    ) { result -&gt;\n      result.first() shouldBeGreaterThanOrEqual 0\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#complete-example","title":"Complete Example","text":"<p>Here's a complete end-to-end test:</p> <pre><code>data class User(\n  val id: Int,\n  val username: String,\n  val email: String,\n  val createdAt: LocalDateTime\n)\n\ntest(\"should create user via API and verify in database\") {\n  TestSystem.validate {\n    val username = \"johndoe\"\n    val email = \"john@example.com\"\n\n    // Create user via API\n    http {\n      postAndExpectBody&lt;UserResponse&gt;(\n        uri = \"/users\",\n        body = CreateUserRequest(username = username, email = email).some()\n      ) { response -&gt;\n        response.status shouldBe 201\n        response.body().username shouldBe username\n      }\n    }\n\n    // Verify in MSSQL\n    mssql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM Users WHERE Email = '$email'\",\n        mapper = { rs -&gt;\n          User(\n            id = rs.getInt(\"UserID\"),\n            username = rs.getString(\"Username\"),\n            email = rs.getString(\"Email\"),\n            createdAt = rs.getTimestamp(\"CreatedAt\").toLocalDateTime()\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().apply {\n          username shouldBe \"johndoe\"\n          email shouldBe \"john@example.com\"\n        }\n      }\n    }\n\n    // Verify event was published\n    kafka {\n      shouldBePublished&lt;UserCreatedEvent&gt;(atLeastIn = 10.seconds) {\n        actual.username == username &amp;&amp;\n        actual.email == email\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#integration-with-application","title":"Integration with Application","text":"<p>Use the bridge to access application components:</p> <pre><code>test(\"should use repository to save user\") {\n  TestSystem.validate {\n    val user = User(id = 0, username = \"janedoe\", email = \"jane@example.com\", createdAt = LocalDateTime.now())\n\n    // Use application's repository\n    using&lt;UserRepository&gt; {\n      save(user)\n    }\n\n    // Verify in database\n    mssql {\n      shouldQuery&lt;User&gt;(\n        query = \"SELECT * FROM Users WHERE Username = 'janedoe'\",\n        mapper = { rs -&gt;\n          User(\n            id = rs.getInt(\"UserID\"),\n            username = rs.getString(\"Username\"),\n            email = rs.getString(\"Email\"),\n            createdAt = rs.getTimestamp(\"CreatedAt\").toLocalDateTime()\n          )\n        }\n      ) { users -&gt;\n        users.size shouldBe 1\n        users.first().email shouldBe \"jane@example.com\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#batch-operations","title":"Batch Operations","text":"<p>Execute multiple operations:</p> <pre><code>TestSystem.validate {\n  mssql {\n    // Create tables\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE Categories (\n        CategoryID INT PRIMARY KEY IDENTITY(1,1),\n        CategoryName NVARCHAR(50) NOT NULL\n      );\n      CREATE TABLE Products (\n        ProductID INT PRIMARY KEY IDENTITY(1,1),\n        ProductName NVARCHAR(100) NOT NULL,\n        CategoryID INT REFERENCES Categories(CategoryID)\n      );\n      \"\"\".trimIndent()\n    )\n\n    // Insert categories\n    listOf(\"Electronics\", \"Books\", \"Clothing\").forEach { category -&gt;\n      shouldExecute(\"INSERT INTO Categories (CategoryName) VALUES ('$category')\")\n    }\n\n    // Verify all inserted\n    shouldQuery&lt;String&gt;(\n      \"SELECT CategoryName FROM Categories\",\n      mapper = { it.getString(\"CategoryName\") }\n    ) { categories -&gt;\n      categories.size shouldBe 3\n      categories shouldContainAll listOf(\"Electronics\", \"Books\", \"Clothing\")\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#stored-procedures","title":"Stored Procedures","text":"<p>Test stored procedures:</p> <pre><code>TestSystem.validate {\n  mssql {\n    // Create stored procedure\n    shouldExecute(\n      \"\"\"\n      CREATE PROCEDURE GetPersonsByCity\n        @City NVARCHAR(100)\n      AS\n      BEGIN\n        SELECT * FROM Person WHERE City = @City\n      END\n      \"\"\".trimIndent()\n    )\n\n    // Insert test data\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, City) VALUES ('Doe', 'John', 'NYC')\")\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, City) VALUES ('Smith', 'Jane', 'NYC')\")\n    shouldExecute(\"INSERT INTO Person (LastName, FirstName, City) VALUES ('Brown', 'Bob', 'LA')\")\n\n    // Execute stored procedure\n    shouldQuery&lt;Person&gt;(\n      query = \"EXEC GetPersonsByCity @City = 'NYC'\",\n      mapper = { rs -&gt;\n        Person(\n          personId = rs.getInt(\"PersonID\"),\n          lastName = rs.getString(\"LastName\"),\n          firstName = rs.getString(\"FirstName\"),\n          address = rs.getString(\"Address\"),\n          city = rs.getString(\"City\")\n        )\n      }\n    ) { persons -&gt;\n      persons.size shouldBe 2\n      persons.all { it.city == \"NYC\" } shouldBe true\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#transactions","title":"Transactions","text":"<p>Test transaction behavior:</p> <pre><code>TestSystem.validate {\n  mssql {\n    ops {\n      // Start transaction manually via SQL\n      execute(\"BEGIN TRANSACTION\")\n\n      try {\n        execute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Test', 'User1')\")\n        execute(\"INSERT INTO Person (LastName, FirstName) VALUES ('Test', 'User2')\")\n\n        // Commit transaction\n        execute(\"COMMIT TRANSACTION\")\n      } catch (e: Exception) {\n        execute(\"ROLLBACK TRANSACTION\")\n        throw e\n      }\n\n      // Verify\n      val count = select(\"SELECT COUNT(*) FROM Person WHERE LastName = 'Test'\") { it.getInt(1) }\n      count.first() shouldBe 2\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/#provided-instance-external-mssql","title":"Provided Instance (External MSSQL)","text":"<p>For CI/CD pipelines or shared infrastructure:</p> <pre><code>TestSystem()\n  .with {\n    mssql {\n      MsSqlOptions.provided(\n        jdbcUrl = System.getenv(\"MSSQL_JDBC_URL\") ?: \"jdbc:sqlserver://localhost:1433;databaseName=testdb\",\n        host = System.getenv(\"MSSQL_HOST\") ?: \"localhost\",\n        port = System.getenv(\"MSSQL_PORT\")?.toInt() ?: 1433,\n        databaseName = \"testdb\",\n        username = System.getenv(\"MSSQL_USERNAME\") ?: \"sa\",\n        password = System.getenv(\"MSSQL_PASSWORD\") ?: \"YourStrong@Passw0rd\",\n        runMigrations = true,\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM Orders\")\n          operations.execute(\"DELETE FROM Person\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/08-mssql/#data-types","title":"Data Types","text":"<p>Working with various SQL Server data types:</p> <pre><code>data class DataTypesExample(\n  val id: Int,\n  val intValue: Int,\n  val bigIntValue: Long,\n  val decimalValue: BigDecimal,\n  val floatValue: Double,\n  val bitValue: Boolean,\n  val dateValue: LocalDate,\n  val timeValue: LocalTime,\n  val dateTimeValue: LocalDateTime,\n  val nvarcharValue: String,\n  val varcharValue: String\n)\n\nTestSystem.validate {\n  mssql {\n    // Create table with various types\n    shouldExecute(\n      \"\"\"\n      CREATE TABLE DataTypes (\n        ID INT PRIMARY KEY IDENTITY(1,1),\n        IntValue INT,\n        BigIntValue BIGINT,\n        DecimalValue DECIMAL(18, 4),\n        FloatValue FLOAT,\n        BitValue BIT,\n        DateValue DATE,\n        TimeValue TIME,\n        DateTimeValue DATETIME2,\n        NVarcharValue NVARCHAR(100),\n        VarcharValue VARCHAR(100)\n      )\n      \"\"\".trimIndent()\n    )\n\n    // Insert test data\n    shouldExecute(\n      \"\"\"\n      INSERT INTO DataTypes \n        (IntValue, BigIntValue, DecimalValue, FloatValue, BitValue, DateValue, TimeValue, DateTimeValue, NVarcharValue, VarcharValue)\n      VALUES \n        (42, 9223372036854775807, 1234.5678, 3.14159, 1, '2024-01-15', '14:30:00', '2024-01-15 14:30:00', N'Unicode: \u65e5\u672c\u8a9e', 'ASCII text')\n      \"\"\".trimIndent()\n    )\n\n    // Query and verify\n    shouldQuery&lt;DataTypesExample&gt;(\n      query = \"SELECT * FROM DataTypes\",\n      mapper = { rs -&gt;\n        DataTypesExample(\n          id = rs.getInt(\"ID\"),\n          intValue = rs.getInt(\"IntValue\"),\n          bigIntValue = rs.getLong(\"BigIntValue\"),\n          decimalValue = rs.getBigDecimal(\"DecimalValue\"),\n          floatValue = rs.getDouble(\"FloatValue\"),\n          bitValue = rs.getBoolean(\"BitValue\"),\n          dateValue = rs.getDate(\"DateValue\").toLocalDate(),\n          timeValue = rs.getTime(\"TimeValue\").toLocalTime(),\n          dateTimeValue = rs.getTimestamp(\"DateTimeValue\").toLocalDateTime(),\n          nvarcharValue = rs.getString(\"NVarcharValue\"),\n          varcharValue = rs.getString(\"VarcharValue\")\n        )\n      }\n    ) { results -&gt;\n      results.first().apply {\n        intValue shouldBe 42\n        bitValue shouldBe true\n        nvarcharValue shouldContain \"\u65e5\u672c\u8a9e\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/","title":"Redis","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-redis:$version\")\n    }\n</code></pre>"},{"location":"Components/09-redis/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    redis {\n      RedisSystemOptions {\n        listOf(\n          \"redis.host=${it.host}\",\n          \"redis.port=${it.port}\",\n          \"redis.password=${it.password}\"\n        )\n      }\n    }\n  }.run()\n</code></pre>"},{"location":"Components/09-redis/#usage","title":"Usage","text":"<p>The Redis component provides access to the underlying Lettuce Redis client, allowing you to test all Redis operations.</p>"},{"location":"Components/09-redis/#accessing-the-redis-client","title":"Accessing the Redis Client","text":"<p>Access the Redis client using the <code>client()</code> extension function:</p> <pre><code>TestSystem.validate {\n  redis {\n    val redisClient = client()\n    val connection = redisClient.connect()\n    // Use the connection for Redis operations\n    connection.close()\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#string-operations","title":"String Operations","text":"<p>Test basic string operations:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    // SET and GET\n    connection.set(\"user:123:name\", \"John Doe\")\n    val name = connection.get(\"user:123:name\")\n    name shouldBe \"John Doe\"\n\n    // SET with expiration\n    connection.setex(\"session:abc\", 3600, \"session-data\")\n    val ttl = connection.ttl(\"session:abc\")\n    ttl shouldBeGreaterThan 0\n\n    // INCREMENT\n    connection.set(\"counter\", \"0\")\n    connection.incr(\"counter\")\n    connection.incr(\"counter\")\n    val counter = connection.get(\"counter\")\n    counter shouldBe \"2\"\n\n    // Multiple keys\n    connection.mset(mapOf(\n      \"key1\" to \"value1\",\n      \"key2\" to \"value2\",\n      \"key3\" to \"value3\"\n    ))\n    val values = connection.mget(\"key1\", \"key2\", \"key3\")\n    values.size shouldBe 3\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#hash-operations","title":"Hash Operations","text":"<p>Test Redis hash operations:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    // HSET and HGET\n    connection.hset(\"user:123\", \"name\", \"John Doe\")\n    connection.hset(\"user:123\", \"email\", \"john@example.com\")\n    connection.hset(\"user:123\", \"age\", \"30\")\n\n    val name = connection.hget(\"user:123\", \"name\")\n    name shouldBe \"John Doe\"\n\n    // HGETALL\n    val user = connection.hgetall(\"user:123\")\n    user[\"name\"] shouldBe \"John Doe\"\n    user[\"email\"] shouldBe \"john@example.com\"\n    user[\"age\"] shouldBe \"30\"\n\n    // HMSET\n    connection.hmset(\"product:456\", mapOf(\n      \"name\" to \"Laptop\",\n      \"price\" to \"999.99\",\n      \"stock\" to \"10\"\n    ))\n\n    // HINCRBY\n    connection.hincrby(\"product:456\", \"stock\", -1)\n    val stock = connection.hget(\"product:456\", \"stock\")\n    stock shouldBe \"9\"\n\n    // HDEL\n    connection.hdel(\"user:123\", \"age\")\n    val age = connection.hget(\"user:123\", \"age\")\n    age shouldBe null\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#list-operations","title":"List Operations","text":"<p>Test Redis list operations:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    // LPUSH and RPUSH\n    connection.rpush(\"queue:tasks\", \"task1\", \"task2\", \"task3\")\n    connection.lpush(\"queue:tasks\", \"urgent-task\")\n\n    // LRANGE\n    val tasks = connection.lrange(\"queue:tasks\", 0, -1)\n    tasks.size shouldBe 4\n    tasks.first() shouldBe \"urgent-task\"\n\n    // LPOP and RPOP\n    val firstTask = connection.lpop(\"queue:tasks\")\n    firstTask shouldBe \"urgent-task\"\n\n    val lastTask = connection.rpop(\"queue:tasks\")\n    lastTask shouldBe \"task3\"\n\n    // LLEN\n    val length = connection.llen(\"queue:tasks\")\n    length shouldBe 2\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#set-operations","title":"Set Operations","text":"<p>Test Redis set operations:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    // SADD\n    connection.sadd(\"tags:123\", \"kotlin\", \"testing\", \"redis\")\n\n    // SMEMBERS\n    val tags = connection.smembers(\"tags:123\")\n    tags.size shouldBe 3\n    tags shouldContain \"kotlin\"\n\n    // SISMEMBER\n    val isKotlin = connection.sismember(\"tags:123\", \"kotlin\")\n    isKotlin shouldBe true\n\n    // SREM\n    connection.srem(\"tags:123\", \"redis\")\n    val remainingTags = connection.smembers(\"tags:123\")\n    remainingTags.size shouldBe 2\n\n    // Set operations\n    connection.sadd(\"set1\", \"a\", \"b\", \"c\")\n    connection.sadd(\"set2\", \"b\", \"c\", \"d\")\n\n    // SINTER (intersection)\n    val intersection = connection.sinter(\"set1\", \"set2\")\n    intersection.size shouldBe 2\n    intersection shouldContain \"b\"\n    intersection shouldContain \"c\"\n\n    // SUNION\n    val union = connection.sunion(\"set1\", \"set2\")\n    union.size shouldBe 4\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#sorted-set-operations","title":"Sorted Set Operations","text":"<p>Test Redis sorted set operations:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    // ZADD\n    connection.zadd(\"leaderboard\", 100.0, \"player1\")\n    connection.zadd(\"leaderboard\", 250.0, \"player2\")\n    connection.zadd(\"leaderboard\", 175.0, \"player3\")\n\n    // ZRANGE (ascending)\n    val ascending = connection.zrange(\"leaderboard\", 0, -1)\n    ascending.size shouldBe 3\n    ascending.first() shouldBe \"player1\"\n    ascending.last() shouldBe \"player2\"\n\n    // ZREVRANGE (descending)\n    val descending = connection.zrevrange(\"leaderboard\", 0, -1)\n    descending.first() shouldBe \"player2\"\n\n    // ZSCORE\n    val score = connection.zscore(\"leaderboard\", \"player2\")\n    score shouldBe 250.0\n\n    // ZRANK\n    val rank = connection.zrank(\"leaderboard\", \"player3\")\n    rank shouldBe 1L // 0-indexed\n\n    // ZINCRBY\n    connection.zincrby(\"leaderboard\", 50.0, \"player1\")\n    val newScore = connection.zscore(\"leaderboard\", \"player1\")\n    newScore shouldBe 150.0\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#async-operations","title":"Async Operations","text":"<p>Use async operations for better performance:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().async()\n\n    // Async SET\n    val setFuture = connection.set(\"async:key\", \"async:value\")\n    setFuture.await() shouldBe \"OK\"\n\n    // Async GET\n    val getFuture = connection.get(\"async:key\")\n    val value = getFuture.await()\n    value shouldBe \"async:value\"\n\n    // Pipeline multiple operations\n    connection.setAutoFlushCommands(false)\n    val futures = listOf(\n      connection.set(\"key1\", \"value1\"),\n      connection.set(\"key2\", \"value2\"),\n      connection.set(\"key3\", \"value3\")\n    )\n    connection.flushCommands()\n\n    futures.forEach { it.await() shouldBe \"OK\" }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#pubsub-operations","title":"Pub/Sub Operations","text":"<p>Test Redis Pub/Sub:</p> <pre><code>TestSystem.validate {\n  redis {\n    val pubConnection = client().connectPubSub().sync()\n    val subConnection = client().connectPubSub().sync()\n\n    // Subscribe to channel\n    val messages = mutableListOf&lt;String&gt;()\n    subConnection.addListener(object : RedisPubSubAdapter&lt;String, String&gt;() {\n      override fun message(channel: String, message: String) {\n        messages.add(message)\n      }\n    })\n\n    subConnection.subscribe(\"notifications\")\n\n    // Publish messages\n    pubConnection.publish(\"notifications\", \"User logged in\")\n    pubConnection.publish(\"notifications\", \"Order created\")\n\n    // Wait for messages\n    delay(1.seconds)\n\n    messages.size shouldBe 2\n    messages shouldContain \"User logged in\"\n    messages shouldContain \"Order created\"\n\n    subConnection.unsubscribe(\"notifications\")\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#expiration-and-ttl","title":"Expiration and TTL","text":"<p>Test key expiration:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    // Set with expiration\n    connection.setex(\"temp:data\", 5, \"temporary-value\")\n\n    // Check TTL\n    val ttl = connection.ttl(\"temp:data\")\n    ttl shouldBeGreaterThan 0\n    ttl shouldBeLessThanOrEqual 5\n\n    // Set expiration on existing key\n    connection.set(\"permanent\", \"data\")\n    connection.expire(\"permanent\", 10)\n    val newTtl = connection.ttl(\"permanent\")\n    newTtl shouldBeGreaterThan 0\n\n    // Remove expiration\n    connection.persist(\"permanent\")\n    val persistedTtl = connection.ttl(\"permanent\")\n    persistedTtl shouldBe -1 // No expiration\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#transactions","title":"Transactions","text":"<p>Test Redis transactions:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    connection.multi()\n    connection.set(\"account:1:balance\", \"1000\")\n    connection.decrby(\"account:1:balance\", 100)\n    connection.incrby(\"account:2:balance\", 100)\n    val results = connection.exec()\n\n    results.size shouldBe 3\n\n    val balance1 = connection.get(\"account:1:balance\")\n    balance1 shouldBe \"900\"\n\n    val balance2 = connection.get(\"account:2:balance\")\n    balance2 shouldBe \"100\"\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#pause-and-unpause-container","title":"Pause and Unpause Container","text":"<p>Test failure scenarios:</p> <pre><code>TestSystem.validate {\n  redis {\n    val connection = client().connect().sync()\n\n    // Redis is running\n    connection.set(\"test\", \"value\")\n    connection.get(\"test\") shouldBe \"value\"\n\n    // Pause container\n    pause()\n\n    // Operations should fail\n    shouldThrow&lt;RedisException&gt; {\n      connection.get(\"test\")\n    }\n\n    // Unpause container\n    unpause()\n\n    // Wait for recovery\n    delay(2.seconds)\n\n    // Operations should work again\n    val value = connection.get(\"test\")\n    value shouldBe \"value\"\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#complete-example","title":"Complete Example","text":"<p>Here's a complete caching test example:</p> <pre><code>test(\"should cache product data in redis\") {\n  TestSystem.validate {\n    val productId = \"product-123\"\n\n    // Product not in cache - verify using client()\n    redis {\n      val conn = client().connect().sync()\n      val cached = conn.get(\"cache:product:$productId\")\n      cached shouldBe null\n    }\n\n    // Fetch from database via API (application should cache the result)\n    http {\n      get&lt;ProductResponse&gt;(\"/products/$productId\") { product -&gt;\n        product.id shouldBe productId\n        product.name shouldNotBe null\n      }\n    }\n\n    // Application should have cached the product - verify\n    redis {\n      val conn = client().connect().sync()\n      val cachedData = conn.get(\"cache:product:$productId\")\n      cachedData shouldNotBe null\n\n      val cachedProduct = objectMapper.readValue(cachedData, ProductResponse::class.java)\n      cachedProduct.id shouldBe productId\n    }\n\n    // Verify TTL is set\n    redis {\n      val conn = client().connect().sync()\n      val ttl = conn.ttl(\"cache:product:$productId\")\n      ttl shouldBeGreaterThan 0\n      ttl shouldBeLessThanOrEqual 3600\n    }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#integration-with-application","title":"Integration with Application","text":"<p>Test application caching behavior:</p> <pre><code>test(\"should use redis for session management\") {\n  TestSystem.validate {\n    val sessionId = UUID.randomUUID().toString()\n\n    // Create session via API\n    http {\n      postAndExpectBody&lt;SessionResponse&gt;(\n        uri = \"/auth/login\",\n        body = LoginRequest(username = \"user\", password = \"pass\").some()\n      ) { response -&gt;\n        response.status shouldBe 200\n        response.body().sessionId shouldBe sessionId\n      }\n    }\n\n    // Verify session in Redis\n    redis {\n      val connection = client().connect().sync()\n      val sessionData = connection.get(\"session:$sessionId\")\n      sessionData shouldNotBe null\n\n      val session = objectMapper.readValue(sessionData, Session::class.java)\n      session.username shouldBe \"user\"\n      session.createdAt shouldNotBe null\n    }\n\n    // Use session\n    http {\n      get&lt;UserProfile&gt;(\n        uri = \"/profile\",\n        headers = mapOf(\"X-Session-ID\" to sessionId)\n      ) { profile -&gt;\n        profile.username shouldBe \"user\"\n      }\n    }\n\n    // Logout\n    http {\n      postAndExpectBodilessResponse(\n        uri = \"/auth/logout\",\n        body = LogoutRequest(sessionId = sessionId).some()\n      ) { response -&gt;\n        response.status shouldBe 200\n      }\n    }\n\n    // Verify session removed from Redis\n    redis {\n      val connection = client().connect().sync()\n      val sessionData = connection.get(\"session:$sessionId\")\n      sessionData shouldBe null\n    }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/#advanced-custom-extensions","title":"Advanced: Custom Extensions","text":"<p>Create reusable extensions for common patterns:</p> <pre><code>// Custom extension functions\nfun RedisSystem.shouldGet(key: String, assertion: (String?) -&gt; Unit): RedisSystem {\n  val connection = client().connect().sync()\n  val value = connection.get(key)\n  assertion(value)\n  return this\n}\n\nfun RedisSystem.shouldSet(key: String, value: String): RedisSystem {\n  val connection = client().connect().sync()\n  connection.set(key, value)\n  return this\n}\n\n// Usage in tests\nTestSystem.validate {\n  redis {\n    shouldSet(\"user:123\", \"John Doe\")\n    shouldGet(\"user:123\") { value -&gt;\n      value shouldBe \"John Doe\"\n    }\n  }\n}\n</code></pre>"},{"location":"Components/10-bridge/","title":"Bridge","text":"<p>The Bridge component provides direct access to your application's dependency injection (DI) container from within your tests. This enables you to resolve and use any bean or service registered in your application, making it possible to test internal state, verify side effects, or set up test data through application services.</p>"},{"location":"Components/10-bridge/#overview","title":"Overview","text":"<p>When testing an application end-to-end, you often need to:</p> <ul> <li>Verify internal state that isn't exposed through APIs</li> <li>Access application services to set up test data</li> <li>Invoke domain services directly to test business logic</li> <li>Replace time-dependent implementations for deterministic tests</li> <li>Verify side effects that happen within the application</li> </ul> <p>The Bridge provides a type-safe way to access any component from your application's DI container.</p>"},{"location":"Components/10-bridge/#configuration","title":"Configuration","text":"<p>Bridge is built into the framework starters, so no extra dependency is needed.</p> Spring BootKtor <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n}\n</code></pre> <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$version\")\n}\n</code></pre>"},{"location":"Components/10-bridge/#setup","title":"Setup","text":"<p>Enable Bridge in your TestSystem configuration:</p> <pre><code>TestSystem()\n  .with {\n    httpClient { HttpClientSystemOptions(baseUrl = \"http://localhost:8080\") }\n\n    bridge()  // Enable access to DI container\n\n    springBoot(\n      runner = { params -&gt; myApp.run(params) },\n      withParameters = listOf(\"server.port=8080\")\n    )\n  }\n  .run()\n</code></pre>"},{"location":"Components/10-bridge/#framework-support","title":"Framework Support","text":""},{"location":"Components/10-bridge/#spring-boot","title":"Spring Boot","text":"<p>For Spring Boot applications, Bridge provides access to the <code>ApplicationContext</code>:</p> <pre><code>// Bridge resolves beans from ApplicationContext\nusing&lt;UserService&gt; {\n    // 'this' is the UserService bean from Spring context\n    findById(123)\n}\n</code></pre> <p>Under the hood, it uses <code>ApplicationContext.getBean()</code>:</p> <pre><code>class SpringBridgeSystem(testSystem: TestSystem) : BridgeSystem&lt;ApplicationContext&gt;(testSystem) {\n    override fun &lt;D : Any&gt; get(klass: KClass&lt;D&gt;): D = ctx.getBean(klass.java)\n}\n</code></pre>"},{"location":"Components/10-bridge/#ktor","title":"Ktor","text":"<p>For Ktor applications using Koin, Bridge provides access to the Koin container:</p> <pre><code>// Bridge resolves beans from Koin\nusing&lt;UserRepository&gt; {\n    // 'this' is the UserRepository from Koin\n    save(user)\n}\n</code></pre> <p>Under the hood, it uses Koin's <code>getKoin().get()</code>:</p> <pre><code>class KtorBridgeSystem(testSystem: TestSystem) : BridgeSystem&lt;Application&gt;(testSystem) {\n    override fun &lt;D : Any&gt; get(klass: KClass&lt;D&gt;): D = ctx.getKoin().get(klass)\n}\n</code></pre>"},{"location":"Components/10-bridge/#usage","title":"Usage","text":""},{"location":"Components/10-bridge/#single-bean-access","title":"Single Bean Access","text":"<p>Access a single bean and perform operations:</p> <pre><code>TestSystem.validate {\n    using&lt;UserService&gt; {\n        // 'this' refers to UserService\n        val user = findById(123)\n        user.name shouldBe \"John Doe\"\n        user.email shouldBe \"john@example.com\"\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#multiple-bean-access","title":"Multiple Bean Access","text":"<p>Access multiple beans in a single block (up to 5 beans supported):</p> <pre><code>TestSystem.validate {\n    // Two beans\n    using&lt;UserService, OrderService&gt; { userService, orderService -&gt;\n        val user = userService.findById(123)\n        val orders = orderService.findByUserId(123)\n        orders.size shouldBeGreaterThan 0\n    }\n\n    // Three beans\n    using&lt;UserService, ProductService, InventoryService&gt; { users, products, inventory -&gt;\n        val product = products.findById(\"SKU-123\")\n        val stock = inventory.getStock(product.id)\n        stock shouldBeGreaterThan 0\n    }\n\n    // Four beans\n    using&lt;A, B, C, D&gt; { a, b, c, d -&gt;\n        // Work with all four services\n    }\n\n    // Five beans\n    using&lt;A, B, C, D, E&gt; { a, b, c, d, e -&gt;\n        // Work with all five services\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#capturing-values-for-later-use","title":"Capturing Values for Later Use","text":"<p>When you need to capture a value from inside the <code>using</code> block for later use, declare a variable outside the block and assign it inside:</p> <pre><code>TestSystem.validate {\n    // Declare variable outside, assign inside\n    var userId: Long = 0\n    using&lt;UserService&gt; {\n        userId = createUser(CreateUserRequest(name = \"John\", email = \"john@example.com\")).id\n    }\n\n    // Use the captured value in subsequent operations\n    http {\n        get&lt;UserResponse&gt;(\"/users/$userId\") { user -&gt;\n            user.name shouldBe \"John\"\n        }\n    }\n\n    // Capture multiple values\n    var user: User? = null\n    var token: String? = null\n    using&lt;AuthService&gt; {\n        user = register(email = \"test@example.com\", password = \"secret\")\n        token = generateToken(user!!)\n    }\n\n    // Or use lateinit for non-nullable types\n    lateinit var order: Order\n    using&lt;OrderService&gt; {\n        order = findById(orderId)\n    }\n\n    // Use captured values\n    http {\n        getResponse(\"/orders/${order.id}\", headers = mapOf(\"Authorization\" to \"Bearer $token\")) { response -&gt;\n            response.status shouldBe 200\n        }\n    }\n}\n</code></pre> <p>Variable Capture Pattern</p> <p>Since <code>using</code> blocks don't return values, use the pattern of declaring variables outside and assigning inside when you need to pass data between blocks.</p>"},{"location":"Components/10-bridge/#use-cases","title":"Use Cases","text":""},{"location":"Components/10-bridge/#1-setting-up-test-data","title":"1. Setting Up Test Data","text":"<p>Use application repositories to set up test data:</p> <pre><code>test(\"should return user orders\") {\n    TestSystem.validate {\n        // Create test data using application's repository\n        var userId: Long = 0\n        using&lt;UserRepository&gt; {\n            userId = save(User(name = \"Test User\", email = \"test@example.com\")).id\n        }\n\n        using&lt;OrderRepository&gt; {\n            save(Order(userId = userId, amount = 100.0))\n            save(Order(userId = userId, amount = 250.0))\n        }\n\n        // Test the API\n        http {\n            get&lt;List&lt;OrderResponse&gt;&gt;(\"/users/$userId/orders\") { orders -&gt;\n                orders.size shouldBe 2\n                orders.sumOf { it.amount } shouldBe 350.0\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#2-verifying-internal-state","title":"2. Verifying Internal State","text":"<p>Verify state that isn't exposed through APIs:</p> <pre><code>test(\"should update inventory after order\") {\n    TestSystem.validate {\n        val productId = \"PROD-123\"\n\n        // Check initial inventory\n        var initialStock = 0\n        using&lt;InventoryService&gt; {\n            initialStock = getStock(productId)\n        }\n\n        // Place an order via API\n        http {\n            postAndExpectBodilessResponse(\n                uri = \"/orders\",\n                body = CreateOrderRequest(productId = productId, quantity = 5).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // Verify inventory was reduced (internal side effect)\n        using&lt;InventoryService&gt; {\n            getStock(productId) shouldBe (initialStock - 5)\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#3-testing-domain-services-directly","title":"3. Testing Domain Services Directly","text":"<p>Test business logic that may be complex to trigger through APIs:</p> <pre><code>test(\"should calculate shipping cost correctly\") {\n    TestSystem.validate {\n        using&lt;ShippingCalculator&gt; {\n            // Test various scenarios directly\n            calculate(weight = 1.0, destination = \"US\") shouldBe 5.99\n            calculate(weight = 5.0, destination = \"US\") shouldBe 12.99\n            calculate(weight = 1.0, destination = \"EU\") shouldBe 15.99\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#4-triggering-scheduled-jobs","title":"4. Triggering Scheduled Jobs","text":"<p>Manually trigger scheduled jobs for testing:</p> <pre><code>test(\"should process pending orders when scheduler runs\") {\n    TestSystem.validate {\n        // Setup: Create pending orders\n        using&lt;OrderRepository&gt; {\n            save(Order(status = \"PENDING\", createdAt = Instant.now().minusHours(2)))\n            save(Order(status = \"PENDING\", createdAt = Instant.now().minusHours(3)))\n        }\n\n        // Trigger the scheduled job manually\n        using&lt;OrderProcessingScheduler&gt; {\n            processPendingOrders()\n        }\n\n        // Verify orders were processed\n        using&lt;OrderRepository&gt; {\n            findByStatus(\"PENDING\").size shouldBe 0\n            findByStatus(\"PROCESSED\").size shouldBe 2\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#5-time-control","title":"5. Time Control","text":"<p>Control time-dependent behavior:</p> <pre><code>// First, create a testable time provider interface\ninterface TimeProvider {\n    fun now(): Instant\n}\n\n// Production implementation\nclass SystemTimeProvider : TimeProvider {\n    override fun now(): Instant = Instant.now()\n}\n\n// Test implementation\nclass FixedTimeProvider(private var time: Instant) : TimeProvider {\n    override fun now(): Instant = time\n    fun advance(duration: Duration) { time = time.plus(duration) }\n}\n\n// Register test implementation in TestInitializer\nclass TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;TimeProvider&gt;(isPrimary = true) { FixedTimeProvider(Instant.parse(\"2024-01-01T00:00:00Z\")) }\n})\n\n// Use in tests\ntest(\"should expire session after timeout\") {\n    TestSystem.validate {\n        // Create session and capture the session ID\n        var sessionId: String = \"\"\n        http {\n            postAndExpectBody&lt;SessionResponse&gt;(\"/login\", body = credentials.some()) { response -&gt;\n                sessionId = response.body().sessionId \n            }\n        }\n\n        // Advance time past session timeout\n        using&lt;FixedTimeProvider&gt; {\n            advance(Duration.ofHours(2))\n        }\n\n        // Session should be expired\n        http {\n            getResponse(\"/protected\", headers = mapOf(\"Session-ID\" to sessionId)) { response -&gt;\n                response.status shouldBe 401\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#6-event-verification","title":"6. Event Verification","text":"<p>Capture and verify domain events:</p> <pre><code>// Test event listener (registered in TestInitializer)\nclass TestEventCapture {\n    private val events = ConcurrentLinkedQueue&lt;Any&gt;()\n\n    @EventListener\n    fun capture(event: Any) {\n        events.add(event)\n    }\n\n    inline fun &lt;reified T&gt; getEvents(): List&lt;T&gt; = events.filterIsInstance&lt;T&gt;()\n    fun clear() = events.clear()\n}\n\ntest(\"should publish UserCreatedEvent when user registers\") {\n    TestSystem.validate {\n        // Clear previous events\n        using&lt;TestEventCapture&gt; { clear() }\n\n        // Perform action\n        http {\n            postAndExpectBodilessResponse(\"/users\", body = newUser.some()) { \n                it.status shouldBe 201 \n            }\n        }\n\n        // Verify event was published\n        using&lt;TestEventCapture&gt; {\n            val events = getEvents&lt;UserCreatedEvent&gt;()\n            events.size shouldBe 1\n            events.first().email shouldBe newUser.email\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#test-initializers","title":"Test Initializers","text":"<p>Use <code>BaseApplicationContextInitializer</code> to register test-specific beans:</p> <pre><code>class TestInitializer : BaseApplicationContextInitializer({\n    // Replace production beans with test doubles\n    bean&lt;TimeProvider&gt;(isPrimary = true) { FixedTimeProvider(Instant.now()) }\n    bean&lt;EmailService&gt;(isPrimary = true) { MockEmailService() }\n\n    // Add test utilities\n    bean&lt;TestEventCapture&gt;()\n    bean&lt;TestDataBuilder&gt;()\n})\n\nfun SpringApplication.addTestDependencies() {\n    addInitializers(TestInitializer())\n}\n\n// In TestSystem configuration\nTestSystem()\n    .with {\n        bridge()\n        springBoot(\n            runner = { params -&gt; \n                myApp.run(params) { addTestDependencies() }\n            }\n        )\n    }\n    .run()\n</code></pre>"},{"location":"Components/10-bridge/#extending-initializers","title":"Extending Initializers","text":"<p>You can extend initializers with additional registrations:</p> <pre><code>class TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;MockEmailService&gt;(isPrimary = true)\n}) {\n    init {\n        // Add more registrations\n        register {\n            bean&lt;TestEventCapture&gt;()\n            bean&lt;FixedClock&gt;(isPrimary = true) { FixedClock(Instant.now()) }\n        }\n    }\n\n    // React to application events\n    override fun onEvent(event: ApplicationEvent) {\n        when (event) {\n            is ContextRefreshedEvent -&gt; println(\"Context refreshed\")\n        }\n    }\n\n    // Execute when application is ready\n    override fun applicationReady(applicationContext: GenericApplicationContext) {\n        println(\"Application is ready for testing\")\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#integration-with-other-systems","title":"Integration with Other Systems","text":"<p>Bridge works seamlessly with other Stove systems:</p> <pre><code>test(\"should process order end-to-end\") {\n    TestSystem.validate {\n        val orderId = UUID.randomUUID().toString()\n\n        // Mock external payment service\n        wiremock {\n            mockPost(\"/payments/charge\", statusCode = 200, responseBody = PaymentResult(success = true).some())\n        }\n\n        // Create order via API\n        http {\n            postAndExpectBody&lt;OrderResponse&gt;(\n                uri = \"/orders\",\n                body = CreateOrderRequest(id = orderId, amount = 99.99).some()\n            ) { response -&gt;\n                response.status shouldBe 201\n            }\n        }\n\n        // Verify in database using application's repository\n        using&lt;OrderRepository&gt; {\n            val order = findById(orderId)\n            order.status shouldBe \"PAID\"\n            order.paymentId shouldNotBe null\n        }\n\n        // Verify Kafka event\n        kafka {\n            shouldBePublished&lt;OrderPaidEvent&gt;(atLeastIn = 10.seconds) {\n                actual.orderId == orderId\n            }\n        }\n\n        // Verify in Couchbase (if using)\n        couchbase {\n            shouldGet&lt;Order&gt;(\"orders\", orderId) { order -&gt;\n                order.status shouldBe \"PAID\"\n            }\n        }\n\n        // Access domain service for additional verification\n        using&lt;OrderAnalytics&gt; {\n            getTodaysTotalRevenue() shouldBeGreaterThanOrEqual 99.99\n        }\n  }\n}\n</code></pre>"},{"location":"Components/10-bridge/#best-practices","title":"Best Practices","text":""},{"location":"Components/10-bridge/#1-use-bridge-for-setup-http-for-actions","title":"1. Use Bridge for Setup, HTTP for Actions","text":"<pre><code>// \u2705 Good: Use bridge for setup, HTTP for testing\nusing&lt;ProductRepository&gt; {\n    save(Product(id = \"123\", name = \"Test\", price = 99.99))\n}\nhttp {\n    get&lt;ProductResponse&gt;(\"/products/123\") { product -&gt;\n        product.name shouldBe \"Test\"\n    }\n}\n\n// \u274c Avoid: Using bridge for everything\nusing&lt;ProductService&gt; {\n    create(product)\n    val retrieved = findById(\"123\")  // Not testing actual API\n    retrieved.name shouldBe \"Test\"\n}\n</code></pre>"},{"location":"Components/10-bridge/#2-prefer-application-services-over-direct-repository-access","title":"2. Prefer Application Services Over Direct Repository Access","text":"<pre><code>// \u2705 Good: Use application services that encapsulate business logic\nusing&lt;OrderService&gt; {\n    createOrder(CreateOrderRequest(...))  // Triggers all business logic\n}\n\n// \u26a0\ufe0f Be careful: Direct repository access bypasses business logic\nusing&lt;OrderRepository&gt; {\n    save(Order(...))  // No validation, no events, no side effects\n}\n</code></pre>"},{"location":"Components/10-bridge/#3-clean-up-test-data","title":"3. Clean Up Test Data","text":"<pre><code>// Use cleanup functions or explicit cleanup in tests\nTestSystem.validate {\n    var userId: Long = 0\n    using&lt;UserRepository&gt; {\n        userId = save(user).id\n    }\n\n    try {\n        // Test logic\n        http { /* ... */ }\n    } finally {\n        // Cleanup\n        using&lt;UserRepository&gt; {\n            deleteById(userId)\n        }\n    }\n}\n</code></pre>"},{"location":"Components/10-bridge/#4-keep-test-beans-minimal","title":"4. Keep Test Beans Minimal","text":"<p>Only replace what's necessary:</p> <pre><code>// \u2705 Good: Replace only time-sensitive components\nclass TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;Clock&gt;(isPrimary = true) { Clock.fixed(fixedInstant, ZoneId.UTC) }\n})\n\n// \u274c Avoid: Replacing too many components (reduces test value)\nclass TestInitializer : BaseApplicationContextInitializer({\n    bean&lt;UserService&gt;(isPrimary = true) { MockUserService() }\n    bean&lt;OrderService&gt;(isPrimary = true) { MockOrderService() }\n    bean&lt;PaymentService&gt;(isPrimary = true) { MockPaymentService() }\n})\n</code></pre>"},{"location":"Components/10-bridge/#summary","title":"Summary","text":"<p>The Bridge component enables:</p> Capability Example Use Case Bean Access Resolve any bean from DI container State Verification Check internal state not exposed by APIs Test Setup Create test data using application services Time Control Replace time providers for deterministic tests Event Capture Verify domain events were published Job Triggering Manually trigger scheduled tasks Service Testing Test domain services directly <p>Bridge is essential for comprehensive e2e testing, allowing you to verify and control aspects of your application that aren't accessible through external interfaces alone.</p>"},{"location":"Components/11-provided-instances/","title":"Provided Instances (Testcontainer-less Mode)","text":"<p>Stove supports using externally provided infrastructure instances instead of testcontainers. This is particularly useful for:</p> <ul> <li>CI/CD pipelines with shared infrastructure</li> <li>Reducing startup time by reusing existing instances</li> <li>Lower memory/CPU usage by avoiding container overhead</li> <li>Working with pre-configured environments</li> </ul>"},{"location":"Components/11-provided-instances/#overview","title":"Overview","text":"<p>Instead of starting a testcontainer, you can configure Stove to connect to an existing instance using the <code>.provided(...)</code> companion function on the options class itself.</p>"},{"location":"Components/11-provided-instances/#core-concept","title":"Core Concept","text":"<p>Each system's options class (e.g., <code>CouchbaseSystemOptions</code>, <code>PostgresqlOptions</code>) has a companion function called <code>provided(...)</code> that returns a specialized options subclass configured for external instances.</p>"},{"location":"Components/11-provided-instances/#usage-pattern","title":"Usage Pattern","text":"<p>All systems follow the same pattern:</p> <pre><code>TestSystem()\n  .with {\n    // Option 1: Container-based (default)\n    systemName {\n      SystemOptions(\n        // System-specific options\n        cleanup = { client -&gt; /* cleanup logic */ },\n        configureExposedConfiguration = { cfg -&gt; listOf(\"property=${cfg.value}\") }\n      )\n    }\n\n    // Option 2: Provided instance using .provided() companion function\n    systemName {\n      SystemOptions.provided(\n        // Connection parameters for external instance\n        runMigrations = true,\n        cleanup = { client -&gt; /* cleanup logic */ },\n        configureExposedConfiguration = { cfg -&gt; listOf(\"property=${cfg.value}\") }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#supported-systems","title":"Supported Systems","text":""},{"location":"Components/11-provided-instances/#couchbase","title":"Couchbase","text":"<pre><code>// Container-based with cleanup\nTestSystem()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(\n        defaultBucket = \"myBucket\",\n        cleanup = { cluster -&gt;\n          cluster.query(\"DELETE FROM `myBucket` WHERE type = 'test'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"couchbase.hosts=${cfg.hostsWithPort}\",\n            \"couchbase.username=${cfg.username}\",\n            \"couchbase.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nTestSystem()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions.provided(\n        connectionString = \"couchbase://localhost:8091\",\n        username = \"admin\",\n        password = \"password\",\n        defaultBucket = \"myBucket\",\n        runMigrations = true,\n        cleanup = { cluster -&gt;\n          cluster.query(\"DELETE FROM `myBucket` WHERE type = 'test'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"couchbase.hosts=${cfg.hostsWithPort}\",\n            \"couchbase.username=${cfg.username}\",\n            \"couchbase.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#kafka","title":"Kafka","text":"<pre><code>// Container-based\nTestSystem()\n  .with {\n    kafka {\n      KafkaSystemOptions(\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n            \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nTestSystem()\n  .with {\n    kafka {\n      KafkaSystemOptions.provided(\n        bootstrapServers = \"localhost:9092\",\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n            \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#redis","title":"Redis","text":"<pre><code>// Container-based\nTestSystem()\n  .with {\n    redis {\n      RedisOptions(\n        cleanup = { client -&gt;\n          client.connect().sync().flushdb()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"redis.host=${cfg.host}\",\n            \"redis.port=${cfg.port}\",\n            \"redis.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nTestSystem()\n  .with {\n    redis {\n      RedisOptions.provided(\n        host = \"localhost\",\n        port = 6379,\n        password = \"password\",\n        database = 8,\n        cleanup = { client -&gt;\n          client.connect().sync().flushdb()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"redis.host=${cfg.host}\",\n            \"redis.port=${cfg.port}\",\n            \"redis.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#postgresql","title":"PostgreSQL","text":"<pre><code>// Container-based\nTestSystem()\n  .with {\n    postgresql {\n      PostgresqlOptions(\n        databaseName = \"testdb\",\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM users WHERE email LIKE '%@test.com'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nTestSystem()\n  .with {\n    postgresql {\n      PostgresqlOptions.provided(\n        jdbcUrl = \"jdbc:postgresql://localhost:5432/testdb\",\n        host = \"localhost\",\n        port = 5432,\n        databaseName = \"testdb\",\n        username = \"postgres\",\n        password = \"postgres\",\n        runMigrations = true,\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM users WHERE email LIKE '%@test.com'\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#mssql","title":"MSSQL","text":"<pre><code>// Container-based\nTestSystem()\n  .with {\n    mssql {\n      MsSqlOptions(\n        applicationName = \"stove-tests\",\n        databaseName = \"testdb\",\n        userName = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM Orders WHERE OrderDate &lt; GETDATE() - 1\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nTestSystem()\n  .with {\n    mssql {\n      MsSqlOptions.provided(\n        jdbcUrl = \"jdbc:sqlserver://localhost:1433;databaseName=testdb\",\n        host = \"localhost\",\n        port = 1433,\n        databaseName = \"testdb\",\n        username = \"sa\",\n        password = \"YourStrong@Passw0rd\",\n        runMigrations = true,\n        cleanup = { operations -&gt;\n          operations.execute(\"DELETE FROM Orders WHERE OrderDate &lt; GETDATE() - 1\")\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"spring.datasource.url=${cfg.jdbcUrl}\",\n            \"spring.datasource.username=${cfg.username}\",\n            \"spring.datasource.password=${cfg.password}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#mongodb","title":"MongoDB","text":"<pre><code>// Container-based\nTestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        cleanup = { client -&gt;\n          client.getDatabase(\"testdb\").drop()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nTestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions.provided(\n        connectionString = \"mongodb://localhost:27017\",\n        host = \"localhost\",\n        port = 27017,\n        cleanup = { client -&gt;\n          client.getDatabase(\"testdb\").drop()\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"mongodb.uri=${cfg.connectionString}\",\n            \"mongodb.host=${cfg.host}\",\n            \"mongodb.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#elasticsearch","title":"Elasticsearch","text":"<pre><code>// Container-based\nTestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(\n        cleanup = { esClient -&gt;\n          esClient.indices().delete { it.index(\"test-*\") }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n\n// Provided instance\nTestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions.provided(\n        host = \"localhost\",\n        port = 9200,\n        password = \"\", // Leave empty if security is disabled\n        runMigrations = true,\n        cleanup = { esClient -&gt;\n          esClient.indices().delete { it.index(\"test-*\") }\n        },\n        configureExposedConfiguration = { cfg -&gt;\n          listOf(\n            \"elasticsearch.host=${cfg.host}\",\n            \"elasticsearch.port=${cfg.port}\"\n          )\n        }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#cleanup-function","title":"Cleanup Function","text":"<p>The <code>cleanup</code> parameter is available for both container-based and provided instance modes. It executes during <code>close()</code> before the system is stopped - this ensures cleanup runs after all tests have completed.</p>"},{"location":"Components/11-provided-instances/#use-cases","title":"Use Cases","text":"<ol> <li>Clear test data from previous runs</li> <li>Reset state to a known baseline</li> <li>Delete test-specific records that shouldn't persist</li> </ol>"},{"location":"Components/11-provided-instances/#example-with-container-mode-and-keepdependenciesrunning","title":"Example with Container Mode and keepDependenciesRunning","text":"<p>The cleanup function is especially useful when using containers with <code>keepDependenciesRunning</code>:</p> <pre><code>TestSystem {\n  keepDependenciesRunning()\n}.with {\n  couchbase {\n    CouchbaseSystemOptions(\n      defaultBucket = \"myBucket\",\n      cleanup = { cluster -&gt;\n        // Clean test data between runs when reusing containers\n        cluster.query(\"DELETE FROM `myBucket` WHERE type = 'test'\")\n      },\n      configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      }\n    )\n  }\n}.run()\n</code></pre>"},{"location":"Components/11-provided-instances/#migration-handling","title":"Migration Handling","text":"<p>When using provided instances, migrations are controlled by the <code>runMigrations</code> parameter in the <code>.provided()</code> function:</p> <ul> <li><code>runMigrations = true</code> (default for databases): Migrations will run on every test execution</li> <li><code>runMigrations = false</code> (default for Kafka/Redis): Migrations are skipped</li> </ul> <pre><code>TestSystem()\n  .with {\n    postgresql {\n      PostgresqlOptions.provided(\n        jdbcUrl = \"jdbc:postgresql://localhost:5432/mydb\",\n        host = \"localhost\",\n        port = 5432,\n        databaseName = \"mydb\",\n        username = \"user\",\n        password = \"pass\",\n        runMigrations = false, // Schema already exists\n        configureExposedConfiguration = { cfg -&gt; listOf(/* ... */) }\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/11-provided-instances/#limitations","title":"Limitations","text":"<p>When using provided instances, some operations are not available:</p> <ul> <li><code>pause()</code> - Cannot pause an external instance</li> <li><code>unpause()</code> - Cannot unpause an external instance</li> <li><code>inspect()</code> - Container inspection not available</li> </ul> <p>These methods will log a warning and return without effect when called on a provided instance.</p>"},{"location":"Components/11-provided-instances/#complete-example","title":"Complete Example","text":"<p>Here's a complete setup for a CI/CD pipeline using provided instances:</p> <pre><code>class TestSetup : AbstractProjectConfig() {\n  override suspend fun beforeProject() {\n    TestSystem()\n      .with {\n        httpClient {\n          HttpClientSystemOptions(baseUrl = \"http://localhost:8080\")\n        }\n        bridge()\n        couchbase {\n          CouchbaseSystemOptions.provided(\n            connectionString = System.getenv(\"COUCHBASE_CONNECTION_STRING\"),\n            username = System.getenv(\"COUCHBASE_USERNAME\"),\n            password = System.getenv(\"COUCHBASE_PASSWORD\"),\n            defaultBucket = \"app-bucket\",\n            runMigrations = true,\n            cleanup = { cluster -&gt;\n              cluster.query(\"DELETE FROM `app-bucket` WHERE _type = 'test'\")\n            },\n            configureExposedConfiguration = { cfg -&gt;\n              listOf(\n                \"couchbase.hosts=${cfg.hostsWithPort}\",\n                \"couchbase.username=${cfg.username}\",\n                \"couchbase.password=${cfg.password}\"\n              )\n            }\n          )\n        }\n        kafka {\n          KafkaSystemOptions.provided(\n            bootstrapServers = System.getenv(\"KAFKA_BOOTSTRAP_SERVERS\"),\n            configureExposedConfiguration = { cfg -&gt;\n              listOf(\n                \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n                \"kafka.interceptorClasses=${cfg.interceptorClass}\"\n              )\n            }\n          )\n        }\n        springBoot(\n          runner = { params -&gt;\n            com.example.Application.run(params)\n          }\n        )\n      }\n      .run()\n  }\n\n  override suspend fun afterProject() {\n    TestSystem.stop()\n  }\n}\n</code></pre>"},{"location":"Components/11-provided-instances/#test-isolation-with-shared-infrastructure","title":"Test Isolation with Shared Infrastructure","text":"<p>Critical: Prevent Test Run Collisions</p> <p>When using provided instances (shared infrastructure), multiple test runs can interfere with each other if they use the same resource names. This is especially important in CI/CD pipelines where parallel builds may run against the same infrastructure.</p>"},{"location":"Components/11-provided-instances/#the-problem","title":"The Problem","text":"<p>Consider this scenario: - Build #1 creates records in <code>orders</code> table - Build #2 starts while Build #1 is still running - Build #2 reads Build #1's test data \u2192 Test failures! - Both builds try to create the same Kafka topic \u2192 Conflicts!</p>"},{"location":"Components/11-provided-instances/#the-solution-unique-resource-prefixes","title":"The Solution: Unique Resource Prefixes","text":"<p>Generate unique prefixes for each test run and use them for all resource names:</p> <pre><code>object TestRunContext {\n    // Unique prefix for this test run\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: System.getenv(\"BUILD_NUMBER\")\n        ?: UUID.randomUUID().toString().take(8)\n\n    // Resource names with unique prefixes\n    val databaseName = \"testdb_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n    val bucketPrefix = \"test_${runId}_\"\n    val cacheKeyPrefix = \"test:$runId:\"\n}\n</code></pre>"},{"location":"Components/11-provided-instances/#implementation-by-system","title":"Implementation by System","text":""},{"location":"Components/11-provided-instances/#postgresql-mssql-unique-database","title":"PostgreSQL / MSSQL - Unique Database","text":"<pre><code>TestSystem()\n    .with {\n        postgresql {\n            PostgresqlOptions.provided(\n                jdbcUrl = \"jdbc:postgresql://shared-db:5432/${TestRunContext.databaseName}\",\n                host = \"shared-db\",\n                port = 5432,\n                databaseName = TestRunContext.databaseName,\n                username = \"postgres\",\n                password = \"postgres\",\n                runMigrations = true,  // Creates tables in unique database\n                cleanup = { ops -&gt;\n                    // Optional: cleanup is less critical with unique database\n                    ops.execute(\"DROP SCHEMA public CASCADE; CREATE SCHEMA public;\")\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\"spring.datasource.url=${cfg.jdbcUrl}\")\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"spring.datasource.url=jdbc:postgresql://shared-db:5432/${TestRunContext.databaseName}\"\n            )\n        )\n    }\n</code></pre> <p>Database Creation</p> <p>You can create the database using Stove's migration system: <pre><code>class CreateDatabaseMigration : DatabaseMigration&lt;PostgresSqlMigrationContext&gt; {\n    override val order: Int = 0  // Run first\n\n    override suspend fun execute(connection: PostgresSqlMigrationContext) {\n        connection.operations.execute(\n            \"CREATE DATABASE IF NOT EXISTS ${TestRunContext.databaseName}\"\n        )\n    }\n}\n</code></pre></p> <p>Multiple Databases</p> <p>If your application uses multiple databases in production (e.g., separate databases for users, orders, analytics), you can create all of them via migrations and expose separate connection URLs:</p> <pre><code>configureExposedConfiguration = { cfg -&gt;\n    val baseUrl = \"jdbc:postgresql://${cfg.host}:${cfg.port}\"\n    listOf(\n        \"db.users.url=$baseUrl/users_${TestRunContext.runId}\",\n        \"db.orders.url=$baseUrl/orders_${TestRunContext.runId}\",\n        \"db.analytics.url=$baseUrl/analytics_${TestRunContext.runId}\",\n        // ... common credentials\n    )\n}\n</code></pre> <p>See PostgreSQL - Multiple Databases for a complete guide.</p>"},{"location":"Components/11-provided-instances/#kafka-unique-topic-prefix","title":"Kafka - Unique Topic Prefix","text":"<pre><code>TestSystem()\n    .with {\n        kafka {\n            KafkaSystemOptions.provided(\n                bootstrapServers = \"shared-kafka:9092\",\n                topicSuffixes = TopicSuffixes(\n                    // These are suffixes for error/retry topics\n                    error = \".error\",\n                    retry = \".retry\"\n                ),\n                cleanup = { admin -&gt;\n                    // Delete only topics with our prefix\n                    val ourTopics = admin.listTopics().names().get()\n                        .filter { it.startsWith(TestRunContext.topicPrefix) }\n                    if (ourTopics.isNotEmpty()) {\n                        admin.deleteTopics(ourTopics).all().get()\n                    }\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"kafka.bootstrapServers=${cfg.bootstrapServers}\",\n                        \"kafka.topicPrefix=${TestRunContext.topicPrefix}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                // Application uses this prefix for all topic names\n                \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n                \"kafka.topic.payments=${TestRunContext.topicPrefix}payments\",\n                \"kafka.topic.notifications=${TestRunContext.topicPrefix}notifications\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#elasticsearch-unique-index-prefix","title":"Elasticsearch - Unique Index Prefix","text":"<pre><code>TestSystem()\n    .with {\n        elasticsearch {\n            ElasticsearchSystemOptions.provided(\n                host = \"shared-elasticsearch\",\n                port = 9200,\n                password = \"\",\n                runMigrations = true,\n                cleanup = { esClient -&gt;\n                    // Delete only indices with our prefix\n                    esClient.indices().delete { \n                        it.index(\"${TestRunContext.indexPrefix}*\") \n                    }\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"elasticsearch.host=${cfg.host}\",\n                        \"elasticsearch.indexPrefix=${TestRunContext.indexPrefix}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\",\n                \"elasticsearch.index.orders=${TestRunContext.indexPrefix}orders\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#couchbase-unique-document-prefix-or-scope","title":"Couchbase - Unique Document Prefix or Scope","text":"<pre><code>TestSystem()\n    .with {\n        couchbase {\n            CouchbaseSystemOptions.provided(\n                connectionString = \"couchbase://shared-couchbase:8091\",\n                username = \"admin\",\n                password = \"password\",\n                defaultBucket = \"shared-bucket\",\n                runMigrations = true,\n                cleanup = { cluster -&gt;\n                    // Delete only documents with our prefix\n                    cluster.query(\n                        \"DELETE FROM `shared-bucket` WHERE META().id LIKE '${TestRunContext.bucketPrefix}%'\"\n                    )\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"couchbase.documentPrefix=${TestRunContext.bucketPrefix}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"couchbase.documentPrefix=${TestRunContext.bucketPrefix}\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#mongodb-unique-database-or-collection-prefix","title":"MongoDB - Unique Database or Collection Prefix","text":"<pre><code>TestSystem()\n    .with {\n        mongodb {\n            MongodbSystemOptions.provided(\n                connectionString = \"mongodb://shared-mongo:27017\",\n                host = \"shared-mongo\",\n                port = 27017,\n                cleanup = { client -&gt;\n                    // Drop our unique database\n                    client.getDatabase(TestRunContext.databaseName).drop()\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"mongodb.database=${TestRunContext.databaseName}\"\n                    )\n                }\n            )\n        }\n        springBoot(\n            withParameters = listOf(\n                \"spring.data.mongodb.database=${TestRunContext.databaseName}\"\n            )\n        )\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#redis-unique-key-prefix-or-database-number","title":"Redis - Unique Key Prefix or Database Number","text":"<pre><code>TestSystem()\n    .with {\n        redis {\n            // Use unique database number (0-15) or key prefix\n            val redisDb = (TestRunContext.runId.hashCode() and 0xF)  // 0-15\n\n            RedisOptions.provided(\n                host = \"shared-redis\",\n                port = 6379,\n                password = \"\",\n                database = redisDb,\n                cleanup = { client -&gt;\n                    // Flush only our database\n                    client.connect().sync().flushdb()\n                },\n                configureExposedConfiguration = { cfg -&gt;\n                    listOf(\n                        \"spring.redis.database=$redisDb\"\n                    )\n                }\n            )\n        }\n    }\n</code></pre>"},{"location":"Components/11-provided-instances/#complete-cicd-example","title":"Complete CI/CD Example","text":"<pre><code>object TestRunContext {\n    val runId: String = System.getenv(\"CI_JOB_ID\") \n        ?: System.getenv(\"GITHUB_RUN_ID\")\n        ?: System.getenv(\"BUILD_NUMBER\")\n        ?: UUID.randomUUID().toString().take(8)\n\n    val databaseName = \"test_$runId\"\n    val topicPrefix = \"test_${runId}_\"\n    val indexPrefix = \"test_${runId}_\"\n    val keyPrefix = \"test:$runId:\"\n\n    init {\n        println(\"Test Run ID: $runId\")\n        println(\"Database: $databaseName\")\n        println(\"Topic Prefix: $topicPrefix\")\n    }\n}\n\nclass TestConfig : AbstractProjectConfig() {\n    override suspend fun beforeProject() {\n        TestSystem()\n            .with {\n                postgresql {\n                    PostgresqlOptions.provided(\n                        jdbcUrl = \"jdbc:postgresql://db:5432/${TestRunContext.databaseName}\",\n                        databaseName = TestRunContext.databaseName,\n                        // ... other config\n                    )\n                }\n                kafka {\n                    KafkaSystemOptions.provided(\n                        bootstrapServers = \"kafka:9092\",\n                        cleanup = { admin -&gt;\n                            val topics = admin.listTopics().names().get()\n                                .filter { it.startsWith(TestRunContext.topicPrefix) }\n                            if (topics.isNotEmpty()) admin.deleteTopics(topics).all().get()\n                        },\n                        // ... other config\n                    )\n                }\n                elasticsearch {\n                    ElasticsearchSystemOptions.provided(\n                        host = \"elasticsearch\",\n                        port = 9200,\n                        cleanup = { es -&gt;\n                            es.indices().delete { it.index(\"${TestRunContext.indexPrefix}*\") }\n                        },\n                        // ... other config\n                    )\n                }\n                springBoot(\n                    runner = { params -&gt; myApp.run(params) },\n                    withParameters = listOf(\n                        \"spring.datasource.url=jdbc:postgresql://db:5432/${TestRunContext.databaseName}\",\n                        \"kafka.topic.orders=${TestRunContext.topicPrefix}orders\",\n                        \"elasticsearch.index.products=${TestRunContext.indexPrefix}products\"\n                    )\n                )\n            }\n            .run()\n    }\n\n    override suspend fun afterProject() {\n        TestSystem.stop()\n        // Resources cleaned up by cleanup functions\n    }\n}\n</code></pre>"},{"location":"Components/11-provided-instances/#best-practices-for-test-isolation","title":"Best Practices for Test Isolation","text":"Practice Description Use CI Job ID Most CI systems provide unique job/build IDs - use them Prefix everything Database names, topics, indices, keys - all should be unique Clean up after Use cleanup functions to remove test data Short prefixes Keep prefixes short but unique (8 chars usually enough) Log the prefix Print the run ID at test start for debugging Application support Your app must read resource names from configuration"},{"location":"Components/11-provided-instances/#debugging-isolation-issues","title":"Debugging Isolation Issues","text":"<p>If tests fail intermittently in CI:</p> <ol> <li> <p>Check for hardcoded names: <pre><code>// \u274c Bad - hardcoded\nval topic = \"orders\"\n\n// \u2705 Good - configurable\nval topic = config.getString(\"kafka.topic.orders\")\n</code></pre></p> </li> <li> <p>Verify cleanup runs: <pre><code>cleanup = { admin -&gt;\n    println(\"Cleaning up topics with prefix: ${TestRunContext.topicPrefix}\")\n    // ... cleanup code\n}\n</code></pre></p> </li> <li> <p>Check parallel job interference: <pre><code># In CI logs, look for overlapping run IDs\ngrep \"Test Run ID\" build-*.log\n</code></pre></p> </li> </ol>"},{"location":"migration/notes/","title":"Migration Notes","text":""},{"location":"migration/notes/#from-014x-to-015x","title":"From 0.14.x to 0.15.x","text":""},{"location":"migration/notes/#breaking-changes","title":"Breaking Changes","text":"<p>The most notable breaking change is ser/de operations. The framework was only relying on Jackson for serialization and deserialization. Now, it provides a way to use other serialization libraries. <code>StoveSerde&lt;TIn, TOut&gt;</code> is the new interface that you can implement to provide your own serialization and deserialization logic.</p> <p><code>StoveSerde</code> also provides the access to the other serializers that <code>com-trendyol:stove-testing-e2e</code> package has.</p> <ul> <li>Jackson</li> <li>Gson</li> <li>Kotlinx</li> </ul> <p>Also look at ser/de section: Serialization and Deserialization</p>"},{"location":"migration/notes/#spring-kafka-com-trendyolstove-spring-testing-e2e-kafka","title":"Spring Kafka (com-trendyol:stove-spring-testing-e2e-kafka)","text":"<p>The <code>TestSystemKafkaInterceptor</code> now depends on <code>StoveSerde</code> to provide the serialization and deserialization logic instead of <code>ObjectMapper</code>.</p> <p>You can of course use your default Jackson implementation by providing the <code>ObjectMapperConfig.default()</code> to the <code>StoveSerde.jackson.anyByteArraySerde</code> function.</p> <pre><code>class TestSystemInitializer : BaseApplicationContextInitializer({\n  bean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;(isPrimary = true)\n  bean { StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfig.default()) } // or any other serde that is &lt;Any, ByteArray&gt;\n})\n</code></pre>"},{"location":"migration/notes/#standalone-kafka","title":"Standalone Kafka","text":"<pre><code>kafka {\n  KafkaSystemOptions(\n    serde = StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfig.default) // or any other serde that is &lt;Any, ByteArray&gt;\n    //...\n  )\n}\n</code></pre>"},{"location":"migration/notes/#couchbase","title":"Couchbase","text":"<pre><code>couchbase {\n  CouchbaseSystemOptions(\n    clusterSerDe = JacksonJsonSerializer(CouchbaseConfiguration.objectMapper), // here you can provide your own serde\n    //...\n  )\n}\n</code></pre>"},{"location":"migration/notes/#http","title":"Http","text":"<pre><code> httpClient {\n  HttpClientSystemOptions(\n    baseUrl = \"http://localhost:8001\",\n    contentConverter = JacksonConverter(ObjectMapperConfig.default)\n  )\n}\n</code></pre>"},{"location":"migration/notes/#wiremock","title":"Wiremock","text":"<pre><code>wiremock {\n  WireMockSystemOptions(\n    port = 9090,\n    serde = StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfiguration.default)\n  )\n</code></pre>"},{"location":"migration/notes/#elasticsearch","title":"Elasticsearch","text":"<pre><code>elasticsearch {\n  ElasticsearchSystemOptions(\n    jsonpMapper = JacksonJsonpMapper(StoveSerde.jackson.default), // or any JsonpMapper\n  )\n}\n</code></pre>"},{"location":"migration/notes/#mongodb","title":"Mongodb","text":"<pre><code>mongodb {\n  MongoDbSystemOptions(\n    serde = StoveSerde.jackson.default // or any other serde that you implement\n  )\n}\n</code></pre> <p>The default serde is: <pre><code>  val serde: StoveSerde&lt;Any, String&gt; = StoveSerde.jackson.anyJsonStringSerde(\n    StoveSerde.jackson.byConfiguring {\n      disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n      enable(MapperFeature.DEFAULT_VIEW_INCLUSION)\n      addModule(ObjectIdModule())\n      addModule(KotlinModule.Builder().build())\n    }\n  ),\n</code></pre></p>"}]}