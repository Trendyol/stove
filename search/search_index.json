{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Stove","text":"<p>Stove is an end-to-end testing framework that spins up physical dependencies and your application all together. So you have a control over dependencies via Kotlin code.</p> <p>In the JVM world, thanks to code interoperability, you application code and test can be written with different JVM languages and can be run together. For example, you can write your application code with Java and write your tests with Kotlin, or Application code with Scala and test with Kotlin, etc. Stove uses this ability and provides a way to write your tests in Kotlin.</p> <p>Your tests will be infra agnostic, but component aware, so they can use easily necessary physical components with Stove provided APIs. All the infra is pluggable, and can be added easily. You can also create your own infra needs by using the abstractions that Stove provides. Having said that, the only dependency is <code>docker</code> since Stove is using testcontainers underlying.</p> <p>You can use JUnit and Kotest for running the tests. You can run all the tests on your CI, too. But that needs DinD(docker-in-docker) integration.</p> <p>The medium story about the motivation behind the framework: A New Approach to the API End-to-End Testing in Kotlin</p> <p>Note: Stove is not a replacement for the unit tests, it is a framework for end-to-end/component tests.</p>"},{"location":"#what-is-the-problem","title":"What is the problem?","text":"<p>In the JVM world, we have a lot of frameworks for the application code, but when it comes to integration/component/e2e testing we don't have a single framework that can be used for all the tech stacks. We have testcontainers but you still need to do lots of plumbing to make it work with your tech stack.</p> <p>The use-cases that led us develop the Stove are to increase the productivity of the developers while keeping the quality of the codebase high and coherent.</p> <p>Those use-cases are:</p> <ul> <li>Kotlin app with Spring-Boot</li> <li>Kotlin app with Ktor</li> <li>Java app with Spring-Boot</li> <li>Java app with Micronaut</li> <li>Java app with Quarkus</li> <li>Scala app with Spring-Boot</li> </ul> <p>People have different tech stacks and each time when they want to write e2e tests, they need to write a lot of boilerplate code. Alongside the physical components that are needed to be started, we need to write the code to start the application, and the code to access the beans of the application. Stove is here to solve this problem. It provides a single API to write e2e tests for all the tech stacks.</p> <p>Stove unifies the testing experience whatever you use.</p>"},{"location":"#high-level-architecture","title":"High Level Architecture","text":""},{"location":"#how-to-build-the-source-code","title":"How to build the source code?","text":"<ul> <li>JDK 17+</li> <li>Docker for running the tests (please use the latest version)</li> </ul> <pre><code>./gradlew build # that will build and run the tests\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#pre-requisites","title":"Pre-requisites","text":"<ul> <li>JDK 17+</li> <li>Docker for running the tests (please use the latest version)</li> <li>Kotlin 1.8+</li> <li>Gradle or Maven for running the tests, but Gradle is recommended.<ul> <li>Gradle is the default build tool for Stove, and it is used in the examples.</li> <li>If you are using Intellij IDEA, Kotest plugin is recommended.</li> </ul> </li> </ul> <p>The framework still under development and is getting matured. It is working well and in use at Trendyol. Besides, the Stove tests are highly likely going to be located under your testing context and the folder, so, it is risk-free to apply and use, give it a try!</p> <p><code>$version = please check the current version</code></p> <p>Versions are available at Releases</p> <p>Tip</p> <p>You can use SNAPSHOT versions for the latest features. You can add the following repository to your build file. SNAPSHOT versions released with the <code>1.0.0.{buildNumber}-SNAPSHOT</code> strategy.</p> <pre><code>repositories {\n    maven {\n        url = uri(\"https://oss.sonatype.org/content/repositories/snapshots/\")\n    }\n}\n</code></pre> <p>Every physical component that your testing needs is a separate module in Stove. You can add them according to your needs. Stove supports the following components:</p> <ul> <li>Kafka</li> <li>MongoDB</li> <li>MSSQL</li> <li>PostgreSQL</li> <li>Redis</li> <li>Elasticsearch</li> <li>Couchbase</li> <li>Wiremock</li> <li>HTTP</li> </ul> Gradle <pre><code>repositories {\n  mavenCentral()\n}\n\ndependencies {\n  // Application Under Test\n\n  // Spring Boot\n  testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n\n  // or\n\n  // Ktor\n  testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$version\")\n\n  // Components\n  testImplementation(\"com.trendyol:stove-testing-e2e:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-mongodb:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-mssql:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-postgresql:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-redis:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-elasticsearch:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-couchbase:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-wiremock:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n}\n</code></pre>"},{"location":"#how-to-write-tests","title":"How To Write Tests?","text":"<p>Stove uses your application entrance point to start your application alongside the physical components. The application's <code>main</code> is the entrance point for the applications in general.</p> <p>Everything starts with the <code>TestSystem</code> class. You can configure your system with the <code>with</code> function.</p> <pre><code>TestSystem()\n  .with {\n    // your configurations depending on the dependencies you need\n  }.run()\n</code></pre> <p><code>with</code> function is a lambda that you can configure your system. You can add your physical components. It is also a place to plug your custom systems that you might want to create. If you added <code>com.trendyol:stove-testing-e2e-kafka</code> package, you can use <code>kafka</code> function in the <code>with</code> block.</p> <pre><code>TestSystem()\n  .with {\n    kafka {\n      // your kafka configurations\n    }\n  }.run()\n</code></pre> <p>Note</p> <p>You can add multiple physical components in the <code>with</code> block. Think of it as a DSL for your test system and a <code>docker-compose</code> in Kotlin.</p> <p>Tip</p> <p>If you want to jump directly to the examples, you can check the examples in the repository.</p> <ul> <li> <p>Examples</p> <ul> <li>Ktor Example</li> <li>Spring Boot Example</li> <li>Spring Boot with Standalone Kafka</li> </ul> </li> <li> <p>Recipes</p> <ul> <li>Java Recipes</li> <li>Kotlin Recipes</li> <li>Scala Recipes</li> </ul> </li> </ul> <p>Stove has the concept of \"Application Aware Testing\". It means that Stove is aware of the application's entrance point and that is the only information it needs to start the application.</p> <p>Application that is being tested is a Spring Boot, Ktor, Micronaut, Quarkus, etc. and is called \"Application Under Test (AUT)\".</p> <p>The tests are agnostic to the application's framework. Right now Stove supports Spring Boot, Ktor. But it is easy to add new frameworks.</p> <p>Note</p> <p>If you want to add a new framework, you can check the <code>com.trendyol.stove.testing.e2e.system.abstractions.ApplicationUnderTest</code> interface. You can implement this interface for your framework.</p> <p>Let's create an example for a Spring-Boot application with Kafka and explain the setup flow.</p> <p>The dependencies we will need in the <code>build.gradle.kts</code> file are:</p> <pre><code> dependencies {\n  testImplementation(\"com.trendyol:stove-testing-e2e:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n  testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n  testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n}\n</code></pre> <pre><code>TestSystem()\n  .with {\n    httpClient {\n      HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8001\"\n      )\n    }\n\n    kafka {\n      KafkaSystemOptions(\n        containerOptions = KafkaContainerOptions(tag = \"latest\"),\n      ) {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.isSecure=false\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\",\n          \"kafka.heartbeatInSeconds=2\",\n          \"kafka.autoCreateTopics=true\",\n          \"kafka.offset=earliest\",\n          \"kafka.secureKafka=false\"\n        )\n      }\n    }\n\n    bridge()\n\n    springBoot( // Application Under Test\n      runner = { parameters -&gt;\n        stove.spring.standalone.example.run(parameters)\n      },\n      withParameters = listOf(\n        \"server.port=8001\",\n        \"logging.level.root=info\",\n        \"logging.level.org.springframework.web=info\",\n        \"spring.profiles.active=default\",\n      )\n    )\n  }\n  .run()\n</code></pre> <p>The typical setup for a Spring Boot application with Kafka is like this. You can see that we have a <code>httpClient</code>function that is used for the HTTP client against the application's endpoints. Then we have a <code>kafka</code> function that is used for the Kafka setup. Then we have a <code>bridge</code> function that is used for accessing the DI container of the application. Then we have a <code>springBoot</code> function that is used for the Spring Boot application setup.</p>"},{"location":"#httpclient-function","title":"<code>httpClient</code> function","text":"<p>It is used for the HTTP client against the application's endpoints. You can configure the base URL of the application. When the application is started, the base URL is used for the HTTP client.</p>"},{"location":"#kafka-function","title":"<code>kafka</code> function","text":"<p>It is used for the Kafka setup. You can configure the Kafka container options and the Kafka properties. When the application is started, the Kafka container is started and the Kafka properties are used for the application. We will investigate the Kafka setup in detail in the Kafka section. Your application code should be able to read these properties, and event app code needs to be arranged for this.</p> <p>Is my application code e2e testing friendly?</p> <p>In general, to write proper unit tests your code should be testable.  This means extracting dependencies to interfaces and using dependency injection. </p> <p>Injecting time, configuration, and other dependencies is a good practice.  This makes your classes testable and you can easily replace the implementations of the interfaces in the tests.</p> <p>Changing your configuration to be able to read from the environment variables or CLI arguments is also a good practice. Since Stove is also passing down the test configurations and the optimum setup for the tests, your application should be able to read these configurations.</p> <p>So, don't think that you're changing too much application code just for sake of the Stove tests, you're making your application code e2e test friendly.</p>"},{"location":"#bridge-function","title":"<code>bridge</code> function","text":"<p>This function is used for accessing the DI container of the application. When the application is started, the bridge is created and the DI container is accessed in the tests.</p> <p>If you want to access to the beans of the application, you can simply do:</p> <pre><code>TestSystem.validate {\n  using&lt;UserApplicationService&gt; {\n    this.getUserById(1) shouldBe User(1, \"John\", \"Doe\")\n  }\n\n  using&lt;ProductDomainService, ProductRepository&gt; { productDomainService, productRepository -&gt;\n    productDomainService.getProductById(1) shouldBe Product(1, \"Product 1\")\n    productRepository.findById(1) shouldBe Product(1, \"Product 1\")\n  }\n}\n</code></pre>"},{"location":"#springboot-function","title":"<code>springBoot</code> function","text":"<p>This function is used for the Spring Boot application setup. You can configure the runner function and the parameters of the application. When the application is started, the runner function is called with the parameters. The parameters you see in <code>runner</code> function are the parameters that are passed to the Spring Boot application when it is started. Each physical component exposes its own properties and you can use them in the application. Here:</p> <pre><code>kafka {\n  KafkaSystemOptions(\n    containerOptions = KafkaContainerOptions(tag = \"latest\"),\n  ) {\n    listOf(\n      \"kafka.bootstrapServers=${it.bootstrapServers}\",\n      \"kafka.isSecure=false\",\n      \"kafka.interceptorClasses=${it.interceptorClass}\",\n      \"kafka.heartbeatInSeconds=2\",\n      \"kafka.autoCreateTopics=true\",\n      \"kafka.offset=earliest\",\n      \"kafka.secureKafka=false\"\n    )\n  }\n}\n</code></pre> <p>The list of properties are exposed by the Kafka component and you can use them in the application. The reference <code>it</code> in this block is the physical component itself and it's exposed properties. Whenever Kafka and testing suite start, the properties are changed and passed down to the application.</p>"},{"location":"#run-function","title":"<code>run</code> function","text":"<p>Runs the entire setup. It starts the physical components and the application.</p> <p>Run the Setup Once</p> <p>You should run the setup once in your test suite. You can run it in the <code>@BeforeAll</code> function of JUnit or implement <code>AbstractProjectConfig#beforeProject</code> in Kotest. Teardown is also important to call. You can run it in the <code>@AfterAll</code> function of JUnit or implement <code>AbstractProjectConfig#afterProject</code> in Kotest. Simply calling <code>TestSystem.stop()</code> is enough to stop the setup.</p>"},{"location":"#writing-tests","title":"Writing Tests","text":"<p>After the setup is done, you can write your tests. You can use the <code>validate</code> function to write your tests.</p> <pre><code>TestSystem.validate {\n  http {\n    get&lt;String&gt;(\"/hello/index\") { actual -&gt;\n      actual shouldContain \"Hi from Stove framework\"\n    }\n  }\n\n  kafka {\n    shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt;\n      actual.productId == 1\n    }\n  }\n\n  using&lt;UserApplicationService&gt; {\n    this.getUserById(1) shouldBe User(1, \"John\", \"Doe\")\n  }\n\n  using&lt;ProductDomainService, ProductRepository&gt; { productDomainService, productRepository -&gt;\n    productDomainService.getProductById(1) shouldBe Product(1, \"Product 1\")\n    productRepository.findById(1) shouldBe Product(1, \"Product 1\")\n  }\n\n  kafka {\n    shouldBePublished&lt;ProductCreatedEvent&gt; { actual -&gt;\n      actual.productId == 1\n    }\n  }\n}\n</code></pre> <p>That's it! You have up-and-running API, can be tested with Stove. And each test is independent of each other. But they share the same instance of physical component of course, so you need to provide random data for each test. This is a good practice for the tests to be independent of each other.</p>"},{"location":"#application-aware-testing","title":"Application Aware Testing","text":"<p>Stove is aware of your application either it is SpringBoot or Ktor, and it is aware of the entrance point of your application.</p> <p>There are entry point for every application, usually a <code>main</code> method that is invoked, and starts the application lifecycle.</p> <p>If you are publishing your <code>application</code> as a docker image, <code>docker run ...</code> basically runs your application highly likely with a <code>jvm/java</code> command.</p> <p>In this approach, we're using the same <code>main</code> function of your application in the test context to run the application as full-blown as if it is invoked from outside.</p> <p>Stove calls your application's <code>main</code> function like you would call <code>java yourApplicationName.jar --param1 --param2</code> to run the application from the test context. So the runner is JUnit or Kotest.</p> <p>For Stove to attach properly to your application, application's main function needs to allow that. This does not change behaviour at all, it just opens a door for e2e testing framework to enter.</p> <p>This approach has lots of benefits besides of providing a debug ability while e2e testing. You can:</p> <ul> <li>Debug the application code</li> <li>Replace the implementations of the interfaces. Useful for time-bounded implementations such as schedulers, background   workers, and time itself.   you would only have consuming.</li> <li>Use and expose application's dependency container to the test context. You can access the beans of the application   easily. Using <code>bridge</code> functionality.</li> </ul>"},{"location":"#spring-boot","title":"Spring Boot","text":"<p>You need to add the Stove-Spring dependency to be able to write e2e tests for the Spring application.</p> Gradle <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-spring-testing-e2e:$version\")\n\n    // You can add other components if you need\n}\n</code></pre>"},{"location":"#tuning-the-applications-entry-point","title":"Tuning the application's entry point","text":"<p>Let's say the application has a standard <code>main</code> function, here how we will change it:</p> BeforeAfter <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { runApplication&lt;ExampleApplication&gt;(*args) }\n</code></pre> <pre><code>@SpringBootApplication\nclass ExampleApplication\n\nfun main(args: Array&lt;String&gt;) { run(args) }\n\nfun run(\n     args: Array&lt;String&gt;,\n     init: SpringApplication.() -&gt; Unit = {},\n  ): ConfigurableApplicationContext {\n        return runApplication&lt;ExampleApplication&gt;(*args, init = init)\n    }\n</code></pre> <p>As you can see from <code>before-after</code> sections, we have divided the application main function into two parts.</p> <p><code>run(args, init)</code> method is the important point for the testing configuration. <code>init</code> allows us to override any dependency from the testing side that is being <code>time</code> related or <code>configuration</code> related. Spring itself opens this configuration higher order function to the outside.</p> <p>Also returning <code>ConfigurableApplicationContext</code> is important for the <code>bridge</code> functionality that we will use in the tests.</p> <p>Tip</p> <p>Here you can jump immediately to the Spring example application.</p>"},{"location":"#initial-configuration","title":"Initial Configuration","text":"<p>After you've added the dependencies, and configured the application's <code>main</code> function, it is time to run your application for the first time from the test-context with Stove.</p>"},{"location":"#setting-up-stove-for-the-runner","title":"Setting up Stove for the Runner","text":"KotestJUnit <p>It implements <code>AbstractProjectConfig</code> from Kotest framework that allows us to spin up Stove per run. This is project wide operation and executes only one time, as the name implies <code>beforeProject</code>.</p> <pre><code>class Stove : AbstractProjectConfig() {    \n    override suspend fun beforeProject(): Unit = \n        TestSystem()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions (\n                        baseUrl = \"http://localhost:8001\"\n                    )\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n\n    override suspend fun afterProject(): Unit = TestSystem.stop()\n}\n</code></pre> <pre><code>class TestSystemConfig {\n\n    @BeforeAll\n    fun beforeProject() = runBlocking {\n         TestSystem()\n            .with {\n                httpClient {\n                    HttpClientSystemOptions (\n                        baseUrl = \"http://localhost:8001\"\n                    )\n                }\n                springBoot(\n                    runner = { parameters -&gt;\n                        /* \n                        *  As you remember, we have divided application's main \n                        *  function into two parts, main and run. \n                        *  We use `run` invocation here.\n                        * */\n                        stove.spring.example.run(parameters)\n                    },\n                    withParameters = listOf(\n                        \"server.port=8001\",\n                        \"logging.level.root=warn\",\n                        \"logging.level.org.springframework.web=warn\",\n                        \"spring.profiles.active=default\"\n                    )\n                )\n            }.run()\n    }\n\n    @AfterAll\n    fun afterProject() = runBlocking {\n        TestSystem.stop()\n    }\n}\n</code></pre> <p>In the section of <code>springBoot</code> function, we have configured the application's entry point, and the parameters that are passed to the application. <code>stove.spring.example.run(parameters)</code> is the entrance point of the application.</p> <p>Like the concept of <code>service under test</code> from the Test-Driven-Development. Here we have the similar concept, since we're testing the entire system, it is called <code>Application Under Test</code></p> <p>In here we're configuring the Spring Boot application as application under test.</p> <p>Note</p> <p><code>server.port=8001</code> is a Spring config, TestSystem's <code>baseUrl</code> needs to match with it, since Http requests are made  against the <code>baseUrl</code> that is defined. <code>withDefaultHttp</code> creates a WebClient and uses the <code>baseUrl</code> that is passed.</p>"},{"location":"#writing-tests_1","title":"Writing Tests","text":"<p>Here is an example test that validates <code>http://localhost:$port/hello/index</code> returns the expected text</p> KotestJUnit <pre><code>class ExampleTest: FunSpec({\n\n    test(\"should return hi\"){\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n})\n</code></pre> <pre><code>class ExampleTest {\n\n    @Test\n    fun `should return hi`() {\n        TestSystem.validate {\n            http {\n                get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n                    actual shouldContain \"Hi from Stove framework\" \n                }\n            }\n    }\n})\n</code></pre> <p>That's it! You have up-and-running API, can be tested with Stove.</p> <p>Tip</p> <p>DSL scopes can appear more than once while writing the tests.  You can access to any DSL assertion scope such as http, kafka, using, etc. as many times as you need.</p> <p>Example:</p> <pre><code>TestSystem.validate {\n    http {\n        get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n            actual shouldContain \"Hi from Stove framework\" \n        }\n    }\n\n    kafka {\n        shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt; \n            actual.productId == 1\n        }\n    }\n\n    kafka {\n        shouldBeConsumed&lt;ProductCreatedEvent&gt; { actual -&gt; \n            actual.productId == 1\n        }\n    }\n\n    http {\n        get&lt;String&gt;(\"/hello/index\") { actual -&gt; \n            actual shouldContain \"Hi from Stove framework\" \n        }\n    }\n\n    using&lt;UserApplicationService&gt; {\n        this.getUserById(1) shouldBe\n    }\n</code></pre>"},{"location":"#ktor","title":"Ktor","text":"Gradle <pre><code>dependencies {\n    testImplementation(\"com.trendyol:stove-ktor-testing-e2e:$version\")\n\n    // You can add other components if you need\n}\n</code></pre>"},{"location":"#example-setup","title":"Example Setup","text":"<pre><code>TestSystem()\n  .with {\n    // You can add other components if you need\n    // We removed for simplicity\n\n    ktor(\n      withParameters = listOf(\n        \"port=8080\"\n      ),\n      runner = { parameters -&gt;\n        stove.ktor.example.run(parameters) {\n          addTestSystemDependencies()\n        }\n      }\n    )\n  }.run()\n</code></pre> <p>After you've added <code>stove-ktor-testing-e2e</code> dependency, and configured the application's <code>main</code> function for Stove to enter, it is time to run your application for the first time from the test-context with Stove.</p>"},{"location":"#tuning-the-applications-entry-point_1","title":"Tuning the application's entry point","text":"<p>Let's say the application has a standard <code>main</code> function, here how we will change it:</p> BeforeAfter <pre><code>fun main() {\n  embeddedServer(Netty, port = 8080) {\n      routing {\n          get(\"/\") {\n              call.respondText(\"Hello, world!\")\n          }\n      }\n   }.start(wait = true)\n}\n</code></pre> <pre><code>object ExampleApp {\n  @JvmStatic\n  fun main(args: Array&lt;String&gt;) {\n     run(args)\n  }\n\n fun run(args: Array&lt;String&gt;, \n        wait: Boolean = true, \n        configure: org.koin.core.module.Module = module { }\n    ): Application {\n     val config = loadConfiguration&lt;Env&gt;(args)\n     return startKtorApplication(config, wait) {\n         appModule(config, configure)\n     }\n  }\n}\n</code></pre> <p>As you can see from <code>before-after</code> sections, we have divided the application main function into two parts. <code>run(args, wait, configure)</code> method is the important point for the testing configuration. <code>configure</code> allows us to override any dependency from the testing side that is being <code>time</code> related or <code>configuration</code> related.</p> <p>Note</p> <p>There are helper methods here for example loadConfiguration  that is used to load the configuration from the environment variables or CLI arguments. And as you can see there is an <code>Env</code> data class to cast the configuration.  Stove itself does not provide them, but of course we have already used them in our examples, you can find them in the examples.</p> <p>Tip</p> <p>Here you can jump immediately to the Ktor example application.</p>"},{"location":"#advanced","title":"Advanced","text":""},{"location":"#serializing-and-deserializing","title":"Serializing and Deserializing","text":"<p>Each component has its own serialization and deserialization mechanism. You can align Stove's serialization and deserialization mechanism with your application's serialization and deserialization mechanism.</p> <p>Stove works with multiple serializers and deserializers. The package <code>stove-testing-e2e</code> provides the following serializers and deserializers:</p> <ul> <li>Jackson</li> <li>Gson</li> <li>Kotlinx</li> </ul> <p>Stove also provides a way to add your own serializer and deserializer. You can implement the <code>StoveSerde&lt;TIn, TOut&gt;</code> interface and add your own serializer and deserializer.</p> <p><code>StoveSerde</code> also keeps the reference to the aforementioned libraries:</p> <pre><code>StoveSerde.jackson \nStoveSerde.gson\nStoveSerde.kotlinx\n</code></pre> <p>And also provides default implementations for them:</p> <pre><code>StoveSerde.jackson.anyByteArraySerde(yourObjectMapper())\nStoveSerde.gson.anyByteArraySerde(yourGson())\nStoveSerde.kotlinx.anyByteArraySerde(yourJson())\n\n// there is also string serde\nStoveSerde.jackson.anyStringSerde(yourObjectMapper())\nStoveSerde.gson.anyStringSerde(yourGson())\nStoveSerde.kotlinx.anyStringSerde(yourJson())\n</code></pre>"},{"location":"#replacing-dependencies-for-better-testability","title":"Replacing Dependencies For Better Testability","text":"<p>When it comes to handling the time, no one wants to wait for 30 minutes for a scheduler job, or for a delayed task to be able to test it. In these situations what we need to do is <code>advancing</code> the time, or replacing the effect of the time for our needs. This may require you to change your code, too. Because, we might need to provide a time-free implementation to an interface, or we might need to extract it to an interface if not properly implemented.</p> <p>For example, in international-service project we have a delayed command executor that accepts a task and a time for it to delay it until it is right time to execute. But, in tests we need to replace this behaviour with the time-effect free implementation.</p> <pre><code>class BackgroundCommandBusImpl // is the class for delayed operations\n</code></pre> <p>We would like to by-pass the time-bounded logic inside BackgroundCommandBusImpl, and for e2eTest scope we write:</p> <pre><code>class NoDelayBackgroundCommandBusImpl(\n  backgroundMessageEnvelopeDispatcher: BackgroundMessageEnvelopeDispatcher,\n  backgroundMessageEnvelopeStorage: BackgroundMessageEnvelopeStorage,\n  lockProvider: CouchbaseLockProvider,\n) : BackgroundCommandBusImpl(\n  backgroundMessageEnvelopeDispatcher,\n  backgroundMessageEnvelopeStorage,\n  lockProvider\n) {\n\n  override suspend fun &lt;TNotification : BackgroundNotification&gt; publish(\n    notification: TNotification,\n    options: BackgroundOptions,\n  ) {\n    super.publish(notification, options.withDelay(0))\n  }\n\n  override suspend fun &lt;TCommand : BackgroundCommand&gt; send(\n    command: TCommand,\n    options: BackgroundOptions,\n  ) {\n    super.send(command, options.withDelay(0))\n  }\n}\n</code></pre> <p>Now, it is time to tell to e2eTest system to use NoDelay implementation.</p> <p>That brings us to initializers.</p>"},{"location":"#writing-your-own-testsystem","title":"Writing Your Own TestSystem","text":"<pre><code>fun TestSystem.withSchedulerSystem(): TestSystem {\n  getOrRegister(SchedulerSystem(this))\n  return this\n}\n\nfun TestSystem.scheduler(): SchedulerSystem = getOrNone&lt;SchedulerSystem&gt;().getOrElse {\n  throw SystemNotRegisteredException(SchedulerSystem::class)\n}\n\nclass SchedulerSystem(override val testSystem: TestSystem) : AfterRunAware&lt;ApplicationContext&gt;, PluggedSystem {\n\n  private lateinit var scheduler: WaitingRoomScheduler\n  private lateinit var backgroundCommandBus: BackgroundCommandBusImpl\n\n  fun advance(): SchedulerSystem {\n    scheduler.publishValidProducts()\n    return this\n  }\n\n  fun advanceBackgroundCommandBus(): SchedulerSystem {\n    backgroundCommandBus.dispatchTimeoutNotifications()\n    return this\n  }\n\n  override suspend fun afterRun(context: ApplicationContext) {\n    scheduler = context.getBean()\n    backgroundCommandBus = context.getBean()\n  }\n\n  override fun close() {}\n}\n</code></pre> <p>Later you can use it in testing;</p> <pre><code>validate {\n  scheduler {\n    advance()\n  }\n}\n</code></pre>"},{"location":"#accessing-an-application-dependency-with-a-system","title":"Accessing an application dependency with a system","text":"<p>As you can see, in the example above, if a system implements <code>AfterRunAware&lt;ApplicationContext&gt;</code> then, <code>afterRun</code> method becomes available, in here we have access to applications dependency container to resolve any bean we need to use.</p> <pre><code>override suspend fun afterRun(context: ApplicationContext) {\n  scheduler = context.getBean()\n  backgroundCommandBus = context.getBean()\n}\n</code></pre>"},{"location":"#writing-a-testinitializer","title":"Writing a TestInitializer","text":"<p>The tests initializers help you to add test scoped beans, basically you can configure the Spring application from the test perspective.</p> <pre><code>class TestInitializer : BaseApplicationContextInitializer({\n  bean&lt;YourInstanceToReplace&gt;(isPrimary = true)\n  bean&lt;NoDelayBackgroundCommandBusImpl&gt;(isPrimary = true) // Optional dependency to alter delayed implementation with 0-wait.\n})\n\nfun SpringApplication.addTestDependencies() {\n  this.addInitializers(TestInitializer())\n}\n</code></pre> <p><code>addTestDependencies</code> is an extension that helps us to register our dependencies in the application.</p> <pre><code>.springBoot(\n  runner = { parameters -&gt;\n    com.trendyol.exampleapp.run(parameters) {\n      addTestDependencies()\n    }\n  },\n  withParameters = listOf(\n    \"logging.level.root=error\",\n    \"logging.level.org.springframework.web=error\",\n    \"spring.profiles.active=default\",\n    \"server.http2.enabled=false\",\n    \"kafka.heartbeatInSeconds=2\",\n    \"kafka.autoCreateTopics=true\",\n    \"kafka.offset=earliest\"\n  )\n)\n</code></pre>"},{"location":"Components/","title":"Dependencies","text":"<p>All the dependencies are pluggable. Stove supports:</p> <ul> <li>Couchbase</li> <li>Kafka</li> <li>Elasticsearch</li> <li>Wiremock</li> <li>Http client</li> <li>Postgres Sql</li> <li>MongoDB</li> <li>Mssql</li> <li>Redis</li> </ul>"},{"location":"Components/01-couchbase/","title":"Couchbase","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-couchbase:$version\")\n    }\n</code></pre>"},{"location":"Components/01-couchbase/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>couchbase</code> function. This function configures the Couchbase Docker container that is going to be started.</p> <p>Here you can define a <code>defaultBucket</code> name.</p> <p>Warning</p> <p>Make sure that your application has the same bucket names.</p> <pre><code>TestSystem()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(defaultBucket = \"test-bucket\", configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      })\n    }\n  }\n  .run()\n</code></pre> <p>Stove exposes configuration that is generated by the execution, so you can pass the real connection strings and configurations to your Spring application before it starts. Your application will start with the physical dependencies that are spun-up by the framework.</p>"},{"location":"Components/01-couchbase/#migrations","title":"Migrations","text":"<p>Stove provides a way to run migrations before the test starts.</p> <pre><code>class CouchbaseMigration : DatabaseMigration&lt;Cluster&gt; {\n  override val order: Int = 1\n\n  override suspend fun execute(connection: Cluster) {\n    val bucket = connection.bucket(CollectionConstants.BUCKET_NAME)\n    listOf(CollectionConstants.PRODUCT_COLLECTION).forEach { collection -&gt;\n      bucket.collections.createCollection(bucket.defaultScope().name, collection)\n    }\n    connection.waitUntilReady(30.seconds)\n  }\n}\n</code></pre> <p>You can define your migration class by implementing the <code>DatabaseMigration</code> interface. You can define the order of the migration by overriding the <code>order</code> property. The migrations will be executed in the order of the <code>order</code> property.</p> <p>After defining your migration class, you can pass it to the <code>migrations</code> function of the <code>couchbase</code> configuration.</p> <pre><code>TestSystem()\n  .with {\n    couchbase {\n      CouchbaseSystemOptions(defaultBucket = \"test-bucket\", configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"couchbase.hosts=${cfg.hostsWithPort}\",\n          \"couchbase.username=${cfg.username}\",\n          \"couchbase.password=${cfg.password}\"\n        )\n      }).migrations&lt;CouchbaseMigration&gt;()\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/02-kafka/","title":"Kafka","text":"<p>There are two ways to work with Kafka in Stove. You can use standalone Kafka or Kafka with Spring. You can use only one of them in your project.</p>"},{"location":"Components/02-kafka/#standalone-kafka","title":"Standalone Kafka","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-kafka:$version\")\n    }\n</code></pre>"},{"location":"Components/02-kafka/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    // other dependencies\n\n    kafka {\n      stoveKafkaObjectMapperRef = objectMapperRef\n      KafkaSystemOptions {\n        listOf(\n          \"kafka.bootstrapServers=${it.bootstrapServers}\",\n          \"kafka.interceptorClasses=${it.interceptorClass}\"\n        )\n      }\n    }\n  }.run()\n</code></pre> <p>The configuration values are:</p> <pre><code>class KafkaSystemOptions(\n  /**\n   * Suffixes for error and retry topics in the application.\n   */\n  val topicSuffixes: TopicSuffixes = TopicSuffixes(),\n  /**\n   * If true, the system will listen to the messages published by the Kafka system.\n   */\n  val listenPublishedMessagesFromStove: Boolean = false,\n  /**\n   * The port of the bridge gRPC server that is used to communicate with the Kafka system.\n   */\n  val bridgeGrpcServerPort: Int = stoveKafkaBridgePortDefault.toInt(),\n  /**\n   * The Serde that is used while asserting the messages,\n   * serializing while bridging the messages. Take a look at the [serde] property for more information.\n   *\n   * The default value is [StoveSerde.jackson]'s anyByteArraySerde.\n   * Depending on your application's needs you might want to change this value.\n   *\n   * The places where it was used listed below:\n   *\n   * @see [com.trendyol.stove.testing.e2e.standalone.kafka.intercepting.StoveKafkaBridge] for bridging the messages.\n   * @see StoveKafkaValueSerializer for serializing the messages.\n   * @see StoveKafkaValueDeserializer for deserializing the messages.\n   * @see valueSerializer for serializing the messages.\n   */\n  val serde: StoveSerde&lt;Any, ByteArray&gt; = stoveSerdeRef,\n  /**\n   * The Value serializer that is used to serialize messages.\n   */\n  val valueSerializer: Serializer&lt;Any&gt; = StoveKafkaValueSerializer(),\n  /**\n   * The options for the Kafka container.\n   */\n  val containerOptions: KafkaContainerOptions = KafkaContainerOptions(),\n  /**\n   * The options for the Kafka system that is exposed to the application\n   */\n  override val configureExposedConfiguration: (KafkaExposedConfiguration) -&gt; List&lt;String&gt;\n) : SystemOptions, ConfiguresExposedConfiguration&lt;KafkaExposedConfiguration&gt;\n</code></pre>"},{"location":"Components/02-kafka/#configuring-serializer-and-deserializer","title":"Configuring Serializer and Deserializer","text":"<p>Like every <code>SystemOptions</code> object, <code>KafkaSystemOptions</code> has a <code>serde</code> property that you can configure. It is a <code>StoveSerde</code> object that has two functions <code>serialize</code> and <code>deserialize</code>. You can configure them depending on your application's needs.</p> <pre><code>val kafkaSystemOptions = KafkaSystemOptions(\n  serde = object : StoveSerde&lt;Any, ByteArray&gt; {\n    override fun serialize(value: Any): ByteArray {\n      return objectMapper.writeValueAsBytes(value)\n    }\n\n    override fun &lt;T&gt; deserialize(value: ByteArray): T {\n      return objectMapper.readValue(value, Any::class.java) as T\n    }\n  }\n)\n</code></pre>"},{"location":"Components/02-kafka/#kafka-bridge-with-your-application","title":"Kafka Bridge With Your Application","text":"<p>Stove Kafka bridge is a MUST to work with Kafka. Otherwise you can't assert any messages from your application.</p> <p>As you can see in the example above, you need to add a support to your application to work with interceptor that Stove provides.</p> <pre><code> \"kafka.interceptorClasses=com.trendyol.stove.testing.e2e.standalone.kafka.intercepting.StoveKafkaBridge\"\n\n// or\n\n\"kafka.interceptorClasses={cfg.interceptorClass}\" // cfg.interceptorClass is exposed by Stove\n</code></pre> <p>Important</p> <p><code>kafka.</code> prefix or <code>interceptorClasses</code> are assumptions that you can change it with your own prefix or configuration.</p>"},{"location":"Components/02-kafka/#spring-kafka","title":"Spring Kafka","text":"<p>When you want to use Kafka with Application Aware testing it provides more assertion capabilities. It is recommended way of working. Stove-Kafka does that with intercepting the messages.</p>"},{"location":"Components/02-kafka/#how-to-get","title":"How to get?","text":"GradleMaven <pre><code>    dependencies {\n      testImplementation(\"com.trendyol:stove-spring-testing-e2e-kafka:$version\")\n    }\n</code></pre> <pre><code> &lt;dependency&gt;\n    &lt;groupId&gt;com.trendyol&lt;/groupId&gt;\n    &lt;artifactId&gt;stove-spring-testing-e2e-kafka&lt;/artifactId&gt;\n    &lt;version&gt;${stove-version}&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>"},{"location":"Components/02-kafka/#configure_1","title":"Configure","text":""},{"location":"Components/02-kafka/#configuration-values","title":"Configuration Values","text":"<p>Kafka works with some settings as default, your application might have these values as not configurable, to make the application testable we need to tweak a little bit.</p> <p>If you have the following configurations:</p> <ul> <li><code>AUTO_OFFSET_RESET_CONFIG | \"auto.offset.reset\" | should be \"earliest\"</code></li> <li><code>ALLOW_AUTO_CREATE_TOPICS_CONFIG | \"allow.auto.create.topics\" | should be true</code></li> <li><code>HEARTBEAT_INTERVAL_MS_CONFIG | \"heartbeat.interval.ms\" | should be 2 seconds</code></li> </ul> <p>You better make them configurable, so from the e2e testing context we can change them work with Stove-Kafka testing.</p> <p>As an example:</p> <pre><code>TestSystem()\n  .with {\n    httpClient()\n    kafka()\n    springBoot(\n      runner = { parameters -&gt;\n        com.trendyol.exampleapp.run(parameters)\n      },\n      withParameters = listOf(\n        \"logging.level.root=error\",\n        \"logging.level.org.springframework.web=error\",\n        \"spring.profiles.active=default\",\n        \"server.http2.enabled=false\",\n        \"kafka.heartbeatInSeconds=2\",\n        \"kafka.autoCreateTopics=true\",\n        \"kafka.offset=earliest\"\n      )\n    )\n  }.run()\n</code></pre> <p>As you can see, we pass these configuration values as parameters. Since they are configurable, the application considers these values instead of application-default values.</p>"},{"location":"Components/02-kafka/#consumer-settings","title":"Consumer Settings","text":"<p>Second thing we need to do is tweak your consumer configuration. For that we will provide Stove-Kafka interceptor to your Kafka configuration.</p> <p>Locate to the point where you define your <code>ConcurrentKafkaListenerContainerFactory</code> or where you can set the interceptor. Interceptor needs to implement <code>ConsumerAwareRecordInterceptor&lt;String, String&gt;</code> since Stove-Kafka relies on that.</p> <pre><code>@EnableKafka\n@Configuration\nclass KafkaConsumerConfiguration(\n  private val interceptor: ConsumerAwareRecordInterceptor&lt;String, String&gt;,\n) {\n\n  @Bean\n  fun kafkaListenerContainerFactory(): ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; {\n    val factory = ConcurrentKafkaListenerContainerFactory&lt;String, String&gt;()\n    // ...\n    factory.setRecordInterceptor(interceptor)\n    return factory\n  }\n}\n</code></pre>"},{"location":"Components/02-kafka/#producer-settings","title":"Producer Settings","text":"<p>Make sure that the aforementioned values are also configurable for producer settings, too. Stove will have access to <code>KafkaTemplate</code> and will use <code>setProducerListener</code> to arrange itself to listen produced messages.</p>"},{"location":"Components/02-kafka/#plugging-in","title":"Plugging in","text":"<p>When all the configuration is done, it is time to tell to application to use our <code>TestSystemInterceptor</code> and configuration values.</p>"},{"location":"Components/02-kafka/#testsysteminterceptor-and-testinitializer","title":"TestSystemInterceptor and TestInitializer","text":"<pre><code>class TestInitializer : BaseApplicationContextInitializer({\n  bean&lt;TestSystemInterceptor&gt;(isPrimary = true)\n  bean { StoveSerde.jackson.anyByteArraySerde(yourObjectMapper()) } // or any serde that implements StoveSerde&lt;Any, ByteArray&gt;\n})\n\nfun SpringApplication.addTestDependencies() {\n  this.addInitializers(TestInitializer())\n}\n</code></pre>"},{"location":"Components/02-kafka/#configuring-the-systemundertest-and-parameters","title":"Configuring the SystemUnderTest and Parameters","text":"<p><code>addTestDependencies</code> is an extension that helps us to register our dependencies in the application.</p> <pre><code>springBoot(\n  runner = { parameters -&gt;\n    com.trendyol.exampleapp.run(parameters) {\n      addTestDependencies() // Enable TestInitializer with extensions call\n    }\n  },\n  withParameters = listOf(\n    \"logging.level.root=error\",\n    \"logging.level.org.springframework.web=error\",\n    \"spring.profiles.active=default\",\n    \"server.http2.enabled=false\",\n    \"kafka.heartbeatInSeconds=2\", // Added Parameter\n    \"kafka.autoCreateTopics=true\", // Added Parameter\n    \"kafka.offset=earliest\" // Added Parameter\n  )\n)\n</code></pre> <p>Now you're full set and have control over Kafka messages from the testing context.</p> <pre><code>TestSystem.validate {\n  kafka {\n    shouldBeConsumed&lt;AnyEvent&gt; { actual -&gt; }\n    shouldBePublished&lt;AnyEvent&gt; { actual -&gt; }\n  }\n}\n</code></pre>"},{"location":"Components/03-elasticsearch/","title":"Elasticsearch","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-elasticsearch:$version\")\n    }\n</code></pre>"},{"location":"Components/03-elasticsearch/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>elasticsearch</code> function. This function configures the Elasticsearch Docker container that is going to be started.</p> <pre><code>TestSystem()\n  .with {\n    elasticsearch {\n      ElasticsearchSystemOptions(configureExposedConfiguration = { cfg -&gt;\n        listOf(\n          \"elasticsearch.hosts=${cfg.hostsWithPort}\",\n          \"elasticsearch.username=${cfg.username}\",\n          \"elasticsearch.password=${cfg.password}\"\n        )\n      })\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/04-wiremock/","title":"Wiremock","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-wiremock:$version\")\n    }\n</code></pre>"},{"location":"Components/04-wiremock/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>wiremock</code> function.</p> <p>This will start an instance of Wiremock server. You can configure the port of the Wiremock server.</p> <pre><code>TestSystem()\n  .with {\n    wiremock {\n      WiremockSystemOptions(\n        port = 8080,\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/04-wiremock/#options","title":"Options","text":"<pre><code>data class WireMockSystemOptions(\n  /**\n   * Port of wiremock server\n   */\n  val port: Int = 9090,\n  /**\n   * Configures wiremock server\n   */\n  val configure: WireMockConfiguration.() -&gt; WireMockConfiguration = { this.notifier(ConsoleNotifier(true)) },\n  /**\n   * Removes the stub when request matches/completes\n   * Default value is false\n   */\n  val removeStubAfterRequestMatched: Boolean = false,\n  /**\n   * Called after stub removed\n   */\n  val afterStubRemoved: AfterStubRemoved = { _, _ -&gt; },\n  /**\n   * Called after request handled\n   */\n  val afterRequest: AfterRequestHandler = { _, _ -&gt; },\n  /**\n   * ObjectMapper for serialization/deserialization\n   */\n  val serde: StoveSerde&lt;Any, ByteArray&gt; = StoveSerde.jackson.anyByteArraySerde()\n) : SystemOptions\n</code></pre>"},{"location":"Components/04-wiremock/#mocking","title":"Mocking","text":"<p>Wiremock starts a mock server on the <code>localhost</code> with the given port. The important thing is that you use the same port in your application for your services.</p> <p>Say, your application calls an external service in your production configuration as: <code>http://externalservice.com/api/product/get-all</code> you need to replace the base url of this an all the external services with the Wiremock host and port: <code>http://localhost:9090</code></p> <p>You can either do this in your application configuration, or let Stove send this as a command line argument to your application.</p> <pre><code>TestSystem()\n  .with {\n    wiremock {\n      WireMockSystemOptions(\n        port = 9090,\n      )\n    }\n    springBoot( // or ktor\n      runner = {\n        // ...\n      },\n      withParameters = listOf(\n        \"externalServiceBaseUrl=http://localhost:9090\",\n        \"otherService1BaseUrl=http://localhost:9090\",\n        \"otherService2BaseUrl=http://localhost:9090\"\n      )\n    )\n  }\n  .run()\n</code></pre> <p>All service endpoints will be pointing to the Wiremock server. You can now define the stubs for the services that your application calls.</p> <pre><code>wiremock {\n  mockGet(\"/api/product/get-all\", 200, lisOf(Product(\"1\", \"Product 1\"), Product(\"2\", \"Product 2\")).some())\n}\n</code></pre> <p>Relative url is mocked. BaseUrl is known by Wiremock server since it hosts it, and your application because you passed it as a command line argument.</p>"},{"location":"Components/04-wiremock/#behavioural-mocking","title":"Behavioural Mocking","text":"<p>Sometimes, a service call returns a failure response before a success response. You can define this behaviour with behavioural mocking.</p> <pre><code>test(\"behavioural tests\") {\n  val expectedGetDtoName = UUID.randomUUID().toString()\n  TestSystem.validate {\n    wiremock {\n      behaviourFor(\"/get-behaviour\", WireMock::get) {\n        initially {\n          aResponse()\n            .withStatus(503)\n            .withBody(\"Service unavailable\")\n        }\n        then {\n          aResponse()\n            .withHeader(\"Content-Type\", \"application/json\")\n            .withStatus(200)\n            .withBody(it.serialize(TestDto(expectedGetDtoName)))\n        }\n      }\n    }\n    http {\n      this.getResponse(\"/get-behaviour\") { actual -&gt;\n        actual.status shouldBe 503\n      }\n      get&lt;TestDto&gt;(\"/get-behaviour\") { actual -&gt;\n        actual.name shouldBe expectedGetDtoName\n      }\n    }\n  }\n}\n</code></pre> <p>Here we define a behaviour for the <code>/get-behaviour</code> endpoint. Initially, it returns a 503 status code with a message. Then, it returns a 200 status code with a <code>TestDto</code> object.</p>"},{"location":"Components/05-http/","title":"HttpClient","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-http:$version\")\n    }\n</code></pre>"},{"location":"Components/05-http/#configure","title":"Configure","text":"<p>After getting the library from the maven source, while configuring TestSystem you will have access to <code>http</code></p> <pre><code>TestSystem()\n  .with {\n    http {\n      HttpClientSystemOptions(\n        baseUrl = \"http://localhost:8080\",\n      )\n    }\n  }\n  .run()\n</code></pre> <p>The other options that you can set are: <pre><code>data class HttpClientSystemOptions(\n  /**\n   * Base URL of the HTTP client.\n   */\n  val baseUrl: String,\n\n  /**\n   * Content converter for the HTTP client. Default is JacksonConverter. You can use GsonConverter or any other converter.\n   * If you want to use your own converter, you can implement ContentConverter interface.\n   */\n  val contentConverter: ContentConverter = JacksonConverter(StoveSerde.jackson.default),\n\n  /**\n   * Timeout for the HTTP client. Default is 30 seconds.\n   */\n  val timeout: Duration = 30.seconds,\n\n  /**\n   * Create client function for the HTTP client. Default is jsonHttpClient.\n   */\n  val createClient: () -&gt; io.ktor.client.HttpClient = { jsonHttpClient(timeout, contentConverter) }\n)\n</code></pre></p>"},{"location":"Components/05-http/#usage","title":"Usage","text":"<pre><code>validate {\n  http {\n    get&lt;YourResponse&gt;(\"/relative-url\") { actual -&gt;\n      actual shouldBe expected\n    }\n  }\n}\n</code></pre>"},{"location":"Components/06-postgresql/","title":"Postgresql","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-rdbms-postgres:$version\")\n    }\n</code></pre>"},{"location":"Components/06-postgresql/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    postgresql {\n      PostgresqlSystemOptions {\n        listOf(\n          \"postgresql.host=${it.host}\",\n          \"postgresql.port=${it.port}\",\n          \"postgresql.database=${it.database}\",\n          \"postgresql.username=${it.username}\",\n          \"postgresql.password=${it.password}\"\n        )\n      }\n    }\n  }.run()\n</code></pre>"},{"location":"Components/06-postgresql/#usage","title":"Usage","text":"<pre><code>TestSystem.validate {\n  postgresql {\n    shouldExecute(\n      \"\"\"\n              DROP TABLE IF EXISTS Dummies;                    \n              CREATE TABLE IF NOT EXISTS Dummies (\n                id serial PRIMARY KEY,\n                description VARCHAR (50)  NOT NULL\n              );\n      \"\"\".trimIndent()\n    )\n    shouldExecute(\"INSERT INTO Dummies (description) VALUES ('${testCase.name.testName}')\")\n    shouldQuery&lt;IdAndDescription&gt;(\"SELECT * FROM Dummies\", mapper = {\n      IdAndDescription(it.getLong(\"id\"), it.getString(\"description\"))\n    }) { actual -&gt;\n      actual.size shouldBeGreaterThan 0\n      actual.first().description shouldBe testCase.name.testName\n    }\n  }\n}\n</code></pre>"},{"location":"Components/07-mongodb/","title":"Mongodb","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-mongodb:$version\")\n    }\n</code></pre>"},{"location":"Components/07-mongodb/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    mongodb {\n      MongodbSystemOptions(\n        listOf(\n          \"mongodb.host=${it.host}\",\n          \"mongodb.port=${it.port}\",\n          \"mongodb.database=${it.database}\",\n          \"mongodb.username=${it.username}\",\n          \"mongodb.password=${it.password}\"\n        )\n      )\n    }\n  }\n  .run()\n</code></pre>"},{"location":"Components/07-mongodb/#usage","title":"Usage","text":"<pre><code>test(\"should save and get with string objectId\") {\n  val id = ObjectId()\n  validate {\n    mongodb {\n      save(\n        ExampleInstanceWithStringObjectId(\n          id = id.toHexString(),\n          aggregateId = id.toHexString(),\n          description = testCase.name.testName\n        ),\n        id.toHexString()\n      )\n      shouldGet&lt;ExampleInstanceWithStringObjectId&gt;(id.toHexString()) { actual -&gt;\n        actual.aggregateId shouldBe id.toHexString()\n        actual.description shouldBe testCase.name.testName\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/08-mssql/","title":"Postgresql","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-rdbms-mssql:$version\")\n    }\n</code></pre>"},{"location":"Components/08-mssql/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    mssql {\n      MssqlSystemOptions {\n        listOf(\n          \"mssql.host=${it.host}\",\n          \"mssql.port=${it.port}\",\n          \"mssql.database=${it.database}\",\n          \"mssql.username=${it.username}\",\n          \"mssql.password=${it.password}\"\n        )\n      }\n    }\n  }.run()\n</code></pre>"},{"location":"Components/08-mssql/#usage","title":"Usage","text":"<pre><code>validate {\n  mssql {\n    ops {\n      val result = select(\"SELECT 1\") {\n        it.getInt(1)\n      }\n      result.first() shouldBe 1\n    }\n    shouldExecute(\"insert into Person values (1, 'Doe', 'John', '123 Main St', 'Springfield')\")\n    shouldQuery&lt;Person&gt;(\n      query = \"select * from Person\",\n      mapper = {\n        Person(\n          it.getInt(1),\n          it.getString(2),\n          it.getString(3),\n          it.getString(4),\n          it.getString(5)\n        )\n      }\n    ) { result -&gt;\n      result.size shouldBe 1\n      result.first().apply {\n        personId shouldBe 1\n        lastName shouldBe \"Doe\"\n        firstName shouldBe \"John\"\n        address shouldBe \"123 Main St\"\n        city shouldBe \"Springfield\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Components/09-redis/","title":"Redis","text":"Gradle <pre><code>    dependencies {\n        testImplementation(\"com.trendyol:stove-testing-e2e-redis:$version\")\n    }\n</code></pre>"},{"location":"Components/09-redis/#configure","title":"Configure","text":"<pre><code>TestSystem()\n  .with {\n    redis {\n      RedisSystemOptions {\n        listOf(\n          \"redis.host=${it.host}\",\n          \"redis.port=${it.port}\",\n          \"redis.password=${it.password}\"\n        )\n      }\n    }\n  }.run()\n</code></pre>"},{"location":"Components/09-redis/#usage","title":"Usage","text":"<p>There is not much to do with Redis. You can use the <code>RedisSystem</code> object to interact with the Redis instance.</p> <p>There is an extension function called <code>client</code> that gives the access to the underlying redis client of <code>RedisSystem</code>.</p> <p>You can create any extension on top of <code>client</code> to interact with Redis.</p> <pre><code>class RedisSystem {\n  // Reference to the Redis client, this is already located in RedisSystem.\n  companion object {\n    fun RedisSystem.client(): RedisClient {\n      if (!isInitialized()) throw SystemNotInitializedException(RedisSystem::class)\n      return client\n    }\n  }\n}\n</code></pre> <p>Your tests:</p> <pre><code>validate {\n  redis {\n    client().use { client -&gt;\n      client.set(\"key\", \"value\")\n      val value = client.get(\"key\")\n      value shouldBe \"value\"\n    }\n  }\n}\n</code></pre>"},{"location":"migration/notes/","title":"Migration Notes","text":""},{"location":"migration/notes/#from-014x-to-015x","title":"From 0.14.x to 0.15.x","text":""},{"location":"migration/notes/#breaking-changes","title":"Breaking Changes","text":"<p>The most notable breaking change is ser/de operations. The framework was only relying on Jackson for serialization and deserialization. Now, it provides a way to use other serialization libraries. <code>StoveSerde&lt;TIn, TOut&gt;</code> is the new interface that you can implement to provide your own serialization and deserialization logic.</p> <p><code>StoveSerde</code> also provides the access to the other serializers that <code>com-trendyol:stove-testing-e2e</code> package has.</p> <ul> <li>Jackson</li> <li>Gson</li> <li>Kotlinx</li> </ul> <p>Also look at ser/de section: Serialization and Deserialization</p>"},{"location":"migration/notes/#spring-kafka-com-trendyolstove-spring-testing-e2e-kafka","title":"Spring Kafka (com-trendyol:stove-spring-testing-e2e-kafka)","text":"<p>The <code>TestSystemKafkaInterceptor</code> now depends on <code>StoveSerde</code> to provide the serialization and deserialization logic instead of <code>ObjectMapper</code>.</p> <p>You can of course use your default Jackson implementation by providing the <code>ObjectMapperConfig.default()</code> to the <code>StoveSerde.jackson.anyByteArraySerde</code> function.</p> <pre><code>class TestSystemInitializer : BaseApplicationContextInitializer({\n  bean&lt;TestSystemKafkaInterceptor&lt;*, *&gt;&gt;(isPrimary = true)\n  bean { StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfig.default()) } // or any other serde that is &lt;Any, ByteArray&gt;\n})\n</code></pre>"},{"location":"migration/notes/#standalone-kafka","title":"Standalone Kafka","text":"<pre><code>kafka {\n  KafkaSystemOptions(\n    serde = StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfig.default) // or any other serde that is &lt;Any, ByteArray&gt;\n    //...\n  )\n}\n</code></pre>"},{"location":"migration/notes/#couchbase","title":"Couchbase","text":"<pre><code>couchbase {\n  CouchbaseSystemOptions(\n    clusterSerDe = JacksonJsonSerializer(CouchbaseConfiguration.objectMapper), // here you can provide your own serde\n    //...\n  )\n}\n</code></pre>"},{"location":"migration/notes/#http","title":"Http","text":"<pre><code> httpClient {\n  HttpClientSystemOptions(\n    baseUrl = \"http://localhost:8001\",\n    contentConverter = JacksonConverter(ObjectMapperConfig.default)\n  )\n}\n</code></pre>"},{"location":"migration/notes/#wiremock","title":"Wiremock","text":"<pre><code>wiremock {\n  WireMockSystemOptions(\n    port = 9090,\n    serde = StoveSerde.jackson.anyByteArraySerde(ObjectMapperConfiguration.default)\n  )\n</code></pre>"},{"location":"migration/notes/#elasticsearch","title":"Elasticsearch","text":"<pre><code>elasticsearch {\n  ElasticsearchSystemOptions(\n    jsonpMapper = JacksonJsonpMapper(StoveSerde.jackson.default), // or any JsonpMapper\n  )\n}\n</code></pre>"},{"location":"migration/notes/#mongodb","title":"Mongodb","text":"<pre><code>mongodb {\n  MongoDbSystemOptions(\n    serde = StoveSerde.jackson.default // or any other serde that you implement\n  )\n}\n</code></pre> <p>The default serde is: <pre><code>  val serde: StoveSerde&lt;Any, String&gt; = StoveSerde.jackson.anyJsonStringSerde(\n    StoveSerde.jackson.byConfiguring {\n      disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n      enable(MapperFeature.DEFAULT_VIEW_INCLUSION)\n      addModule(ObjectIdModule())\n      addModule(KotlinModule.Builder().build())\n    }\n  ),\n</code></pre></p>"}]}